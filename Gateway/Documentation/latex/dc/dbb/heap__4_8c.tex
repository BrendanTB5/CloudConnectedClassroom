\hypertarget{heap__4_8c}{}\section{third\+\_\+party/freertos/portable/memmang/heap\+\_\+4.c File Reference}
\label{heap__4_8c}\index{third\+\_\+party/freertos/portable/memmang/heap\+\_\+4.\+c@{third\+\_\+party/freertos/portable/memmang/heap\+\_\+4.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include \char`\"{}Free\+R\+T\+O\+S.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}task.\+h\char`\"{}}\newline
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structA__BLOCK__LINK}{A\+\_\+\+B\+L\+O\+C\+K\+\_\+\+L\+I\+NK}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{heap__4_8c_ab622d8c674f2a417a666a7ed89109e79}{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}
\item 
\#define \hyperlink{heap__4_8c_ab71bae5a95671265c828339d44c44b25}{heap\+M\+I\+N\+I\+M\+U\+M\+\_\+\+B\+L\+O\+C\+K\+\_\+\+S\+I\+ZE}~( ( size\+\_\+t ) ( \hyperlink{heap__5_8c_aff7bec0da6b44e3634d215b40eb1db76}{x\+Heap\+Struct\+Size} $<$$<$ 1 ) )
\item 
\#define \hyperlink{heap__4_8c_adcef0c4245ebe20ca2b08a574c1caac9}{heap\+B\+I\+T\+S\+\_\+\+P\+E\+R\+\_\+\+B\+Y\+TE}~( ( size\+\_\+t ) 8 )
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structA__BLOCK__LINK}{A\+\_\+\+B\+L\+O\+C\+K\+\_\+\+L\+I\+NK} \hyperlink{heap__4_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{heap__4_8c_a1a70fdf86d8a603f45e9b93c14e0d24a}{prv\+Insert\+Block\+Into\+Free\+List} (\hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t} $\ast$px\+Block\+To\+Insert)
\item 
static void \hyperlink{heap__4_8c_a3e55181f788f17d9a3e7d226a5206e4f}{prv\+Heap\+Init} (void)
\item 
void $\ast$ \hyperlink{heap__4_8c_a0379669d07d76cc81e3028123113b271}{pv\+Port\+Malloc} (size\+\_\+t x\+Wanted\+Size)
\item 
void \hyperlink{heap__4_8c_a1e7cea2fd1bc894ea3b5f5e8179d259b}{v\+Port\+Free} (void $\ast$pv)
\item 
size\+\_\+t \hyperlink{heap__4_8c_a0c28a12b313bc248be0cb7a37ed81bb7}{x\+Port\+Get\+Free\+Heap\+Size} (void)
\item 
size\+\_\+t \hyperlink{heap__4_8c_ab222e4545b8ff12b62fd000fea6b34eb}{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size} (void)
\item 
void \hyperlink{heap__4_8c_a8bf103ce32ce8473574e9920af8b4eec}{v\+Port\+Initialise\+Blocks} (void)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} \hyperlink{heap__4_8c_a286aa29b13471f0d9f5a7ce688682694}{uc\+Heap} \mbox{[}\hyperlink{FreeRTOSConfig_8h_a9f213227674effff0122a75d94d87938}{config\+T\+O\+T\+A\+L\+\_\+\+H\+E\+A\+P\+\_\+\+S\+I\+ZE}\mbox{]}
\item 
static const size\+\_\+t \hyperlink{heap__4_8c_aff7bec0da6b44e3634d215b40eb1db76}{x\+Heap\+Struct\+Size} = ( sizeof( \hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t} ) + ( ( size\+\_\+t ) ( \hyperlink{pic32mz_2portmacro_8h_ab9091ce3940d8bd93ec850122a2c6a1c}{port\+B\+Y\+T\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT} -\/ 1 ) ) ) \& $\sim$( ( size\+\_\+t ) port\+B\+Y\+T\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+N\+T\+\_\+\+M\+A\+SK )
\item 
static \hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t} \hyperlink{heap__4_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}{x\+Start}
\item 
static \hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t} $\ast$ \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{px\+End} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL}
\item 
static size\+\_\+t \hyperlink{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}{x\+Free\+Bytes\+Remaining} = 0U
\item 
static size\+\_\+t \hyperlink{heap__4_8c_ae88e8dc4d81326f752232a0a39eb119f}{x\+Minimum\+Ever\+Free\+Bytes\+Remaining} = 0U
\item 
static size\+\_\+t \hyperlink{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}{x\+Block\+Allocated\+Bit} = 0
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{heap__4_8c_adcef0c4245ebe20ca2b08a574c1caac9}\label{heap__4_8c_adcef0c4245ebe20ca2b08a574c1caac9}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!heap\+B\+I\+T\+S\+\_\+\+P\+E\+R\+\_\+\+B\+Y\+TE@{heap\+B\+I\+T\+S\+\_\+\+P\+E\+R\+\_\+\+B\+Y\+TE}}
\index{heap\+B\+I\+T\+S\+\_\+\+P\+E\+R\+\_\+\+B\+Y\+TE@{heap\+B\+I\+T\+S\+\_\+\+P\+E\+R\+\_\+\+B\+Y\+TE}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{heap\+B\+I\+T\+S\+\_\+\+P\+E\+R\+\_\+\+B\+Y\+TE}{heapBITS\_PER\_BYTE}}
{\footnotesize\ttfamily \#define heap\+B\+I\+T\+S\+\_\+\+P\+E\+R\+\_\+\+B\+Y\+TE~( ( size\+\_\+t ) 8 )}



Definition at line 56 of file heap\+\_\+4.\+c.

\mbox{\Hypertarget{heap__4_8c_ab71bae5a95671265c828339d44c44b25}\label{heap__4_8c_ab71bae5a95671265c828339d44c44b25}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!heap\+M\+I\+N\+I\+M\+U\+M\+\_\+\+B\+L\+O\+C\+K\+\_\+\+S\+I\+ZE@{heap\+M\+I\+N\+I\+M\+U\+M\+\_\+\+B\+L\+O\+C\+K\+\_\+\+S\+I\+ZE}}
\index{heap\+M\+I\+N\+I\+M\+U\+M\+\_\+\+B\+L\+O\+C\+K\+\_\+\+S\+I\+ZE@{heap\+M\+I\+N\+I\+M\+U\+M\+\_\+\+B\+L\+O\+C\+K\+\_\+\+S\+I\+ZE}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{heap\+M\+I\+N\+I\+M\+U\+M\+\_\+\+B\+L\+O\+C\+K\+\_\+\+S\+I\+ZE}{heapMINIMUM\_BLOCK\_SIZE}}
{\footnotesize\ttfamily \#define heap\+M\+I\+N\+I\+M\+U\+M\+\_\+\+B\+L\+O\+C\+K\+\_\+\+S\+I\+ZE~( ( size\+\_\+t ) ( \hyperlink{heap__5_8c_aff7bec0da6b44e3634d215b40eb1db76}{x\+Heap\+Struct\+Size} $<$$<$ 1 ) )}



Definition at line 53 of file heap\+\_\+4.\+c.

\mbox{\Hypertarget{heap__4_8c_ab622d8c674f2a417a666a7ed89109e79}\label{heap__4_8c_ab622d8c674f2a417a666a7ed89109e79}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE@{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}}
\index{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE@{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}{MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE}}
{\footnotesize\ttfamily \#define M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}



Definition at line 41 of file heap\+\_\+4.\+c.



\subsection{Typedef Documentation}
\mbox{\Hypertarget{heap__4_8c_ad9a44f586d03fc020ee6f5939defb314}\label{heap__4_8c_ad9a44f586d03fc020ee6f5939defb314}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!Block\+Link\+\_\+t@{Block\+Link\+\_\+t}}
\index{Block\+Link\+\_\+t@{Block\+Link\+\_\+t}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{Block\+Link\+\_\+t}{BlockLink\_t}}
{\footnotesize\ttfamily typedef struct \hyperlink{structA__BLOCK__LINK}{A\+\_\+\+B\+L\+O\+C\+K\+\_\+\+L\+I\+NK}  \hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t}}



\subsection{Function Documentation}
\mbox{\Hypertarget{heap__4_8c_a3e55181f788f17d9a3e7d226a5206e4f}\label{heap__4_8c_a3e55181f788f17d9a3e7d226a5206e4f}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!prv\+Heap\+Init@{prv\+Heap\+Init}}
\index{prv\+Heap\+Init@{prv\+Heap\+Init}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{prv\+Heap\+Init()}{prvHeapInit()}}
{\footnotesize\ttfamily static void prv\+Heap\+Init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 329 of file heap\+\_\+4.\+c.


\begin{DoxyCode}
330 \{
331 \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} *pxFirstFreeBlock;
332 \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *pucAlignedHeap;
333 \textcolor{keywordtype}{size\_t} uxAddress;
334 \textcolor{keywordtype}{size\_t} xTotalHeapSize = \hyperlink{FreeRTOSConfig_8h_a9f213227674effff0122a75d94d87938}{configTOTAL\_HEAP\_SIZE};
335 
336     \textcolor{comment}{/* Ensure the heap starts on a correctly aligned boundary. */}
337     uxAddress = ( size\_t ) \hyperlink{heap__4_8c_a286aa29b13471f0d9f5a7ce688682694}{ucHeap};
338 
339     \textcolor{keywordflow}{if}( ( uxAddress & portBYTE\_ALIGNMENT\_MASK ) != 0 )
340     \{
341         uxAddress += ( \hyperlink{pic32mx_2portmacro_8h_ab9091ce3940d8bd93ec850122a2c6a1c}{portBYTE\_ALIGNMENT} - 1 );
342         uxAddress &= ~( ( size\_t ) portBYTE\_ALIGNMENT\_MASK );
343         xTotalHeapSize -= uxAddress - ( size\_t ) \hyperlink{heap__4_8c_a286aa29b13471f0d9f5a7ce688682694}{ucHeap};
344     \}
345 
346     pucAlignedHeap = ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) uxAddress;
347 
348     \textcolor{comment}{/* xStart is used to hold a pointer to the first item in the list of free}
349 \textcolor{comment}{    blocks.  The void cast is used to prevent compiler warnings. */}
350     \hyperlink{heap__4_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}{xStart}.\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = ( \textcolor{keywordtype}{void} * ) pucAlignedHeap;
351     \hyperlink{heap__4_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}{xStart}.\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} = ( size\_t ) 0;
352 
353     \textcolor{comment}{/* pxEnd is used to mark the end of the list of free blocks and is inserted}
354 \textcolor{comment}{    at the end of the heap space. */}
355     uxAddress = ( ( size\_t ) pucAlignedHeap ) + xTotalHeapSize;
356     uxAddress -= \hyperlink{heap__4_8c_aff7bec0da6b44e3634d215b40eb1db76}{xHeapStructSize};
357     uxAddress &= ~( ( size\_t ) portBYTE\_ALIGNMENT\_MASK );
358     \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd} = ( \textcolor{keywordtype}{void} * ) uxAddress;
359     \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd}->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} = 0;
360     \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd}->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
361 
362     \textcolor{comment}{/* To start with there is a single free block that is sized to take up the}
363 \textcolor{comment}{    entire heap space, minus the space taken by pxEnd. */}
364     pxFirstFreeBlock = ( \textcolor{keywordtype}{void} * ) pucAlignedHeap;
365     pxFirstFreeBlock->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} = uxAddress - ( size\_t ) pxFirstFreeBlock;
366     pxFirstFreeBlock->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd};
367 
368     \textcolor{comment}{/* Only one block exists - and it covers the entire usable heap space. */}
369     \hyperlink{heap__4_8c_ae88e8dc4d81326f752232a0a39eb119f}{xMinimumEverFreeBytesRemaining} = pxFirstFreeBlock->
      \hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize};
370     \hyperlink{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}{xFreeBytesRemaining} = pxFirstFreeBlock->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize};
371 
372     \textcolor{comment}{/* Work out the position of the top bit in a size\_t variable. */}
373     \hyperlink{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}{xBlockAllocatedBit} = ( ( size\_t ) 1 ) << ( ( \textcolor{keyword}{sizeof}( size\_t ) * 
      \hyperlink{heap__4_8c_adcef0c4245ebe20ca2b08a574c1caac9}{heapBITS\_PER\_BYTE} ) - 1 );
374 \}
\end{DoxyCode}
\mbox{\Hypertarget{heap__4_8c_a1a70fdf86d8a603f45e9b93c14e0d24a}\label{heap__4_8c_a1a70fdf86d8a603f45e9b93c14e0d24a}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!prv\+Insert\+Block\+Into\+Free\+List@{prv\+Insert\+Block\+Into\+Free\+List}}
\index{prv\+Insert\+Block\+Into\+Free\+List@{prv\+Insert\+Block\+Into\+Free\+List}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{prv\+Insert\+Block\+Into\+Free\+List()}{prvInsertBlockIntoFreeList()}}
{\footnotesize\ttfamily static void prv\+Insert\+Block\+Into\+Free\+List (\begin{DoxyParamCaption}\item[{\hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t} $\ast$}]{px\+Block\+To\+Insert }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 377 of file heap\+\_\+4.\+c.


\begin{DoxyCode}
378 \{
379 \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} *pxIterator;
380 \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *puc;
381 
382     \textcolor{comment}{/* Iterate through the list until a block is found that has a higher address}
383 \textcolor{comment}{    than the block being inserted. */}
384     \textcolor{keywordflow}{for}( pxIterator = &\hyperlink{heap__4_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}{xStart}; pxIterator->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} < pxBlockToInsert; 
      pxIterator = pxIterator->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} )
385     \{
386         \textcolor{comment}{/* Nothing to do here, just iterate to the right position. */}
387     \}
388 
389     \textcolor{comment}{/* Do the block being inserted, and the block it is being inserted after}
390 \textcolor{comment}{    make a contiguous block of memory? */}
391     puc = ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) pxIterator;
392     \textcolor{keywordflow}{if}( ( puc + pxIterator->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} ) == ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) pxBlockToInsert )
393     \{
394         pxIterator->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} += pxBlockToInsert->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize};
395         pxBlockToInsert = pxIterator;
396     \}
397     \textcolor{keywordflow}{else}
398     \{
399         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
400     \}
401 
402     \textcolor{comment}{/* Do the block being inserted, and the block it is being inserted before}
403 \textcolor{comment}{    make a contiguous block of memory? */}
404     puc = ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) pxBlockToInsert;
405     \textcolor{keywordflow}{if}( ( puc + pxBlockToInsert->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} ) == ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) pxIterator->
      \hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} )
406     \{
407         \textcolor{keywordflow}{if}( pxIterator->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} != \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd} )
408         \{
409             \textcolor{comment}{/* Form one big block from the two blocks. */}
410             pxBlockToInsert->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} += pxIterator->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock}->
      \hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize};
411             pxBlockToInsert->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = pxIterator->
      \hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock}->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock};
412         \}
413         \textcolor{keywordflow}{else}
414         \{
415             pxBlockToInsert->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd};
416         \}
417     \}
418     \textcolor{keywordflow}{else}
419     \{
420         pxBlockToInsert->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = pxIterator->
      \hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock};
421     \}
422 
423     \textcolor{comment}{/* If the block being inserted plugged a gab, so was merged with the block}
424 \textcolor{comment}{    before and the block after, then it's pxNextFreeBlock pointer will have}
425 \textcolor{comment}{    already been set, and should not be set here as that would make it point}
426 \textcolor{comment}{    to itself. */}
427     \textcolor{keywordflow}{if}( pxIterator != pxBlockToInsert )
428     \{
429         pxIterator->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = pxBlockToInsert;
430     \}
431     \textcolor{keywordflow}{else}
432     \{
433         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
434     \}
435 \}
\end{DoxyCode}
\mbox{\Hypertarget{heap__4_8c_a0379669d07d76cc81e3028123113b271}\label{heap__4_8c_a0379669d07d76cc81e3028123113b271}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!pv\+Port\+Malloc@{pv\+Port\+Malloc}}
\index{pv\+Port\+Malloc@{pv\+Port\+Malloc}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{pv\+Port\+Malloc()}{pvPortMalloc()}}
{\footnotesize\ttfamily void$\ast$ pv\+Port\+Malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{x\+Wanted\+Size }\end{DoxyParamCaption})}



Definition at line 113 of file heap\+\_\+4.\+c.


\begin{DoxyCode}
114 \{
115 \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
116 \textcolor{keywordtype}{void} *pvReturn = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
117 
118     \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
119     \{
120         \textcolor{comment}{/* If this is the first call to malloc then the heap will require}
121 \textcolor{comment}{        initialisation to setup the list of free blocks. */}
122         \textcolor{keywordflow}{if}( \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd} == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
123         \{
124             \hyperlink{heap__4_8c_a3e55181f788f17d9a3e7d226a5206e4f}{prvHeapInit}();
125         \}
126         \textcolor{keywordflow}{else}
127         \{
128             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
129         \}
130 
131         \textcolor{comment}{/* Check the requested block size is not so large that the top bit is}
132 \textcolor{comment}{        set.  The top bit of the block size member of the BlockLink\_t structure}
133 \textcolor{comment}{        is used to determine who owns the block - the application or the}
134 \textcolor{comment}{        kernel, so it must be free. */}
135         \textcolor{keywordflow}{if}( ( xWantedSize & \hyperlink{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}{xBlockAllocatedBit} ) == 0 )
136         \{
137             \textcolor{comment}{/* The wanted size is increased so it can contain a BlockLink\_t}
138 \textcolor{comment}{            structure in addition to the requested amount of bytes. */}
139             \textcolor{keywordflow}{if}( xWantedSize > 0 )
140             \{
141                 xWantedSize += \hyperlink{heap__4_8c_aff7bec0da6b44e3634d215b40eb1db76}{xHeapStructSize};
142 
143                 \textcolor{comment}{/* Ensure that blocks are always aligned to the required number}
144 \textcolor{comment}{                of bytes. */}
145                 \textcolor{keywordflow}{if}( ( xWantedSize & portBYTE\_ALIGNMENT\_MASK ) != 0x00 )
146                 \{
147                     \textcolor{comment}{/* Byte alignment required. */}
148                     xWantedSize += ( \hyperlink{pic32mx_2portmacro_8h_ab9091ce3940d8bd93ec850122a2c6a1c}{portBYTE\_ALIGNMENT} - ( xWantedSize & 
      portBYTE\_ALIGNMENT\_MASK ) );
149                     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( xWantedSize & portBYTE\_ALIGNMENT\_MASK ) == 0 );
150                 \}
151                 \textcolor{keywordflow}{else}
152                 \{
153                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
154                 \}
155             \}
156             \textcolor{keywordflow}{else}
157             \{
158                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
159             \}
160 
161             \textcolor{keywordflow}{if}( ( xWantedSize > 0 ) && ( xWantedSize <= \hyperlink{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}{xFreeBytesRemaining} ) )
162             \{
163                 \textcolor{comment}{/* Traverse the list from the start (lowest address) block until}
164 \textcolor{comment}{                one of adequate size is found. */}
165                 pxPreviousBlock = &\hyperlink{heap__4_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}{xStart};
166                 pxBlock = \hyperlink{heap__4_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}{xStart}.\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock};
167                 \textcolor{keywordflow}{while}( ( pxBlock->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} < xWantedSize ) && ( pxBlock->
      \hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) )
168                 \{
169                     pxPreviousBlock = pxBlock;
170                     pxBlock = pxBlock->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock};
171                 \}
172 
173                 \textcolor{comment}{/* If the end marker was reached then a block of adequate size}
174 \textcolor{comment}{                was not found. */}
175                 \textcolor{keywordflow}{if}( pxBlock != \hyperlink{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd} )
176                 \{
177                     \textcolor{comment}{/* Return the memory space pointed to - jumping over the}
178 \textcolor{comment}{                    BlockLink\_t structure at its start. */}
179                     pvReturn = ( \textcolor{keywordtype}{void} * ) ( ( ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) pxPreviousBlock->
      \hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} ) + \hyperlink{heap__4_8c_aff7bec0da6b44e3634d215b40eb1db76}{xHeapStructSize} );
180 
181                     \textcolor{comment}{/* This block is being returned for use so must be taken out}
182 \textcolor{comment}{                    of the list of free blocks. */}
183                     pxPreviousBlock->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = pxBlock->
      \hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock};
184 
185                     \textcolor{comment}{/* If the block is larger than required it can be split into}
186 \textcolor{comment}{                    two. */}
187                     \textcolor{keywordflow}{if}( ( pxBlock->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} - xWantedSize ) > 
      \hyperlink{heap__4_8c_ab71bae5a95671265c828339d44c44b25}{heapMINIMUM\_BLOCK\_SIZE} )
188                     \{
189                         \textcolor{comment}{/* This block is to be split into two.  Create a new}
190 \textcolor{comment}{                        block following the number of bytes requested. The void}
191 \textcolor{comment}{                        cast is used to prevent byte alignment warnings from the}
192 \textcolor{comment}{                        compiler. */}
193                         pxNewBlockLink = ( \textcolor{keywordtype}{void} * ) ( ( ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) pxBlock ) + xWantedSize );
194                         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( ( ( \textcolor{keywordtype}{size\_t} ) pxNewBlockLink ) & portBYTE\_ALIGNMENT\_MASK
       ) == 0 );
195 
196                         \textcolor{comment}{/* Calculate the sizes of two blocks split from the}
197 \textcolor{comment}{                        single block. */}
198                         pxNewBlockLink->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} = pxBlock->
      \hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} - xWantedSize;
199                         pxBlock->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} = xWantedSize;
200 
201                         \textcolor{comment}{/* Insert the new block into the list of free blocks. */}
202                         \hyperlink{heap__4_8c_a1a70fdf86d8a603f45e9b93c14e0d24a}{prvInsertBlockIntoFreeList}( pxNewBlockLink );
203                     \}
204                     \textcolor{keywordflow}{else}
205                     \{
206                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
207                     \}
208 
209                     \hyperlink{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}{xFreeBytesRemaining} -= pxBlock->
      \hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize};
210 
211                     \textcolor{keywordflow}{if}( \hyperlink{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}{xFreeBytesRemaining} < 
      \hyperlink{heap__4_8c_ae88e8dc4d81326f752232a0a39eb119f}{xMinimumEverFreeBytesRemaining} )
212                     \{
213                         \hyperlink{heap__4_8c_ae88e8dc4d81326f752232a0a39eb119f}{xMinimumEverFreeBytesRemaining} = 
      \hyperlink{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}{xFreeBytesRemaining};
214                     \}
215                     \textcolor{keywordflow}{else}
216                     \{
217                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
218                     \}
219 
220                     \textcolor{comment}{/* The block is being returned - it is allocated and owned}
221 \textcolor{comment}{                    by the application and has no "next" block. */}
222                     pxBlock->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} |= \hyperlink{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}{xBlockAllocatedBit};
223                     pxBlock->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
224                 \}
225                 \textcolor{keywordflow}{else}
226                 \{
227                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
228                 \}
229             \}
230             \textcolor{keywordflow}{else}
231             \{
232                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
233             \}
234         \}
235         \textcolor{keywordflow}{else}
236         \{
237             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
238         \}
239 
240         \hyperlink{FreeRTOS_8h_af326afe922ffa6da245c98dc227a3293}{traceMALLOC}( pvReturn, xWantedSize );
241     \}
242     ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
243 
244 \textcolor{preprocessor}{    #if( configUSE\_MALLOC\_FAILED\_HOOK == 1 )}
245     \{
246         \textcolor{keywordflow}{if}( pvReturn == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
247         \{
248             \textcolor{keyword}{extern} \textcolor{keywordtype}{void} vApplicationMallocFailedHook( \textcolor{keywordtype}{void} );
249             vApplicationMallocFailedHook();
250         \}
251         \textcolor{keywordflow}{else}
252         \{
253             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
254         \}
255     \}
256 \textcolor{preprocessor}{    #endif}
257 
258     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( ( ( \textcolor{keywordtype}{size\_t} ) pvReturn ) & ( \textcolor{keywordtype}{size\_t} ) portBYTE\_ALIGNMENT\_MASK ) == 0 );
259     \textcolor{keywordflow}{return} pvReturn;
260 \}
\end{DoxyCode}
\mbox{\Hypertarget{heap__4_8c_a1e7cea2fd1bc894ea3b5f5e8179d259b}\label{heap__4_8c_a1e7cea2fd1bc894ea3b5f5e8179d259b}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!v\+Port\+Free@{v\+Port\+Free}}
\index{v\+Port\+Free@{v\+Port\+Free}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{v\+Port\+Free()}{vPortFree()}}
{\footnotesize\ttfamily void v\+Port\+Free (\begin{DoxyParamCaption}\item[{void $\ast$}]{pv }\end{DoxyParamCaption})}



Definition at line 263 of file heap\+\_\+4.\+c.


\begin{DoxyCode}
264 \{
265 \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *puc = ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) pv;
266 \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} *pxLink;
267 
268     \textcolor{keywordflow}{if}( pv != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
269     \{
270         \textcolor{comment}{/* The memory being freed will have an BlockLink\_t structure immediately}
271 \textcolor{comment}{        before it. */}
272         puc -= \hyperlink{heap__4_8c_aff7bec0da6b44e3634d215b40eb1db76}{xHeapStructSize};
273 
274         \textcolor{comment}{/* This casting is to keep the compiler from issuing warnings. */}
275         pxLink = ( \textcolor{keywordtype}{void} * ) puc;
276 
277         \textcolor{comment}{/* Check the block is actually allocated. */}
278         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( pxLink->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} & 
      \hyperlink{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}{xBlockAllocatedBit} ) != 0 );
279         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxLink->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} );
280 
281         \textcolor{keywordflow}{if}( ( pxLink->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} & \hyperlink{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}{xBlockAllocatedBit} ) != 0 )
282         \{
283             \textcolor{keywordflow}{if}( pxLink->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
284             \{
285                 \textcolor{comment}{/* The block is being returned to the heap - it is no longer}
286 \textcolor{comment}{                allocated. */}
287                 pxLink->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} &= ~\hyperlink{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}{xBlockAllocatedBit};
288 
289                 \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
290                 \{
291                     \textcolor{comment}{/* Add this block to the list of free blocks. */}
292                     \hyperlink{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}{xFreeBytesRemaining} += pxLink->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize};
293                     \hyperlink{FreeRTOS_8h_a941bb09090b5788f0c27d9690118eed2}{traceFREE}( pv, pxLink->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} );
294                     \hyperlink{heap__4_8c_a1a70fdf86d8a603f45e9b93c14e0d24a}{prvInsertBlockIntoFreeList}( ( ( 
      \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} * ) pxLink ) );
295                 \}
296                 ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
297             \}
298             \textcolor{keywordflow}{else}
299             \{
300                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
301             \}
302         \}
303         \textcolor{keywordflow}{else}
304         \{
305             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
306         \}
307     \}
308 \}
\end{DoxyCode}
\mbox{\Hypertarget{heap__4_8c_a8bf103ce32ce8473574e9920af8b4eec}\label{heap__4_8c_a8bf103ce32ce8473574e9920af8b4eec}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!v\+Port\+Initialise\+Blocks@{v\+Port\+Initialise\+Blocks}}
\index{v\+Port\+Initialise\+Blocks@{v\+Port\+Initialise\+Blocks}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{v\+Port\+Initialise\+Blocks()}{vPortInitialiseBlocks()}}
{\footnotesize\ttfamily void v\+Port\+Initialise\+Blocks (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 323 of file heap\+\_\+4.\+c.


\begin{DoxyCode}
324 \{
325     \textcolor{comment}{/* This just exists to keep the linker quiet. */}
326 \}
\end{DoxyCode}
\mbox{\Hypertarget{heap__4_8c_a0c28a12b313bc248be0cb7a37ed81bb7}\label{heap__4_8c_a0c28a12b313bc248be0cb7a37ed81bb7}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!x\+Port\+Get\+Free\+Heap\+Size@{x\+Port\+Get\+Free\+Heap\+Size}}
\index{x\+Port\+Get\+Free\+Heap\+Size@{x\+Port\+Get\+Free\+Heap\+Size}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{x\+Port\+Get\+Free\+Heap\+Size()}{xPortGetFreeHeapSize()}}
{\footnotesize\ttfamily size\+\_\+t x\+Port\+Get\+Free\+Heap\+Size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 311 of file heap\+\_\+4.\+c.


\begin{DoxyCode}
312 \{
313     \textcolor{keywordflow}{return} \hyperlink{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}{xFreeBytesRemaining};
314 \}
\end{DoxyCode}
\mbox{\Hypertarget{heap__4_8c_ab222e4545b8ff12b62fd000fea6b34eb}\label{heap__4_8c_ab222e4545b8ff12b62fd000fea6b34eb}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size@{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size}}
\index{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size@{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size()}{xPortGetMinimumEverFreeHeapSize()}}
{\footnotesize\ttfamily size\+\_\+t x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 317 of file heap\+\_\+4.\+c.


\begin{DoxyCode}
318 \{
319     \textcolor{keywordflow}{return} \hyperlink{heap__4_8c_ae88e8dc4d81326f752232a0a39eb119f}{xMinimumEverFreeBytesRemaining};
320 \}
\end{DoxyCode}


\subsection{Variable Documentation}
\mbox{\Hypertarget{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}\label{heap__4_8c_a9e133e4e5cd5400005b1378227cbdf7e}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!px\+End@{px\+End}}
\index{px\+End@{px\+End}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{px\+End}{pxEnd}}
{\footnotesize\ttfamily \hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t} $\ast$ px\+End = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL}\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 98 of file heap\+\_\+4.\+c.

\mbox{\Hypertarget{heap__4_8c_a286aa29b13471f0d9f5a7ce688682694}\label{heap__4_8c_a286aa29b13471f0d9f5a7ce688682694}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!uc\+Heap@{uc\+Heap}}
\index{uc\+Heap@{uc\+Heap}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{uc\+Heap}{ucHeap}}
{\footnotesize\ttfamily \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} uc\+Heap\mbox{[}\hyperlink{FreeRTOSConfig_8h_a9f213227674effff0122a75d94d87938}{config\+T\+O\+T\+A\+L\+\_\+\+H\+E\+A\+P\+\_\+\+S\+I\+ZE}\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 64 of file heap\+\_\+4.\+c.

\mbox{\Hypertarget{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}\label{heap__4_8c_ad7d272a4def963ce2d0185bb02fc7da4}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!x\+Block\+Allocated\+Bit@{x\+Block\+Allocated\+Bit}}
\index{x\+Block\+Allocated\+Bit@{x\+Block\+Allocated\+Bit}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{x\+Block\+Allocated\+Bit}{xBlockAllocatedBit}}
{\footnotesize\ttfamily size\+\_\+t x\+Block\+Allocated\+Bit = 0\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 109 of file heap\+\_\+4.\+c.

\mbox{\Hypertarget{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}\label{heap__4_8c_a338244e3e604d3b290a3ef1903e97e4b}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!x\+Free\+Bytes\+Remaining@{x\+Free\+Bytes\+Remaining}}
\index{x\+Free\+Bytes\+Remaining@{x\+Free\+Bytes\+Remaining}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{x\+Free\+Bytes\+Remaining}{xFreeBytesRemaining}}
{\footnotesize\ttfamily size\+\_\+t x\+Free\+Bytes\+Remaining = 0U\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 102 of file heap\+\_\+4.\+c.

\mbox{\Hypertarget{heap__4_8c_aff7bec0da6b44e3634d215b40eb1db76}\label{heap__4_8c_aff7bec0da6b44e3634d215b40eb1db76}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!x\+Heap\+Struct\+Size@{x\+Heap\+Struct\+Size}}
\index{x\+Heap\+Struct\+Size@{x\+Heap\+Struct\+Size}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{x\+Heap\+Struct\+Size}{xHeapStructSize}}
{\footnotesize\ttfamily const size\+\_\+t x\+Heap\+Struct\+Size = ( sizeof( \hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t} ) + ( ( size\+\_\+t ) ( \hyperlink{pic32mz_2portmacro_8h_ab9091ce3940d8bd93ec850122a2c6a1c}{port\+B\+Y\+T\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT} -\/ 1 ) ) ) \& $\sim$( ( size\+\_\+t ) port\+B\+Y\+T\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+N\+T\+\_\+\+M\+A\+SK )\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 95 of file heap\+\_\+4.\+c.

\mbox{\Hypertarget{heap__4_8c_ae88e8dc4d81326f752232a0a39eb119f}\label{heap__4_8c_ae88e8dc4d81326f752232a0a39eb119f}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!x\+Minimum\+Ever\+Free\+Bytes\+Remaining@{x\+Minimum\+Ever\+Free\+Bytes\+Remaining}}
\index{x\+Minimum\+Ever\+Free\+Bytes\+Remaining@{x\+Minimum\+Ever\+Free\+Bytes\+Remaining}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{x\+Minimum\+Ever\+Free\+Bytes\+Remaining}{xMinimumEverFreeBytesRemaining}}
{\footnotesize\ttfamily size\+\_\+t x\+Minimum\+Ever\+Free\+Bytes\+Remaining = 0U\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 103 of file heap\+\_\+4.\+c.

\mbox{\Hypertarget{heap__4_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}\label{heap__4_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}} 
\index{heap\+\_\+4.\+c@{heap\+\_\+4.\+c}!x\+Start@{x\+Start}}
\index{x\+Start@{x\+Start}!heap\+\_\+4.\+c@{heap\+\_\+4.\+c}}
\subsubsection{\texorpdfstring{x\+Start}{xStart}}
{\footnotesize\ttfamily \hyperlink{heap__2_8c_ad9a44f586d03fc020ee6f5939defb314}{Block\+Link\+\_\+t} x\+Start\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 98 of file heap\+\_\+4.\+c.

