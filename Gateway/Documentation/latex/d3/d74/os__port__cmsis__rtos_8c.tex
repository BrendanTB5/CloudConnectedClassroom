\hypertarget{os__port__cmsis__rtos_8c}{}\section{common/os\+\_\+port\+\_\+cmsis\+\_\+rtos.c File Reference}
\label{os__port__cmsis__rtos_8c}\index{common/os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{common/os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}


R\+T\+OS abstraction layer (C\+M\+S\+I\+S-\/\+R\+T\+OS)  


{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include \char`\"{}os\+\_\+port.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}debug.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{os__port__cmsis__rtos_8c_afcdf5e66fd927a7f4cc64295acd20407}{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}~\hyperlink{debug_8h_abe394dff8dc1f8684894410f2ffa9160}{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+E\+L\+\_\+\+O\+FF}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{os__port__cmsis__rtos_8c_af1819038a84a0c1b18edbc8421d594ba}{os\+Init\+Kernel} (void)
\begin{DoxyCompactList}\small\item\em Kernel initialization. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_ae09f7770c80e669e765b9f22a837ed18}{os\+Start\+Kernel} (void)
\begin{DoxyCompactList}\small\item\em Start kernel. \end{DoxyCompactList}\item 
\hyperlink{structOsTask}{Os\+Task} $\ast$ \hyperlink{os__port__cmsis__rtos_8c_aef8c6fe13a0df9e5cfaeb0501ecbac3e}{os\+Create\+Task} (const \hyperlink{compiler__port_8h_a40bb5262bf908c328fbcfbe5d29d0201}{char\+\_\+t} $\ast$\hyperlink{resource__manager_8h_a26532d7194d592ae8da35222073f36d6}{name}, \hyperlink{os__port__windows_8h_a52a4e1975bb554c2ce70aaac35b752d2}{Os\+Task\+Code} task\+Code, void $\ast$param, size\+\_\+t stack\+Size, \hyperlink{compiler__port_8h_a022c65af7f6c8d3947e8a37d64db6ad6}{int\+\_\+t} \hyperlink{dns__common_8h_a0815784d41b3c13d42ce22367abfba1d}{priority})
\begin{DoxyCompactList}\small\item\em Create a new task. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_ae19a41c2cb0f1e7242f48c2dbbc36e8e}{os\+Delete\+Task} (\hyperlink{structOsTask}{Os\+Task} $\ast$task)
\begin{DoxyCompactList}\small\item\em Delete a task. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a69608590db97c707277aebf15be010e5}{os\+Delay\+Task} (\hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t} delay)
\begin{DoxyCompactList}\small\item\em Delay routine. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a0f90518dbc8cd7221762e1acf29e8d27}{os\+Switch\+Task} (void)
\begin{DoxyCompactList}\small\item\em Yield control to the next task. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_abb64215d94a3d144b27a7f1509386366}{os\+Suspend\+All\+Tasks} (void)
\begin{DoxyCompactList}\small\item\em Suspend scheduler activity. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a1116ffd72c17afc85cc9c6ac00f1b06c}{os\+Resume\+All\+Tasks} (void)
\begin{DoxyCompactList}\small\item\em Resume scheduler activity. \end{DoxyCompactList}\item 
\hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} \hyperlink{os__port__cmsis__rtos_8c_ac1658f3fed1eb64efcd47e4503a9ef2e}{os\+Create\+Event} (\hyperlink{structOsEvent}{Os\+Event} $\ast$event)
\begin{DoxyCompactList}\small\item\em Create an event object. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a25827a49278bad6150b04b47165fda3d}{os\+Delete\+Event} (\hyperlink{structOsEvent}{Os\+Event} $\ast$event)
\begin{DoxyCompactList}\small\item\em Delete an event object. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_afc1d64fc90afbf03baecfa636bb99ff7}{os\+Set\+Event} (\hyperlink{structOsEvent}{Os\+Event} $\ast$event)
\begin{DoxyCompactList}\small\item\em Set the specified event object to the signaled state. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a9122a1cf258caef553a6b224ef8ef6bf}{os\+Reset\+Event} (\hyperlink{structOsEvent}{Os\+Event} $\ast$event)
\begin{DoxyCompactList}\small\item\em Set the specified event object to the nonsignaled state. \end{DoxyCompactList}\item 
\hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} \hyperlink{os__port__cmsis__rtos_8c_a1dc707247e44dfefae5bec4a322fc78a}{os\+Wait\+For\+Event} (\hyperlink{structOsEvent}{Os\+Event} $\ast$event, \hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t} timeout)
\begin{DoxyCompactList}\small\item\em Wait until the specified event is in the signaled state. \end{DoxyCompactList}\item 
\hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} \hyperlink{os__port__cmsis__rtos_8c_aa30d505571a03dd645af374f40bd7016}{os\+Set\+Event\+From\+Isr} (\hyperlink{structOsEvent}{Os\+Event} $\ast$event)
\begin{DoxyCompactList}\small\item\em Set an event object to the signaled state from an interrupt service routine. \end{DoxyCompactList}\item 
\hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} \hyperlink{os__port__cmsis__rtos_8c_ab40200616c2421cd9baf2a9ec26de7b4}{os\+Create\+Semaphore} (\hyperlink{structOsSemaphore}{Os\+Semaphore} $\ast$semaphore, \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} count)
\begin{DoxyCompactList}\small\item\em Create a semaphore object. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a501b470967cd2cc9caf2fdee107e8590}{os\+Delete\+Semaphore} (\hyperlink{structOsSemaphore}{Os\+Semaphore} $\ast$semaphore)
\begin{DoxyCompactList}\small\item\em Delete a semaphore object. \end{DoxyCompactList}\item 
\hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} \hyperlink{os__port__cmsis__rtos_8c_a77807eaba2cdb91423e0b238f5282e50}{os\+Wait\+For\+Semaphore} (\hyperlink{structOsSemaphore}{Os\+Semaphore} $\ast$semaphore, \hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t} timeout)
\begin{DoxyCompactList}\small\item\em Wait for the specified semaphore to be available. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a33555fb6374f981567026d77e3b687fc}{os\+Release\+Semaphore} (\hyperlink{structOsSemaphore}{Os\+Semaphore} $\ast$semaphore)
\begin{DoxyCompactList}\small\item\em Release the specified semaphore object. \end{DoxyCompactList}\item 
\hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} \hyperlink{os__port__cmsis__rtos_8c_a16627f901c807c29adf29a38fb1af16a}{os\+Create\+Mutex} (\hyperlink{structOsMutex}{Os\+Mutex} $\ast$mutex)
\begin{DoxyCompactList}\small\item\em Create a mutex object. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a2b0ba1e39227e4a4d52ee46bbee15c11}{os\+Delete\+Mutex} (\hyperlink{structOsMutex}{Os\+Mutex} $\ast$mutex)
\begin{DoxyCompactList}\small\item\em Delete a mutex object. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a58485224df4bfa522246d55b35bbd83a}{os\+Acquire\+Mutex} (\hyperlink{structOsMutex}{Os\+Mutex} $\ast$mutex)
\begin{DoxyCompactList}\small\item\em Acquire ownership of the specified mutex object. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a8e10e5b2c6d3877b5ba60e375ac45d79}{os\+Release\+Mutex} (\hyperlink{structOsMutex}{Os\+Mutex} $\ast$mutex)
\begin{DoxyCompactList}\small\item\em Release ownership of the specified mutex object. \end{DoxyCompactList}\item 
\hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t} \hyperlink{os__port__cmsis__rtos_8c_ab66a11272d40a916fa69dd8e4dc443d4}{os\+Get\+System\+Time} (void)
\begin{DoxyCompactList}\small\item\em Retrieve system time. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{os__port__cmsis__rtos_8c_ae86758dcd9fc3c98247ae19815987c9a}{os\+Alloc\+Mem} (size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Allocate a memory block. \end{DoxyCompactList}\item 
void \hyperlink{os__port__cmsis__rtos_8c_a68e4fa4326f2031eab28b92a25f2d68d}{os\+Free\+Mem} (void $\ast$\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p})
\begin{DoxyCompactList}\small\item\em Release a previously allocated memory block. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
R\+T\+OS abstraction layer (C\+M\+S\+I\+S-\/\+R\+T\+OS) 

\hypertarget{pic32mz__ef__curiosity_8h_License}{}\subsection{License}\label{pic32mz__ef__curiosity_8h_License}
S\+P\+D\+X-\/\+License-\/\+Identifier\+: G\+P\+L-\/2.\+0-\/or-\/later

Copyright (C) 2010-\/2019 Oryx Embedded S\+A\+RL. All rights reserved.

This program is free software; you can redistribute it and/or modify it under the terms of the G\+NU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but W\+I\+T\+H\+O\+UT A\+NY W\+A\+R\+R\+A\+N\+TY; without even the implied warranty of M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY or F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE. See the G\+NU General Public License for more details.

You should have received a copy of the G\+NU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-\/1301, U\+SA.

\begin{DoxyAuthor}{Author}
Oryx Embedded S\+A\+RL (www.\+oryx-\/embedded.\+com) 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+9.\+6 
\end{DoxyVersion}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_afcdf5e66fd927a7f4cc64295acd20407}\label{os__port__cmsis__rtos_8c_afcdf5e66fd927a7f4cc64295acd20407}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL@{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}}
\index{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL@{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}{TRACE\_LEVEL}}
{\footnotesize\ttfamily \#define T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL~\hyperlink{debug_8h_abe394dff8dc1f8684894410f2ffa9160}{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+E\+L\+\_\+\+O\+FF}}



Definition at line 30 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.



\subsection{Function Documentation}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a58485224df4bfa522246d55b35bbd83a}\label{os__port__cmsis__rtos_8c_a58485224df4bfa522246d55b35bbd83a}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Acquire\+Mutex@{os\+Acquire\+Mutex}}
\index{os\+Acquire\+Mutex@{os\+Acquire\+Mutex}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Acquire\+Mutex()}{osAcquireMutex()}}
{\footnotesize\ttfamily void os\+Acquire\+Mutex (\begin{DoxyParamCaption}\item[{\hyperlink{structOsMutex}{Os\+Mutex} $\ast$}]{mutex }\end{DoxyParamCaption})}



Acquire ownership of the specified mutex object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em mutex} & Pointer to the mutex object \\
\hline
\end{DoxyParams}


Definition at line 580 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
581 \{
582    \textcolor{comment}{//Obtain ownership of the mutex object}
583    osMutexWait(mutex->\hyperlink{structOsMutex_ae52709d6235dc8132a937fe9a1518878}{id}, osWaitForever);
584 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_ae86758dcd9fc3c98247ae19815987c9a}\label{os__port__cmsis__rtos_8c_ae86758dcd9fc3c98247ae19815987c9a}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Alloc\+Mem@{os\+Alloc\+Mem}}
\index{os\+Alloc\+Mem@{os\+Alloc\+Mem}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Alloc\+Mem()}{osAllocMem()}}
{\footnotesize\ttfamily void$\ast$ os\+Alloc\+Mem (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Allocate a memory block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em size} & Bytes to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the allocated memory block or N\+U\+LL if there is insufficient memory available 
\end{DoxyReturn}


Definition at line 635 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
636 \{
637    \textcolor{keywordtype}{void} *\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
638 
639    \textcolor{comment}{//Enter critical section}
640    \hyperlink{os__port__cmsis__rtos_8c_abb64215d94a3d144b27a7f1509386366}{osSuspendAllTasks}();
641    \textcolor{comment}{//Allocate a memory block}
642    p = malloc(size);
643    \textcolor{comment}{//Leave critical section}
644    \hyperlink{os__port__cmsis__rtos_8c_a1116ffd72c17afc85cc9c6ac00f1b06c}{osResumeAllTasks}();
645 
646    \textcolor{comment}{//Debug message}
647    \hyperlink{debug_8h_a67a8f9bc74358aa21745a76e23768dae}{TRACE\_DEBUG}(\textcolor{stringliteral}{"Allocating %u bytes at 0x%08X\(\backslash\)r\(\backslash\)n"}, size, (\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t}) p);
648 
649    \textcolor{comment}{//Return a pointer to the newly allocated memory block}
650    \textcolor{keywordflow}{return} \hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
651 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_ac1658f3fed1eb64efcd47e4503a9ef2e}\label{os__port__cmsis__rtos_8c_ac1658f3fed1eb64efcd47e4503a9ef2e}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Create\+Event@{os\+Create\+Event}}
\index{os\+Create\+Event@{os\+Create\+Event}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Create\+Event()}{osCreateEvent()}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} os\+Create\+Event (\begin{DoxyParamCaption}\item[{\hyperlink{structOsEvent}{Os\+Event} $\ast$}]{event }\end{DoxyParamCaption})}



Create an event object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em event} & Pointer to the event object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function returns T\+R\+UE if the event object was successfully created. Otherwise, F\+A\+L\+SE is returned 
\end{DoxyReturn}


Definition at line 216 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
217 \{
218    osSemaphoreDef\_t semaphoreDef;
219 
220 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
221    semaphoreDef.semaphore = \textcolor{keyword}{event}->cb;
222 \textcolor{preprocessor}{#elif defined(osCMSIS\_RTX) && (osCMSIS\_RTX >= 0x50000)}
223    semaphoreDef.name = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
224    semaphoreDef.attr\_bits = 0;
225    semaphoreDef.cb\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
226    semaphoreDef.cb\_size = 0;
227 \textcolor{preprocessor}{#elif defined(osCMSIS\_FreeRTOS)}
228    semaphoreDef.name = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
229    semaphoreDef.attr\_bits = 0;
230    semaphoreDef.cb\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
231    semaphoreDef.cb\_size = 0;
232 \textcolor{preprocessor}{#else}
233    semaphoreDef.dummy = 0;
234 \textcolor{preprocessor}{#endif}
235 
236    \textcolor{comment}{//Create a binary semaphore object}
237    \textcolor{keyword}{event}->id = osSemaphoreCreate(&semaphoreDef, 1);
238 
239    \textcolor{comment}{//Check whether the returned semaphore ID is valid}
240    \textcolor{keywordflow}{if}(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
241    \{
242       \textcolor{comment}{//Force the specified event to the nonsignaled state}
243       osSemaphoreWait(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id}, 0);
244       \textcolor{comment}{//Event successfully created}
245       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
246    \}
247    \textcolor{keywordflow}{else}
248    \{
249       \textcolor{comment}{//Failed to create event object}
250       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
251    \}
252 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a16627f901c807c29adf29a38fb1af16a}\label{os__port__cmsis__rtos_8c_a16627f901c807c29adf29a38fb1af16a}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Create\+Mutex@{os\+Create\+Mutex}}
\index{os\+Create\+Mutex@{os\+Create\+Mutex}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Create\+Mutex()}{osCreateMutex()}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} os\+Create\+Mutex (\begin{DoxyParamCaption}\item[{\hyperlink{structOsMutex}{Os\+Mutex} $\ast$}]{mutex }\end{DoxyParamCaption})}



Create a mutex object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em mutex} & Pointer to the mutex object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function returns T\+R\+UE if the mutex was successfully created. Otherwise, F\+A\+L\+SE is returned 
\end{DoxyReturn}


Definition at line 528 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
529 \{
530    osMutexDef\_t mutexDef;
531 
532 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
533    mutexDef.mutex = mutex->cb;
534 \textcolor{preprocessor}{#elif defined(osCMSIS\_RTX) && (osCMSIS\_RTX >= 0x50000)}
535    mutexDef.name = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
536    mutexDef.attr\_bits = 0;
537    mutexDef.cb\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
538    mutexDef.cb\_size = 0;
539 \textcolor{preprocessor}{#elif defined(osCMSIS\_FreeRTOS)}
540    mutexDef.name = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
541    mutexDef.attr\_bits = 0;
542    mutexDef.cb\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
543    mutexDef.cb\_size = 0;
544 \textcolor{preprocessor}{#else}
545    mutexDef.dummy = 0;
546 \textcolor{preprocessor}{#endif}
547 
548    \textcolor{comment}{//Create a mutex object}
549    mutex->\hyperlink{structOsMutex_ae52709d6235dc8132a937fe9a1518878}{id} = osMutexCreate(&mutexDef);
550 
551    \textcolor{comment}{//Check whether the returned mutex ID is valid}
552    \textcolor{keywordflow}{if}(mutex->\hyperlink{structOsMutex_ae52709d6235dc8132a937fe9a1518878}{id} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
553       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
554    \textcolor{keywordflow}{else}
555       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
556 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_ab40200616c2421cd9baf2a9ec26de7b4}\label{os__port__cmsis__rtos_8c_ab40200616c2421cd9baf2a9ec26de7b4}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Create\+Semaphore@{os\+Create\+Semaphore}}
\index{os\+Create\+Semaphore@{os\+Create\+Semaphore}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Create\+Semaphore()}{osCreateSemaphore()}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} os\+Create\+Semaphore (\begin{DoxyParamCaption}\item[{\hyperlink{structOsSemaphore}{Os\+Semaphore} $\ast$}]{semaphore,  }\item[{\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t}}]{count }\end{DoxyParamCaption})}



Create a semaphore object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em semaphore} & Pointer to the semaphore object \\
\hline
\mbox{\tt in}  & {\em count} & The maximum count for the semaphore object. This value must be greater than zero \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function returns T\+R\+UE if the semaphore was successfully created. Otherwise, F\+A\+L\+SE is returned 
\end{DoxyReturn}


Definition at line 405 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
406 \{
407    osSemaphoreDef\_t semaphoreDef;
408 
409 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
410    semaphoreDef.semaphore = semaphore->cb;
411 \textcolor{preprocessor}{#elif defined(osCMSIS\_RTX) && (osCMSIS\_RTX >= 0x50000)}
412    semaphoreDef.name = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
413    semaphoreDef.attr\_bits = 0;
414    semaphoreDef.cb\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
415    semaphoreDef.cb\_size = 0;
416 \textcolor{preprocessor}{#elif defined(osCMSIS\_FreeRTOS)}
417    semaphoreDef.name = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
418    semaphoreDef.attr\_bits = 0;
419    semaphoreDef.cb\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
420    semaphoreDef.cb\_size = 0;
421 \textcolor{preprocessor}{#else}
422    semaphoreDef.dummy = 0;
423 \textcolor{preprocessor}{#endif}
424 
425    \textcolor{comment}{//Create a semaphore object}
426    semaphore->\hyperlink{structOsSemaphore_a524627618a2b124f35e450b4ba708098}{id} = osSemaphoreCreate(&semaphoreDef, count);
427 
428    \textcolor{comment}{//Check whether the returned semaphore ID is valid}
429    \textcolor{keywordflow}{if}(semaphore->\hyperlink{structOsSemaphore_a524627618a2b124f35e450b4ba708098}{id} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
430       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
431    \textcolor{keywordflow}{else}
432       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
433 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_aef8c6fe13a0df9e5cfaeb0501ecbac3e}\label{os__port__cmsis__rtos_8c_aef8c6fe13a0df9e5cfaeb0501ecbac3e}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Create\+Task@{os\+Create\+Task}}
\index{os\+Create\+Task@{os\+Create\+Task}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Create\+Task()}{osCreateTask()}}
{\footnotesize\ttfamily \hyperlink{structOsTask}{Os\+Task}$\ast$ os\+Create\+Task (\begin{DoxyParamCaption}\item[{const \hyperlink{compiler__port_8h_a40bb5262bf908c328fbcfbe5d29d0201}{char\+\_\+t} $\ast$}]{name,  }\item[{\hyperlink{os__port__windows_8h_a52a4e1975bb554c2ce70aaac35b752d2}{Os\+Task\+Code}}]{task\+Code,  }\item[{void $\ast$}]{param,  }\item[{size\+\_\+t}]{stack\+Size,  }\item[{\hyperlink{compiler__port_8h_a022c65af7f6c8d3947e8a37d64db6ad6}{int\+\_\+t}}]{priority }\end{DoxyParamCaption})}



Create a new task. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & A name identifying the task \\
\hline
\mbox{\tt in}  & {\em task\+Code} & Pointer to the task entry function \\
\hline
\mbox{\tt in}  & {\em param} & A pointer to a variable to be passed to the task \\
\hline
\mbox{\tt in}  & {\em stack\+Size} & The initial size of the stack, in words \\
\hline
\mbox{\tt in}  & {\em priority} & The priority at which the task should run \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the function succeeds, the return value is a pointer to the new task. If the function fails, the return value is N\+U\+LL 
\end{DoxyReturn}


Definition at line 80 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
82 \{
83    osThreadId threadId;
84    osThreadDef\_t threadDef;
85 
86 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
87    threadDef.pthread = (os\_pthread) taskCode;
88    threadDef.tpriority = (osPriority) \hyperlink{dns__common_8h_a0815784d41b3c13d42ce22367abfba1d}{priority};
89    threadDef.instances = 1;
90    threadDef.stacksize = stackSize * \textcolor{keyword}{sizeof}(\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t});
91 \textcolor{preprocessor}{#elif defined(osCMSIS\_RTX) && (osCMSIS\_RTX >= 0x50000)}
92    threadDef.pthread = (os\_pthread) taskCode;
93    threadDef.attr.name = \hyperlink{resource__manager_8h_a26532d7194d592ae8da35222073f36d6}{name};
94    threadDef.attr.attr\_bits = 0;
95    threadDef.attr.cb\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
96    threadDef.attr.cb\_size = 0;
97    threadDef.attr.stack\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
98    threadDef.attr.stack\_size = stackSize * \textcolor{keyword}{sizeof}(\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t});
99    threadDef.attr.priority = (osPriority\_t) \hyperlink{dns__common_8h_a0815784d41b3c13d42ce22367abfba1d}{priority};
100    threadDef.attr.tz\_module = 0;
101    threadDef.attr.reserved = 0;
102 \textcolor{preprocessor}{#elif defined(osCMSIS\_FreeRTOS)}
103    threadDef.pthread = (os\_pthread) taskCode;
104    threadDef.attr.name = \hyperlink{resource__manager_8h_a26532d7194d592ae8da35222073f36d6}{name};
105    threadDef.attr.attr\_bits = 0;
106    threadDef.attr.cb\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
107    threadDef.attr.cb\_size = 0;
108    threadDef.attr.stack\_mem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
109    threadDef.attr.stack\_size = stackSize * \textcolor{keyword}{sizeof}(\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t});
110    threadDef.attr.priority = (osPriority\_t) \hyperlink{dns__common_8h_a0815784d41b3c13d42ce22367abfba1d}{priority};
111    threadDef.attr.tz\_module = 0;
112    threadDef.attr.reserved = 0;
113 \textcolor{preprocessor}{#else}
114    threadDef.name = (\hyperlink{compiler__port_8h_a40bb5262bf908c328fbcfbe5d29d0201}{char\_t} *) \hyperlink{resource__manager_8h_a26532d7194d592ae8da35222073f36d6}{name};
115    threadDef.pthread = (os\_pthread) taskCode;
116    threadDef.tpriority = (osPriority) \hyperlink{dns__common_8h_a0815784d41b3c13d42ce22367abfba1d}{priority};
117    threadDef.instances = 1;
118    threadDef.stacksize = stackSize;
119 \textcolor{preprocessor}{#endif}
120 
121    \textcolor{comment}{//Create a new thread}
122    threadId = osThreadCreate(&threadDef, param);
123    \textcolor{comment}{//Return a handle to the newly created thread}
124    \textcolor{keywordflow}{return} (\hyperlink{structOsTask}{OsTask} *) threadId;
125 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a69608590db97c707277aebf15be010e5}\label{os__port__cmsis__rtos_8c_a69608590db97c707277aebf15be010e5}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Delay\+Task@{os\+Delay\+Task}}
\index{os\+Delay\+Task@{os\+Delay\+Task}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Delay\+Task()}{osDelayTask()}}
{\footnotesize\ttfamily void os\+Delay\+Task (\begin{DoxyParamCaption}\item[{\hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t}}]{delay }\end{DoxyParamCaption})}



Delay routine. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em delay} & Amount of time for which the calling task should block \\
\hline
\end{DoxyParams}


Definition at line 153 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
154 \{
155    \textcolor{comment}{//Delay the thread for the specified duration}
156    osDelay(delay);
157 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a25827a49278bad6150b04b47165fda3d}\label{os__port__cmsis__rtos_8c_a25827a49278bad6150b04b47165fda3d}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Delete\+Event@{os\+Delete\+Event}}
\index{os\+Delete\+Event@{os\+Delete\+Event}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Delete\+Event()}{osDeleteEvent()}}
{\footnotesize\ttfamily void os\+Delete\+Event (\begin{DoxyParamCaption}\item[{\hyperlink{structOsEvent}{Os\+Event} $\ast$}]{event }\end{DoxyParamCaption})}



Delete an event object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em event} & Pointer to the event object \\
\hline
\end{DoxyParams}


Definition at line 260 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
261 \{
262    \textcolor{comment}{//Make sure the semaphore ID is valid}
263    \textcolor{keywordflow}{if}(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
264    \{
265       \textcolor{comment}{//Properly dispose the event object}
266       osSemaphoreDelete(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id});
267    \}
268 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a2b0ba1e39227e4a4d52ee46bbee15c11}\label{os__port__cmsis__rtos_8c_a2b0ba1e39227e4a4d52ee46bbee15c11}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Delete\+Mutex@{os\+Delete\+Mutex}}
\index{os\+Delete\+Mutex@{os\+Delete\+Mutex}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Delete\+Mutex()}{osDeleteMutex()}}
{\footnotesize\ttfamily void os\+Delete\+Mutex (\begin{DoxyParamCaption}\item[{\hyperlink{structOsMutex}{Os\+Mutex} $\ast$}]{mutex }\end{DoxyParamCaption})}



Delete a mutex object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em mutex} & Pointer to the mutex object \\
\hline
\end{DoxyParams}


Definition at line 564 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
565 \{
566    \textcolor{comment}{//Make sure the mutex ID is valid}
567    \textcolor{keywordflow}{if}(mutex->\hyperlink{structOsMutex_ae52709d6235dc8132a937fe9a1518878}{id} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
568    \{
569       \textcolor{comment}{//Properly dispose the specified mutex}
570       osMutexDelete(mutex->\hyperlink{structOsMutex_ae52709d6235dc8132a937fe9a1518878}{id});
571    \}
572 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a501b470967cd2cc9caf2fdee107e8590}\label{os__port__cmsis__rtos_8c_a501b470967cd2cc9caf2fdee107e8590}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Delete\+Semaphore@{os\+Delete\+Semaphore}}
\index{os\+Delete\+Semaphore@{os\+Delete\+Semaphore}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Delete\+Semaphore()}{osDeleteSemaphore()}}
{\footnotesize\ttfamily void os\+Delete\+Semaphore (\begin{DoxyParamCaption}\item[{\hyperlink{structOsSemaphore}{Os\+Semaphore} $\ast$}]{semaphore }\end{DoxyParamCaption})}



Delete a semaphore object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em semaphore} & Pointer to the semaphore object \\
\hline
\end{DoxyParams}


Definition at line 441 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
442 \{
443    \textcolor{comment}{//Make sure the semaphore ID is valid}
444    \textcolor{keywordflow}{if}(semaphore->\hyperlink{structOsSemaphore_a524627618a2b124f35e450b4ba708098}{id} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
445    \{
446       \textcolor{comment}{//Properly dispose the specified semaphore}
447       osSemaphoreDelete(semaphore->\hyperlink{structOsSemaphore_a524627618a2b124f35e450b4ba708098}{id});
448    \}
449 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_ae19a41c2cb0f1e7242f48c2dbbc36e8e}\label{os__port__cmsis__rtos_8c_ae19a41c2cb0f1e7242f48c2dbbc36e8e}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Delete\+Task@{os\+Delete\+Task}}
\index{os\+Delete\+Task@{os\+Delete\+Task}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Delete\+Task()}{osDeleteTask()}}
{\footnotesize\ttfamily void os\+Delete\+Task (\begin{DoxyParamCaption}\item[{\hyperlink{structOsTask}{Os\+Task} $\ast$}]{task }\end{DoxyParamCaption})}



Delete a task. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em task} & Pointer to the task to be deleted \\
\hline
\end{DoxyParams}


Definition at line 133 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
134 \{
135 \textcolor{preprocessor}{#if (osCMSIS >= 0x20000)}
136    \textcolor{comment}{//Delete the specified thread}
137    \textcolor{keywordflow}{if}(task == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
138       osThreadExit();
139    \textcolor{keywordflow}{else}
140       osThreadTerminate((osThreadId\_t) task);
141 \textcolor{preprocessor}{#else}
142    \textcolor{comment}{//Delete the specified thread}
143    osThreadTerminate((osThreadId) task);
144 \textcolor{preprocessor}{#endif}
145 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a68e4fa4326f2031eab28b92a25f2d68d}\label{os__port__cmsis__rtos_8c_a68e4fa4326f2031eab28b92a25f2d68d}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Free\+Mem@{os\+Free\+Mem}}
\index{os\+Free\+Mem@{os\+Free\+Mem}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Free\+Mem()}{osFreeMem()}}
{\footnotesize\ttfamily void os\+Free\+Mem (\begin{DoxyParamCaption}\item[{void $\ast$}]{p }\end{DoxyParamCaption})}



Release a previously allocated memory block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em p} & Previously allocated memory block to be freed \\
\hline
\end{DoxyParams}


Definition at line 659 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
660 \{
661    \textcolor{comment}{//Make sure the pointer is valid}
662    \textcolor{keywordflow}{if}(\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
663    \{
664       \textcolor{comment}{//Debug message}
665       \hyperlink{debug_8h_a67a8f9bc74358aa21745a76e23768dae}{TRACE\_DEBUG}(\textcolor{stringliteral}{"Freeing memory at 0x%08X\(\backslash\)r\(\backslash\)n"}, (\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t}) \hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p});
666 
667       \textcolor{comment}{//Enter critical section}
668       \hyperlink{os__port__cmsis__rtos_8c_abb64215d94a3d144b27a7f1509386366}{osSuspendAllTasks}();
669       \textcolor{comment}{//Free memory block}
670       free(\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p});
671       \textcolor{comment}{//Leave critical section}
672       \hyperlink{os__port__cmsis__rtos_8c_a1116ffd72c17afc85cc9c6ac00f1b06c}{osResumeAllTasks}();
673    \}
674 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_ab66a11272d40a916fa69dd8e4dc443d4}\label{os__port__cmsis__rtos_8c_ab66a11272d40a916fa69dd8e4dc443d4}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Get\+System\+Time@{os\+Get\+System\+Time}}
\index{os\+Get\+System\+Time@{os\+Get\+System\+Time}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Get\+System\+Time()}{osGetSystemTime()}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t} os\+Get\+System\+Time (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Retrieve system time. 

\begin{DoxyReturn}{Returns}
Number of milliseconds elapsed since the system was last started 
\end{DoxyReturn}


Definition at line 604 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
605 \{
606    \hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\_t} \hyperlink{dhcpv6__common_8h_ae73654f333e4363463ad8c594eca1905}{time};
607 
608 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
609    \textcolor{comment}{//Forward function declaration}
610    \textcolor{keyword}{extern} \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\_t} rt\_time\_get(\textcolor{keywordtype}{void});
611 
612    \textcolor{comment}{//Get current tick count}
613    time = rt\_time\_get();
614 \textcolor{preprocessor}{#elif defined(osCMSIS\_RTX) && (osCMSIS\_RTX >= 0x50000)}
615    time = osKernelGetTickCount();
616 \textcolor{preprocessor}{#elif defined(osCMSIS\_FreeRTOS)}
617    time = osKernelGetTickCount();
618 \textcolor{preprocessor}{#else}
619    \textcolor{comment}{//Get current tick count}
620    time = osKernelSysTick();
621 \textcolor{preprocessor}{#endif}
622 
623    \textcolor{comment}{//Convert system ticks to milliseconds}
624    \textcolor{keywordflow}{return} \hyperlink{os__port__chibios_8h_a457717ba71769e37ab62000b09ec7e44}{OS\_SYSTICKS\_TO\_MS}(time);
625 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_af1819038a84a0c1b18edbc8421d594ba}\label{os__port__cmsis__rtos_8c_af1819038a84a0c1b18edbc8421d594ba}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Init\+Kernel@{os\+Init\+Kernel}}
\index{os\+Init\+Kernel@{os\+Init\+Kernel}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Init\+Kernel()}{osInitKernel()}}
{\footnotesize\ttfamily void os\+Init\+Kernel (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Kernel initialization. 



Definition at line 44 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
45 \{
46 \textcolor{preprocessor}{#if (osCMSIS >= 0x10001)}
47    \textcolor{comment}{//Initialize the kernel}
48    osKernelInitialize();
49 \textcolor{preprocessor}{#endif}
50 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a8e10e5b2c6d3877b5ba60e375ac45d79}\label{os__port__cmsis__rtos_8c_a8e10e5b2c6d3877b5ba60e375ac45d79}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Release\+Mutex@{os\+Release\+Mutex}}
\index{os\+Release\+Mutex@{os\+Release\+Mutex}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Release\+Mutex()}{osReleaseMutex()}}
{\footnotesize\ttfamily void os\+Release\+Mutex (\begin{DoxyParamCaption}\item[{\hyperlink{structOsMutex}{Os\+Mutex} $\ast$}]{mutex }\end{DoxyParamCaption})}



Release ownership of the specified mutex object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em mutex} & Pointer to the mutex object \\
\hline
\end{DoxyParams}


Definition at line 592 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
593 \{
594    \textcolor{comment}{//Release ownership of the mutex object}
595    osMutexRelease(mutex->\hyperlink{structOsMutex_ae52709d6235dc8132a937fe9a1518878}{id});
596 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a33555fb6374f981567026d77e3b687fc}\label{os__port__cmsis__rtos_8c_a33555fb6374f981567026d77e3b687fc}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Release\+Semaphore@{os\+Release\+Semaphore}}
\index{os\+Release\+Semaphore@{os\+Release\+Semaphore}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Release\+Semaphore()}{osReleaseSemaphore()}}
{\footnotesize\ttfamily void os\+Release\+Semaphore (\begin{DoxyParamCaption}\item[{\hyperlink{structOsSemaphore}{Os\+Semaphore} $\ast$}]{semaphore }\end{DoxyParamCaption})}



Release the specified semaphore object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em semaphore} & Pointer to the semaphore object \\
\hline
\end{DoxyParams}


Definition at line 514 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
515 \{
516    \textcolor{comment}{//Release the semaphore}
517    osSemaphoreRelease(semaphore->\hyperlink{structOsSemaphore_a524627618a2b124f35e450b4ba708098}{id});
518 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a9122a1cf258caef553a6b224ef8ef6bf}\label{os__port__cmsis__rtos_8c_a9122a1cf258caef553a6b224ef8ef6bf}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Reset\+Event@{os\+Reset\+Event}}
\index{os\+Reset\+Event@{os\+Reset\+Event}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Reset\+Event()}{osResetEvent()}}
{\footnotesize\ttfamily void os\+Reset\+Event (\begin{DoxyParamCaption}\item[{\hyperlink{structOsEvent}{Os\+Event} $\ast$}]{event }\end{DoxyParamCaption})}



Set the specified event object to the nonsignaled state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em event} & Pointer to the event object \\
\hline
\end{DoxyParams}


Definition at line 288 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
289 \{
290 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
291    \textcolor{comment}{//Force the specified event to the nonsignaled state}
292    \textcolor{keywordflow}{while}(osSemaphoreWait(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id}, 0) > 0);
293 \textcolor{preprocessor}{#else}
294    \textcolor{comment}{//Force the specified event to the nonsignaled state}
295    osSemaphoreWait(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id}, 0);
296 \textcolor{preprocessor}{#endif}
297 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a1116ffd72c17afc85cc9c6ac00f1b06c}\label{os__port__cmsis__rtos_8c_a1116ffd72c17afc85cc9c6ac00f1b06c}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Resume\+All\+Tasks@{os\+Resume\+All\+Tasks}}
\index{os\+Resume\+All\+Tasks@{os\+Resume\+All\+Tasks}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Resume\+All\+Tasks()}{osResumeAllTasks()}}
{\footnotesize\ttfamily void os\+Resume\+All\+Tasks (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Resume scheduler activity. 



Definition at line 194 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
195 \{
196 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) || defined(osCMSIS\_FreeRTOS)}
197    \textcolor{comment}{//Not implemented}
198 \textcolor{preprocessor}{#else}
199    \textcolor{comment}{//Make sure the operating system is running}
200    \textcolor{keywordflow}{if}(osKernelRunning())
201    \{
202       \textcolor{comment}{//Resume all threads}
203       osThreadResumeAll();
204    \}
205 \textcolor{preprocessor}{#endif}
206 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_afc1d64fc90afbf03baecfa636bb99ff7}\label{os__port__cmsis__rtos_8c_afc1d64fc90afbf03baecfa636bb99ff7}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Set\+Event@{os\+Set\+Event}}
\index{os\+Set\+Event@{os\+Set\+Event}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Set\+Event()}{osSetEvent()}}
{\footnotesize\ttfamily void os\+Set\+Event (\begin{DoxyParamCaption}\item[{\hyperlink{structOsEvent}{Os\+Event} $\ast$}]{event }\end{DoxyParamCaption})}



Set the specified event object to the signaled state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em event} & Pointer to the event object \\
\hline
\end{DoxyParams}


Definition at line 276 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
277 \{
278    \textcolor{comment}{//Set the specified event to the signaled state}
279    osSemaphoreRelease(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id});
280 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_aa30d505571a03dd645af374f40bd7016}\label{os__port__cmsis__rtos_8c_aa30d505571a03dd645af374f40bd7016}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Set\+Event\+From\+Isr@{os\+Set\+Event\+From\+Isr}}
\index{os\+Set\+Event\+From\+Isr@{os\+Set\+Event\+From\+Isr}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Set\+Event\+From\+Isr()}{osSetEventFromIsr()}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} os\+Set\+Event\+From\+Isr (\begin{DoxyParamCaption}\item[{\hyperlink{structOsEvent}{Os\+Event} $\ast$}]{event }\end{DoxyParamCaption})}



Set an event object to the signaled state from an interrupt service routine. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em event} & Pointer to the event object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
T\+R\+UE if setting the event to signaled state caused a task to unblock and the unblocked task has a priority higher than the currently running task 
\end{DoxyReturn}


Definition at line 386 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
387 \{
388    \textcolor{comment}{//Set the specified event to the signaled state}
389    osSemaphoreRelease(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id});
390 
391    \textcolor{comment}{//The return value is not relevant}
392    \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
393 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_ae09f7770c80e669e765b9f22a837ed18}\label{os__port__cmsis__rtos_8c_ae09f7770c80e669e765b9f22a837ed18}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Start\+Kernel@{os\+Start\+Kernel}}
\index{os\+Start\+Kernel@{os\+Start\+Kernel}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Start\+Kernel()}{osStartKernel()}}
{\footnotesize\ttfamily void os\+Start\+Kernel (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Start kernel. 



Definition at line 57 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
58 \{
59 \textcolor{preprocessor}{#if (osCMSIS >= 0x10001)}
60    \textcolor{comment}{//Start the kernel}
61    osKernelStart();
62 \textcolor{preprocessor}{#else}
63    \textcolor{comment}{//Start the kernel}
64    osKernelStart(\hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
65 \textcolor{preprocessor}{#endif}
66 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_abb64215d94a3d144b27a7f1509386366}\label{os__port__cmsis__rtos_8c_abb64215d94a3d144b27a7f1509386366}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Suspend\+All\+Tasks@{os\+Suspend\+All\+Tasks}}
\index{os\+Suspend\+All\+Tasks@{os\+Suspend\+All\+Tasks}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Suspend\+All\+Tasks()}{osSuspendAllTasks()}}
{\footnotesize\ttfamily void os\+Suspend\+All\+Tasks (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Suspend scheduler activity. 



Definition at line 175 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
176 \{
177 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) || defined(osCMSIS\_FreeRTOS)}
178    \textcolor{comment}{//Not implemented}
179 \textcolor{preprocessor}{#else}
180    \textcolor{comment}{//Make sure the operating system is running}
181    \textcolor{keywordflow}{if}(osKernelRunning())
182    \{
183       \textcolor{comment}{//Suspend all threads}
184       osThreadSuspendAll();
185    \}
186 \textcolor{preprocessor}{#endif}
187 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a0f90518dbc8cd7221762e1acf29e8d27}\label{os__port__cmsis__rtos_8c_a0f90518dbc8cd7221762e1acf29e8d27}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Switch\+Task@{os\+Switch\+Task}}
\index{os\+Switch\+Task@{os\+Switch\+Task}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Switch\+Task()}{osSwitchTask()}}
{\footnotesize\ttfamily void os\+Switch\+Task (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Yield control to the next task. 



Definition at line 164 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
165 \{
166    \textcolor{comment}{//Force a context switch}
167    osThreadYield();
168 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a1dc707247e44dfefae5bec4a322fc78a}\label{os__port__cmsis__rtos_8c_a1dc707247e44dfefae5bec4a322fc78a}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Wait\+For\+Event@{os\+Wait\+For\+Event}}
\index{os\+Wait\+For\+Event@{os\+Wait\+For\+Event}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Wait\+For\+Event()}{osWaitForEvent()}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} os\+Wait\+For\+Event (\begin{DoxyParamCaption}\item[{\hyperlink{structOsEvent}{Os\+Event} $\ast$}]{event,  }\item[{\hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t}}]{timeout }\end{DoxyParamCaption})}



Wait until the specified event is in the signaled state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em event} & Pointer to the event object \\
\hline
\mbox{\tt in}  & {\em timeout} & Timeout interval \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function returns T\+R\+UE if the state of the specified object is signaled. F\+A\+L\+SE is returned if the timeout interval elapsed 
\end{DoxyReturn}


Definition at line 308 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
309 \{
310    \hyperlink{stdint_8h_ab1967d8591af1a4e48c37fd2b0f184d0}{int32\_t} ret;
311 
312    \textcolor{comment}{//Wait until the specified event is in the signaled}
313    \textcolor{comment}{//state or the timeout interval elapses}
314    \textcolor{keywordflow}{if}(timeout == \hyperlink{os__port_8h_ab893de6f8a0ec8b0e6dd8097ff398019}{INFINITE\_DELAY})
315    \{
316       \textcolor{comment}{//Infinite timeout period}
317       ret = osSemaphoreWait(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id}, osWaitForever);
318    \}
319    \textcolor{keywordflow}{else}
320    \{
321 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
322       \hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\_t} \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
323 
324       \textcolor{comment}{//Loop until the assigned time period has elapsed}
325       \textcolor{keywordflow}{do}
326       \{
327          \textcolor{comment}{//Limit the timeout value}
328          n = \hyperlink{os__port_8h_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(timeout, 10000);
329          \textcolor{comment}{//Wait for the specified time interval}
330          ret = osSemaphoreWait(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id}, n);
331          \textcolor{comment}{//Decrement timeout value}
332          timeout -= \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
333 
334          \textcolor{comment}{//Check timeout value}
335       \} \textcolor{keywordflow}{while}(ret == 0 && timeout > 0);
336 \textcolor{preprocessor}{#else}
337       \textcolor{comment}{//Wait for the specified time interval}
338       ret = osSemaphoreWait(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id}, timeout);
339 \textcolor{preprocessor}{#endif}
340    \}
341 
342 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
343    \textcolor{comment}{//Check return value}
344    \textcolor{keywordflow}{if}(ret > 0)
345    \{
346       \textcolor{comment}{//Force the event back to the nonsignaled state}
347       \textcolor{keywordflow}{while}(osSemaphoreWait(event->\hyperlink{structOsEvent_a3444bc46bf8865f17612f50c9f355195}{id}, 0) > 0);
348 
349       \textcolor{comment}{//The specified event is in the signaled state}
350       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
351    \}
352    \textcolor{keywordflow}{else}
353    \{
354       \textcolor{comment}{//The timeout interval elapsed}
355       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
356    \}
357 \textcolor{preprocessor}{#elif defined(osCMSIS\_RTX) && (osCMSIS\_RTX >= 0x50000)}
358    \textcolor{comment}{//Check return value}
359    \textcolor{keywordflow}{if}(ret > 0)
360       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
361    \textcolor{keywordflow}{else}
362       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
363 \textcolor{preprocessor}{#elif defined(osCMSIS\_FreeRTOS)}
364    \textcolor{comment}{//Check return value}
365    \textcolor{keywordflow}{if}(ret > 0)
366       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
367    \textcolor{keywordflow}{else}
368       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
369 \textcolor{preprocessor}{#else}
370    \textcolor{comment}{//Check return value}
371    \textcolor{keywordflow}{if}(ret == osOK)
372       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
373    \textcolor{keywordflow}{else}
374       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
375 \textcolor{preprocessor}{#endif}
376 \}
\end{DoxyCode}
\mbox{\Hypertarget{os__port__cmsis__rtos_8c_a77807eaba2cdb91423e0b238f5282e50}\label{os__port__cmsis__rtos_8c_a77807eaba2cdb91423e0b238f5282e50}} 
\index{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}!os\+Wait\+For\+Semaphore@{os\+Wait\+For\+Semaphore}}
\index{os\+Wait\+For\+Semaphore@{os\+Wait\+For\+Semaphore}!os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c@{os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c}}
\subsubsection{\texorpdfstring{os\+Wait\+For\+Semaphore()}{osWaitForSemaphore()}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} os\+Wait\+For\+Semaphore (\begin{DoxyParamCaption}\item[{\hyperlink{structOsSemaphore}{Os\+Semaphore} $\ast$}]{semaphore,  }\item[{\hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t}}]{timeout }\end{DoxyParamCaption})}



Wait for the specified semaphore to be available. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em semaphore} & Pointer to the semaphore object \\
\hline
\mbox{\tt in}  & {\em timeout} & Timeout interval \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function returns T\+R\+UE if the semaphore is available. F\+A\+L\+SE is returned if the timeout interval elapsed 
\end{DoxyReturn}


Definition at line 460 of file os\+\_\+port\+\_\+cmsis\+\_\+rtos.\+c.


\begin{DoxyCode}
461 \{
462    \hyperlink{stdint_8h_ab1967d8591af1a4e48c37fd2b0f184d0}{int32\_t} ret;
463 
464    \textcolor{comment}{//Wait until the semaphore is available or the timeout interval elapses}
465    \textcolor{keywordflow}{if}(timeout == \hyperlink{os__port_8h_ab893de6f8a0ec8b0e6dd8097ff398019}{INFINITE\_DELAY})
466    \{
467       \textcolor{comment}{//Infinite timeout period}
468       ret = osSemaphoreWait(semaphore->\hyperlink{structOsSemaphore_a524627618a2b124f35e450b4ba708098}{id}, osWaitForever);
469    \}
470    \textcolor{keywordflow}{else}
471    \{
472 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) && (osCMSIS\_RTX < 0x50000)}
473       \hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\_t} \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
474 
475       \textcolor{comment}{//Loop until the assigned time period has elapsed}
476       \textcolor{keywordflow}{do}
477       \{
478          \textcolor{comment}{//Limit the timeout value}
479          n = \hyperlink{os__port_8h_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(timeout, 10000);
480          \textcolor{comment}{//Wait for the specified time interval}
481          ret = osSemaphoreWait(semaphore->\hyperlink{structOsSemaphore_a524627618a2b124f35e450b4ba708098}{id}, n);
482          \textcolor{comment}{//Decrement timeout value}
483          timeout -= \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
484 
485          \textcolor{comment}{//Check timeout value}
486       \} \textcolor{keywordflow}{while}(ret == 0 && timeout > 0);
487 \textcolor{preprocessor}{#else}
488       \textcolor{comment}{//Wait for the specified time interval}
489       ret = osSemaphoreWait(semaphore->\hyperlink{structOsSemaphore_a524627618a2b124f35e450b4ba708098}{id}, timeout);
490 \textcolor{preprocessor}{#endif}
491    \}
492 
493 \textcolor{preprocessor}{#if defined(osCMSIS\_RTX) || defined(osCMSIS\_FreeRTOS)}
494    \textcolor{comment}{//Check return value}
495    \textcolor{keywordflow}{if}(ret > 0)
496       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
497    \textcolor{keywordflow}{else}
498       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
499 \textcolor{preprocessor}{#else}
500    \textcolor{comment}{//Check return value}
501    \textcolor{keywordflow}{if}(ret == osOK)
502       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
503    \textcolor{keywordflow}{else}
504       \textcolor{keywordflow}{return} \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
505 \textcolor{preprocessor}{#endif}
506 \}
\end{DoxyCode}
