\hypertarget{portable_8h}{}\section{third\+\_\+party/freertos/include/portable.h File Reference}
\label{portable_8h}\index{third\+\_\+party/freertos/include/portable.\+h@{third\+\_\+party/freertos/include/portable.\+h}}
{\ttfamily \#include \char`\"{}deprecated\+\_\+definitions.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}portmacro.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}mpu\+\_\+wrappers.\+h\char`\"{}}\newline
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structHeapRegion}{Heap\+Region}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{portable_8h_aca7e1a8a568a38b74cc9db10c8efebda}{port\+N\+U\+M\+\_\+\+C\+O\+N\+F\+I\+G\+U\+R\+A\+B\+L\+E\+\_\+\+R\+E\+G\+I\+O\+NS}~1
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structHeapRegion}{Heap\+Region} \hyperlink{portable_8h_a2496d40e3117c2f7c473d7fb6b77654d}{Heap\+Region\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{Stack\+Type\+\_\+t} $\ast$ \hyperlink{portable_8h_abb736501b227deb79f234b30eaf090e3}{px\+Port\+Initialise\+Stack} (\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{Stack\+Type\+\_\+t} $\ast$px\+Top\+Of\+Stack, \hyperlink{projdefs_8h_a9b32502ff92c255c686dacde53c1cba0}{Task\+Function\+\_\+t} px\+Code, void $\ast$pv\+Parameters) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
void \hyperlink{portable_8h_a4f3a75726f448c4170d9d6565bdef636}{v\+Port\+Define\+Heap\+Regions} (const \hyperlink{portable_8h_a2496d40e3117c2f7c473d7fb6b77654d}{Heap\+Region\+\_\+t} $\ast$const px\+Heap\+Regions) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
void $\ast$ \hyperlink{portable_8h_a237d63f90b28e0950bd86f76815cd6e3}{pv\+Port\+Malloc} (size\+\_\+t x\+Size) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
void \hyperlink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{v\+Port\+Free} (void $\ast$pv) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
void \hyperlink{portable_8h_a846b5ebdaf2b51fe707efb4a0974f676}{v\+Port\+Initialise\+Blocks} (void) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
size\+\_\+t \hyperlink{portable_8h_a8f72fbee5c25c956bda528299ce6dd02}{x\+Port\+Get\+Free\+Heap\+Size} (void) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
size\+\_\+t \hyperlink{portable_8h_a6195704430323f2e97ea4deab7a4eece}{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size} (void) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{portable_8h_a4f3b1bb7590996f2fa1e0456dda961ff}{x\+Port\+Start\+Scheduler} (void) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
void \hyperlink{portable_8h_aa356b7baaa9089490321aa919542dd6c}{v\+Port\+End\+Scheduler} (void) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{portable_8h_aca7e1a8a568a38b74cc9db10c8efebda}\label{portable_8h_aca7e1a8a568a38b74cc9db10c8efebda}} 
\index{portable.\+h@{portable.\+h}!port\+N\+U\+M\+\_\+\+C\+O\+N\+F\+I\+G\+U\+R\+A\+B\+L\+E\+\_\+\+R\+E\+G\+I\+O\+NS@{port\+N\+U\+M\+\_\+\+C\+O\+N\+F\+I\+G\+U\+R\+A\+B\+L\+E\+\_\+\+R\+E\+G\+I\+O\+NS}}
\index{port\+N\+U\+M\+\_\+\+C\+O\+N\+F\+I\+G\+U\+R\+A\+B\+L\+E\+\_\+\+R\+E\+G\+I\+O\+NS@{port\+N\+U\+M\+\_\+\+C\+O\+N\+F\+I\+G\+U\+R\+A\+B\+L\+E\+\_\+\+R\+E\+G\+I\+O\+NS}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{port\+N\+U\+M\+\_\+\+C\+O\+N\+F\+I\+G\+U\+R\+A\+B\+L\+E\+\_\+\+R\+E\+G\+I\+O\+NS}{portNUM\_CONFIGURABLE\_REGIONS}}
{\footnotesize\ttfamily \#define port\+N\+U\+M\+\_\+\+C\+O\+N\+F\+I\+G\+U\+R\+A\+B\+L\+E\+\_\+\+R\+E\+G\+I\+O\+NS~1}



Definition at line 84 of file portable.\+h.



\subsection{Typedef Documentation}
\mbox{\Hypertarget{portable_8h_a2496d40e3117c2f7c473d7fb6b77654d}\label{portable_8h_a2496d40e3117c2f7c473d7fb6b77654d}} 
\index{portable.\+h@{portable.\+h}!Heap\+Region\+\_\+t@{Heap\+Region\+\_\+t}}
\index{Heap\+Region\+\_\+t@{Heap\+Region\+\_\+t}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{Heap\+Region\+\_\+t}{HeapRegion\_t}}
{\footnotesize\ttfamily typedef struct \hyperlink{structHeapRegion}{Heap\+Region}  \hyperlink{portable_8h_a2496d40e3117c2f7c473d7fb6b77654d}{Heap\+Region\+\_\+t}}



\subsection{Function Documentation}
\mbox{\Hypertarget{portable_8h_a237d63f90b28e0950bd86f76815cd6e3}\label{portable_8h_a237d63f90b28e0950bd86f76815cd6e3}} 
\index{portable.\+h@{portable.\+h}!pv\+Port\+Malloc@{pv\+Port\+Malloc}}
\index{pv\+Port\+Malloc@{pv\+Port\+Malloc}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{pv\+Port\+Malloc()}{pvPortMalloc()}}
{\footnotesize\ttfamily void$\ast$ pv\+Port\+Malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{x\+Size }\end{DoxyParamCaption})}



Definition at line 69 of file heap\+\_\+1.\+c.


\begin{DoxyCode}
70 \{
71 \textcolor{keywordtype}{void} *pvReturn = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
72 \textcolor{keyword}{static} \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *pucAlignedHeap = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
73 
74     \textcolor{comment}{/* Ensure that blocks are always aligned to the required number of bytes. */}
75 \textcolor{preprocessor}{    #if( portBYTE\_ALIGNMENT != 1 )}
76     \{
77         \textcolor{keywordflow}{if}( xWantedSize & portBYTE\_ALIGNMENT\_MASK )
78         \{
79             \textcolor{comment}{/* Byte alignment required. */}
80             xWantedSize += ( \hyperlink{pic32mx_2portmacro_8h_ab9091ce3940d8bd93ec850122a2c6a1c}{portBYTE\_ALIGNMENT} - ( xWantedSize & portBYTE\_ALIGNMENT\_MASK
       ) );
81         \}
82     \}
83 \textcolor{preprocessor}{    #endif}
84 
85     \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
86     \{
87         \textcolor{keywordflow}{if}( pucAlignedHeap == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
88         \{
89             \textcolor{comment}{/* Ensure the heap starts on a correctly aligned boundary. */}
90             pucAlignedHeap = ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} * ) ( ( ( \hyperlink{FreeRTOS_8h_a53bae25f223b7156dce0fc6e6b1b2295}{portPOINTER\_SIZE\_TYPE} ) &
      \hyperlink{heap__1_8c_a286aa29b13471f0d9f5a7ce688682694}{ucHeap}[ \hyperlink{pic32mx_2portmacro_8h_ab9091ce3940d8bd93ec850122a2c6a1c}{portBYTE\_ALIGNMENT} ] ) & ( ~( ( 
      \hyperlink{FreeRTOS_8h_a53bae25f223b7156dce0fc6e6b1b2295}{portPOINTER\_SIZE\_TYPE} ) portBYTE\_ALIGNMENT\_MASK ) ) );
91         \}
92 
93         \textcolor{comment}{/* Check there is enough room left for the allocation. */}
94         \textcolor{keywordflow}{if}( ( ( \hyperlink{heap__1_8c_a9f84d71523e492ed69679829b2d827c4}{xNextFreeByte} + xWantedSize ) < 
      \hyperlink{heap__1_8c_a3e68bebe7509a99550e1358cbca8e23f}{configADJUSTED\_HEAP\_SIZE} ) &&
95             ( ( \hyperlink{heap__1_8c_a9f84d71523e492ed69679829b2d827c4}{xNextFreeByte} + xWantedSize ) > \hyperlink{heap__1_8c_a9f84d71523e492ed69679829b2d827c4}{xNextFreeByte} )   )\textcolor{comment}{/* Check for
       overflow. */}
96         \{
97             \textcolor{comment}{/* Return the next free byte then increment the index past this}
98 \textcolor{comment}{            block. */}
99             pvReturn = pucAlignedHeap + \hyperlink{heap__1_8c_a9f84d71523e492ed69679829b2d827c4}{xNextFreeByte};
100             xNextFreeByte += xWantedSize;
101         \}
102 
103         \hyperlink{FreeRTOS_8h_af326afe922ffa6da245c98dc227a3293}{traceMALLOC}( pvReturn, xWantedSize );
104     \}
105     ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
106 
107 \textcolor{preprocessor}{    #if( configUSE\_MALLOC\_FAILED\_HOOK == 1 )}
108     \{
109         \textcolor{keywordflow}{if}( pvReturn == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
110         \{
111             \textcolor{keyword}{extern} \textcolor{keywordtype}{void} vApplicationMallocFailedHook( \textcolor{keywordtype}{void} );
112             vApplicationMallocFailedHook();
113         \}
114     \}
115 \textcolor{preprocessor}{    #endif}
116 
117     \textcolor{keywordflow}{return} pvReturn;
118 \}
\end{DoxyCode}
\mbox{\Hypertarget{portable_8h_abb736501b227deb79f234b30eaf090e3}\label{portable_8h_abb736501b227deb79f234b30eaf090e3}} 
\index{portable.\+h@{portable.\+h}!px\+Port\+Initialise\+Stack@{px\+Port\+Initialise\+Stack}}
\index{px\+Port\+Initialise\+Stack@{px\+Port\+Initialise\+Stack}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{px\+Port\+Initialise\+Stack()}{pxPortInitialiseStack()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{Stack\+Type\+\_\+t}$\ast$ px\+Port\+Initialise\+Stack (\begin{DoxyParamCaption}\item[{\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{Stack\+Type\+\_\+t} $\ast$}]{px\+Top\+Of\+Stack,  }\item[{\hyperlink{projdefs_8h_a9b32502ff92c255c686dacde53c1cba0}{Task\+Function\+\_\+t}}]{px\+Code,  }\item[{void $\ast$}]{pv\+Parameters }\end{DoxyParamCaption})}



Definition at line 160 of file port.\+c.


\begin{DoxyCode}
161 \{
162     \textcolor{comment}{/* Ensure byte alignment is maintained when leaving this function. */}
163     pxTopOfStack--;
164 
165     *pxTopOfStack = (\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{StackType\_t}) 0xDEADBEEF;
166     pxTopOfStack--;
167 
168     *pxTopOfStack = (\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{StackType\_t}) 0x12345678;    \textcolor{comment}{/* Word to which the stack pointer will be left
       pointing after context restore. */}
169     pxTopOfStack--;
170 
171     *pxTopOfStack = (\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{StackType\_t}) \_CP0\_GET\_CAUSE();
172     pxTopOfStack--;
173 
174     *pxTopOfStack = (\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{StackType\_t}) \hyperlink{pic32mx_2port_8c_a26624b2cf57368e3719a498832ecb658}{portINITIAL\_SR};\textcolor{comment}{/* CP0\_STATUS */}
175     pxTopOfStack--;
176 
177     *pxTopOfStack = (\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{StackType\_t}) pxCode;        \textcolor{comment}{/* CP0\_EPC */}
178     pxTopOfStack--;
179 
180     *pxTopOfStack = (\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{StackType\_t}) \hyperlink{pic32mx_2port_8c_a254a1ddd7499c6ec36b38e2fc3486b80}{portTASK\_RETURN\_ADDRESS};    \textcolor{comment}{/* ra */}
181     pxTopOfStack -= 15;
182 
183     *pxTopOfStack = (\hyperlink{pic32mx_2portmacro_8h_a84e9a8ba132feed0b2401c1f4e2ac63c}{StackType\_t}) pvParameters; \textcolor{comment}{/* Parameters to pass in. */}
184     pxTopOfStack -= 15;
185 
186     \textcolor{keywordflow}{return} pxTopOfStack;
187 \}
\end{DoxyCode}
\mbox{\Hypertarget{portable_8h_a4f3a75726f448c4170d9d6565bdef636}\label{portable_8h_a4f3a75726f448c4170d9d6565bdef636}} 
\index{portable.\+h@{portable.\+h}!v\+Port\+Define\+Heap\+Regions@{v\+Port\+Define\+Heap\+Regions}}
\index{v\+Port\+Define\+Heap\+Regions@{v\+Port\+Define\+Heap\+Regions}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{v\+Port\+Define\+Heap\+Regions()}{vPortDefineHeapRegions()}}
{\footnotesize\ttfamily void v\+Port\+Define\+Heap\+Regions (\begin{DoxyParamCaption}\item[{const \hyperlink{portable_8h_a2496d40e3117c2f7c473d7fb6b77654d}{Heap\+Region\+\_\+t} $\ast$const}]{px\+Heap\+Regions }\end{DoxyParamCaption})}



Definition at line 393 of file heap\+\_\+5.\+c.


\begin{DoxyCode}
394 \{
395 \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} *pxFirstFreeBlockInRegion = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}, *pxPreviousFreeBlock;
396 \textcolor{keywordtype}{size\_t} xAlignedHeap;
397 \textcolor{keywordtype}{size\_t} xTotalRegionSize, xTotalHeapSize = 0;
398 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xDefinedRegions = 0;
399 \textcolor{keywordtype}{size\_t} xAddress;
400 \textcolor{keyword}{const} \hyperlink{structHeapRegion}{HeapRegion\_t} *pxHeapRegion;
401 
402     \textcolor{comment}{/* Can only call once! */}
403     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( \hyperlink{heap__5_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd} == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} );
404 
405     pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
406 
407     \textcolor{keywordflow}{while}( pxHeapRegion->\hyperlink{structHeapRegion_a5933b0fd422e70a92ceef839b89a757f}{xSizeInBytes} > 0 )
408     \{
409         xTotalRegionSize = pxHeapRegion->\hyperlink{structHeapRegion_a5933b0fd422e70a92ceef839b89a757f}{xSizeInBytes};
410 
411         \textcolor{comment}{/* Ensure the heap region starts on a correctly aligned boundary. */}
412         xAddress = ( size\_t ) pxHeapRegion->\hyperlink{structHeapRegion_aab323508c34642ebfb884a68441d97fc}{pucStartAddress};
413         \textcolor{keywordflow}{if}( ( xAddress & portBYTE\_ALIGNMENT\_MASK ) != 0 )
414         \{
415             xAddress += ( \hyperlink{pic32mx_2portmacro_8h_ab9091ce3940d8bd93ec850122a2c6a1c}{portBYTE\_ALIGNMENT} - 1 );
416             xAddress &= ~portBYTE\_ALIGNMENT\_MASK;
417 
418             \textcolor{comment}{/* Adjust the size for the bytes lost to alignment. */}
419             xTotalRegionSize -= xAddress - ( size\_t ) pxHeapRegion->
      \hyperlink{structHeapRegion_aab323508c34642ebfb884a68441d97fc}{pucStartAddress};
420         \}
421 
422         xAlignedHeap = xAddress;
423 
424         \textcolor{comment}{/* Set xStart if it has not already been set. */}
425         \textcolor{keywordflow}{if}( xDefinedRegions == 0 )
426         \{
427             \textcolor{comment}{/* xStart is used to hold a pointer to the first item in the list of}
428 \textcolor{comment}{            free blocks.  The void cast is used to prevent compiler warnings. */}
429             \hyperlink{heap__5_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}{xStart}.\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = ( \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} * ) xAlignedHeap;
430             \hyperlink{heap__5_8c_a02f2ab4cbfe2167dc3bbdaf9b6c629c9}{xStart}.\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} = ( size\_t ) 0;
431         \}
432         \textcolor{keywordflow}{else}
433         \{
434             \textcolor{comment}{/* Should only get here if one region has already been added to the}
435 \textcolor{comment}{            heap. */}
436             \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( \hyperlink{heap__5_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} );
437 
438             \textcolor{comment}{/* Check blocks are passed in with increasing start addresses. */}
439             \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( xAddress > ( \textcolor{keywordtype}{size\_t} ) \hyperlink{heap__5_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd} );
440         \}
441 
442         \textcolor{comment}{/* Remember the location of the end marker in the previous region, if}
443 \textcolor{comment}{        any. */}
444         pxPreviousFreeBlock = \hyperlink{heap__5_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd};
445 
446         \textcolor{comment}{/* pxEnd is used to mark the end of the list of free blocks and is}
447 \textcolor{comment}{        inserted at the end of the region space. */}
448         xAddress = xAlignedHeap + xTotalRegionSize;
449         xAddress -= \hyperlink{heap__5_8c_aff7bec0da6b44e3634d215b40eb1db76}{xHeapStructSize};
450         xAddress &= ~portBYTE\_ALIGNMENT\_MASK;
451         \hyperlink{heap__5_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd} = ( \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} * ) xAddress;
452         \hyperlink{heap__5_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd}->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} = 0;
453         \hyperlink{heap__5_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd}->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
454 
455         \textcolor{comment}{/* To start with there is a single free block in this region that is}
456 \textcolor{comment}{        sized to take up the entire heap region minus the space taken by the}
457 \textcolor{comment}{        free block structure. */}
458         pxFirstFreeBlockInRegion = ( \hyperlink{structA__BLOCK__LINK}{BlockLink\_t} * ) xAlignedHeap;
459         pxFirstFreeBlockInRegion->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize} = xAddress - ( size\_t ) pxFirstFreeBlockInRegion;
460         pxFirstFreeBlockInRegion->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = \hyperlink{heap__5_8c_a9e133e4e5cd5400005b1378227cbdf7e}{pxEnd};
461 
462         \textcolor{comment}{/* If this is not the first region that makes up the entire heap space}
463 \textcolor{comment}{        then link the previous region to this region. */}
464         \textcolor{keywordflow}{if}( pxPreviousFreeBlock != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
465         \{
466             pxPreviousFreeBlock->\hyperlink{structA__BLOCK__LINK_aaef1b26e95b0b7b7ebffc91fa6ce874f}{pxNextFreeBlock} = pxFirstFreeBlockInRegion;
467         \}
468 
469         xTotalHeapSize += pxFirstFreeBlockInRegion->\hyperlink{structA__BLOCK__LINK_ad5dcf5df03d8be6186c567be9e2c657b}{xBlockSize};
470 
471         \textcolor{comment}{/* Move onto the next HeapRegion\_t structure. */}
472         xDefinedRegions++;
473         pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
474     \}
475 
476     \hyperlink{heap__5_8c_ae88e8dc4d81326f752232a0a39eb119f}{xMinimumEverFreeBytesRemaining} = xTotalHeapSize;
477     \hyperlink{heap__5_8c_a338244e3e604d3b290a3ef1903e97e4b}{xFreeBytesRemaining} = xTotalHeapSize;
478 
479     \textcolor{comment}{/* Check something was actually defined before it is accessed. */}
480     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( xTotalHeapSize );
481 
482     \textcolor{comment}{/* Work out the position of the top bit in a size\_t variable. */}
483     \hyperlink{heap__5_8c_ad7d272a4def963ce2d0185bb02fc7da4}{xBlockAllocatedBit} = ( ( size\_t ) 1 ) << ( ( \textcolor{keyword}{sizeof}( size\_t ) * 
      \hyperlink{heap__5_8c_adcef0c4245ebe20ca2b08a574c1caac9}{heapBITS\_PER\_BYTE} ) - 1 );
484 \}
\end{DoxyCode}
\mbox{\Hypertarget{portable_8h_aa356b7baaa9089490321aa919542dd6c}\label{portable_8h_aa356b7baaa9089490321aa919542dd6c}} 
\index{portable.\+h@{portable.\+h}!v\+Port\+End\+Scheduler@{v\+Port\+End\+Scheduler}}
\index{v\+Port\+End\+Scheduler@{v\+Port\+End\+Scheduler}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{v\+Port\+End\+Scheduler()}{vPortEndScheduler()}}
{\footnotesize\ttfamily void v\+Port\+End\+Scheduler (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 233 of file port.\+c.


\begin{DoxyCode}
234 \{
235     \textcolor{comment}{/* Not implemented in ports where there is nothing to return to.}
236 \textcolor{comment}{    Artificially force an assert. */}
237     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( \hyperlink{pic32mz_2port_8c_a60c776e8fe8808f7188ee8b0a52f5313}{uxInterruptNesting} == 1000UL );
238 \}
\end{DoxyCode}
\mbox{\Hypertarget{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}\label{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}} 
\index{portable.\+h@{portable.\+h}!v\+Port\+Free@{v\+Port\+Free}}
\index{v\+Port\+Free@{v\+Port\+Free}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{v\+Port\+Free()}{vPortFree()}}
{\footnotesize\ttfamily void v\+Port\+Free (\begin{DoxyParamCaption}\item[{void $\ast$}]{pv }\end{DoxyParamCaption})}



Definition at line 121 of file heap\+\_\+1.\+c.


\begin{DoxyCode}
122 \{
123     \textcolor{comment}{/* Memory cannot be freed using this scheme.  See heap\_2.c, heap\_3.c and}
124 \textcolor{comment}{    heap\_4.c for alternative implementations, and the memory management pages of}
125 \textcolor{comment}{    http://www.FreeRTOS.org for more information. */}
126     ( void ) pv;
127 
128     \textcolor{comment}{/* Force an assert as it is invalid to call this function. */}
129     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pv == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} );
130 \}
\end{DoxyCode}
\mbox{\Hypertarget{portable_8h_a846b5ebdaf2b51fe707efb4a0974f676}\label{portable_8h_a846b5ebdaf2b51fe707efb4a0974f676}} 
\index{portable.\+h@{portable.\+h}!v\+Port\+Initialise\+Blocks@{v\+Port\+Initialise\+Blocks}}
\index{v\+Port\+Initialise\+Blocks@{v\+Port\+Initialise\+Blocks}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{v\+Port\+Initialise\+Blocks()}{vPortInitialiseBlocks()}}
{\footnotesize\ttfamily void v\+Port\+Initialise\+Blocks (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 133 of file heap\+\_\+1.\+c.


\begin{DoxyCode}
134 \{
135     \textcolor{comment}{/* Only required when static memory is not cleared. */}
136     \hyperlink{heap__1_8c_a9f84d71523e492ed69679829b2d827c4}{xNextFreeByte} = ( size\_t ) 0;
137 \}
\end{DoxyCode}
\mbox{\Hypertarget{portable_8h_a8f72fbee5c25c956bda528299ce6dd02}\label{portable_8h_a8f72fbee5c25c956bda528299ce6dd02}} 
\index{portable.\+h@{portable.\+h}!x\+Port\+Get\+Free\+Heap\+Size@{x\+Port\+Get\+Free\+Heap\+Size}}
\index{x\+Port\+Get\+Free\+Heap\+Size@{x\+Port\+Get\+Free\+Heap\+Size}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{x\+Port\+Get\+Free\+Heap\+Size()}{xPortGetFreeHeapSize()}}
{\footnotesize\ttfamily size\+\_\+t x\+Port\+Get\+Free\+Heap\+Size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 140 of file heap\+\_\+1.\+c.


\begin{DoxyCode}
141 \{
142     \textcolor{keywordflow}{return} ( \hyperlink{heap__1_8c_a3e68bebe7509a99550e1358cbca8e23f}{configADJUSTED\_HEAP\_SIZE} - \hyperlink{heap__1_8c_a9f84d71523e492ed69679829b2d827c4}{xNextFreeByte} );
143 \}
\end{DoxyCode}
\mbox{\Hypertarget{portable_8h_a6195704430323f2e97ea4deab7a4eece}\label{portable_8h_a6195704430323f2e97ea4deab7a4eece}} 
\index{portable.\+h@{portable.\+h}!x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size@{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size}}
\index{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size@{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size()}{xPortGetMinimumEverFreeHeapSize()}}
{\footnotesize\ttfamily size\+\_\+t x\+Port\+Get\+Minimum\+Ever\+Free\+Heap\+Size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 317 of file heap\+\_\+4.\+c.


\begin{DoxyCode}
318 \{
319     \textcolor{keywordflow}{return} \hyperlink{heap__4_8c_ae88e8dc4d81326f752232a0a39eb119f}{xMinimumEverFreeBytesRemaining};
320 \}
\end{DoxyCode}
\mbox{\Hypertarget{portable_8h_a4f3b1bb7590996f2fa1e0456dda961ff}\label{portable_8h_a4f3b1bb7590996f2fa1e0456dda961ff}} 
\index{portable.\+h@{portable.\+h}!x\+Port\+Start\+Scheduler@{x\+Port\+Start\+Scheduler}}
\index{x\+Port\+Start\+Scheduler@{x\+Port\+Start\+Scheduler}!portable.\+h@{portable.\+h}}
\subsubsection{\texorpdfstring{x\+Port\+Start\+Scheduler()}{xPortStartScheduler()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Port\+Start\+Scheduler (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 241 of file port.\+c.


\begin{DoxyCode}
242 \{
243 \textcolor{keyword}{extern} \textcolor{keywordtype}{void} vPortStartFirstTask( \textcolor{keywordtype}{void} );
244 \textcolor{keyword}{extern} \textcolor{keywordtype}{void} *\hyperlink{tasks_8c_acdecf2afe97343aba42b111bc6df9eea}{pxCurrentTCB};
245 
246 \textcolor{preprocessor}{    #if ( configCHECK\_FOR\_STACK\_OVERFLOW > 2 )}
247     \{
248         \textcolor{comment}{/* Fill the ISR stack to make it easy to asses how much is being used. */}
249         memset( ( \textcolor{keywordtype}{void} * ) xISRStack, portISR\_STACK\_FILL\_BYTE, \textcolor{keyword}{sizeof}( xISRStack ) );
250     \}
251 \textcolor{preprocessor}{    #endif }\textcolor{comment}{/* configCHECK\_FOR\_STACK\_OVERFLOW > 2 */}\textcolor{preprocessor}{}
252 
253     \textcolor{comment}{/* Clear the software interrupt flag. */}
254     IFS0CLR = \_IFS0\_CS0IF\_MASK;
255 
256     \textcolor{comment}{/* Set software timer priority. */}
257     IPC0CLR = \_IPC0\_CS0IP\_MASK;
258     IPC0SET = ( \hyperlink{FreeRTOSConfig_8h_ac42cff506ad61d4174fa23e952e3225e}{configKERNEL\_INTERRUPT\_PRIORITY} << \_IPC0\_CS0IP\_POSITION );
259 
260     \textcolor{comment}{/* Enable software interrupt. */}
261     IEC0CLR = \_IEC0\_CS0IE\_MASK;
262     IEC0SET = 1 << \_IEC0\_CS0IE\_POSITION;
263 
264     \textcolor{comment}{/* Setup the timer to generate the tick.  Interrupts will have been}
265 \textcolor{comment}{    disabled by the time we get here. */}
266     vApplicationSetupTickTimerInterrupt();
267 
268     \textcolor{comment}{/* Kick off the highest priority task that has been created so far.}
269 \textcolor{comment}{    Its stack location is loaded into uxSavedTaskStackPointer. */}
270     \hyperlink{pic32mz_2port_8c_a835fe37fd85f12a9f0a5a7e9b3d08ab8}{uxSavedTaskStackPointer} = *( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} * ) pxCurrentTCB;
271     vPortStartFirstTask();
272 
273     \textcolor{comment}{/* Should never get here as the tasks will now be executing!  Call the task}
274 \textcolor{comment}{    exit error function to prevent compiler warnings about a static function}
275 \textcolor{comment}{    not being called in the case that the application writer overrides this}
276 \textcolor{comment}{    functionality by defining configTASK\_RETURN\_ADDRESS. */}
277     \hyperlink{pic32mx_2port_8c_a813e8227aedfc6bd83c66c4a9b8e4f41}{prvTaskExitError}();
278 
279     \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
280 \}
\end{DoxyCode}
