\hypertarget{nic_8c}{}\section{cyclone\+\_\+tcp/core/nic.c File Reference}
\label{nic_8c}\index{cyclone\+\_\+tcp/core/nic.\+c@{cyclone\+\_\+tcp/core/nic.\+c}}


Network interface controller abstraction layer.  


{\ttfamily \#include \char`\"{}core/net.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}core/nic.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}core/ethernet.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}ipv4/ipv4.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}ipv6/ipv6.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}debug.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{nic_8c_afcdf5e66fd927a7f4cc64295acd20407}{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}~\hyperlink{net__config_8h_a880f48968c7969b328d5061cd3db0f36}{N\+I\+C\+\_\+\+T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$ \hyperlink{nic_8c_a650d776d6513c3bb88671c3aedd782f0}{nic\+Get\+Logical\+Interface} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface)
\begin{DoxyCompactList}\small\item\em Retrieve logical interface. \end{DoxyCompactList}\item 
\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$ \hyperlink{nic_8c_aa8f48265895dab1633056c2dcd796355}{nic\+Get\+Physical\+Interface} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface)
\begin{DoxyCompactList}\small\item\em Retrieve physical interface. \end{DoxyCompactList}\item 
\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} \hyperlink{nic_8c_a57cef1a0e3b5314d4d0c17fdc13ce56b}{nic\+Get\+Switch\+Port} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface)
\begin{DoxyCompactList}\small\item\em Retrieve switch port identifier. \end{DoxyCompactList}\item 
\hyperlink{stdint_8h_a273cf69d639a59973b6019625df33e30}{uint16\+\_\+t} \hyperlink{nic_8c_a6c931d644f65e0d18c4d4311eaefc68e}{nic\+Get\+Vlan\+Id} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface)
\begin{DoxyCompactList}\small\item\em Retrieve V\+L\+AN identifier. \end{DoxyCompactList}\item 
\hyperlink{stdint_8h_a273cf69d639a59973b6019625df33e30}{uint16\+\_\+t} \hyperlink{nic_8c_a283192e9d12b5c863a2f5710da9fe1c8}{nic\+Get\+Vman\+Id} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface)
\begin{DoxyCompactList}\small\item\em Retrieve V\+M\+AN identifier. \end{DoxyCompactList}\item 
\hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} \hyperlink{nic_8c_afa0628577c7cf893442123f89d0ad183}{nic\+Is\+Parent\+Interface} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface, \hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$parent)
\begin{DoxyCompactList}\small\item\em Test parent/child relationship between 2 interfaces. \end{DoxyCompactList}\item 
void \hyperlink{nic_8c_aa357a772d6985d2516db87e35c39d148}{nic\+Tick} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface)
\begin{DoxyCompactList}\small\item\em Network controller timer handler. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{nic_8c_af480b2743ecb07bc0312f2bbcecdb287}{nic\+Send\+Packet} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface, const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$buffer, size\+\_\+t \hyperlink{pic32mz_2isr__support_8h_ac0542d92dfcd62c19170fd963f9e5052}{offset})
\begin{DoxyCompactList}\small\item\em Send a packet to the network controller. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{nic_8c_a9aa22ecc6ff76481bd33224fda34cb90}{nic\+Update\+Mac\+Addr\+Filter} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface)
\begin{DoxyCompactList}\small\item\em Configure M\+AC address filtering. \end{DoxyCompactList}\item 
void \hyperlink{nic_8c_a5e5ef3b84649c36ebfe1e70edb1a0f75}{nic\+Process\+Packet} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface, \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$packet, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Handle a packet received by the network controller. \end{DoxyCompactList}\item 
void \hyperlink{nic_8c_ae9054795c5d49a4db97396bf1d16b413}{nic\+Notify\+Link\+Change} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface)
\begin{DoxyCompactList}\small\item\em Process link state change notification. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t} \hyperlink{nic_8c_a1dd89f7555db6c62a9228c8a0f0c9806}{nic\+Tick\+Counter}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Network interface controller abstraction layer. 

\hypertarget{pic32mz__ef__curiosity_8h_License}{}\subsection{License}\label{pic32mz__ef__curiosity_8h_License}
S\+P\+D\+X-\/\+License-\/\+Identifier\+: G\+P\+L-\/2.\+0-\/or-\/later

Copyright (C) 2010-\/2019 Oryx Embedded S\+A\+RL. All rights reserved.

This file is part of Cyclone\+T\+CP Open.

This program is free software; you can redistribute it and/or modify it under the terms of the G\+NU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but W\+I\+T\+H\+O\+UT A\+NY W\+A\+R\+R\+A\+N\+TY; without even the implied warranty of M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY or F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE. See the G\+NU General Public License for more details.

You should have received a copy of the G\+NU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-\/1301, U\+SA.

\begin{DoxyAuthor}{Author}
Oryx Embedded S\+A\+RL (www.\+oryx-\/embedded.\+com) 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+9.\+6 
\end{DoxyVersion}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{nic_8c_afcdf5e66fd927a7f4cc64295acd20407}\label{nic_8c_afcdf5e66fd927a7f4cc64295acd20407}} 
\index{nic.\+c@{nic.\+c}!T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL@{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}}
\index{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL@{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}{TRACE\_LEVEL}}
{\footnotesize\ttfamily \#define T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL~\hyperlink{net__config_8h_a880f48968c7969b328d5061cd3db0f36}{N\+I\+C\+\_\+\+T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}}



Definition at line 32 of file nic.\+c.



\subsection{Function Documentation}
\mbox{\Hypertarget{nic_8c_a650d776d6513c3bb88671c3aedd782f0}\label{nic_8c_a650d776d6513c3bb88671c3aedd782f0}} 
\index{nic.\+c@{nic.\+c}!nic\+Get\+Logical\+Interface@{nic\+Get\+Logical\+Interface}}
\index{nic\+Get\+Logical\+Interface@{nic\+Get\+Logical\+Interface}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Get\+Logical\+Interface()}{nicGetLogicalInterface()}}
{\footnotesize\ttfamily \hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface}$\ast$ nic\+Get\+Logical\+Interface (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface }\end{DoxyParamCaption})}



Retrieve logical interface. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Pointer to the network interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the physical interface 
\end{DoxyReturn}


Definition at line 52 of file nic.\+c.


\begin{DoxyCode}
53 \{
54 \textcolor{preprocessor}{#if (ETH\_VLAN\_SUPPORT == ENABLED)}
55    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
56 
57    \textcolor{comment}{//A virtual interface can inherit from multiple parent interfaces}
58    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
59    \{
60       \textcolor{comment}{//Check whether a valid MAC address has been assigned to the interface}
61       \textcolor{keywordflow}{if}(!\hyperlink{ethernet_8h_a800d9f928930baf027e925976c44b9b2}{macCompAddr}(&interface->macAddr, &\hyperlink{ethernet_8c_a24b2ce78dd643fe028d2e18c3b503f1f}{MAC\_UNSPECIFIED\_ADDR}))
62          \textcolor{keywordflow}{break};
63 
64       \textcolor{comment}{//Last interface in the list?}
65       \textcolor{keywordflow}{if}(interface->parent == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
66          \textcolor{keywordflow}{break};
67 
68       \textcolor{comment}{//Point to the interface on top of which the virtual interface runs}
69       \textcolor{keyword}{interface }= interface->parent;
70    \}
71 \textcolor{preprocessor}{#endif}
72 
73    \textcolor{comment}{//Return a pointer to the logical interface}
74    \textcolor{keywordflow}{return} interface;
75 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_aa8f48265895dab1633056c2dcd796355}\label{nic_8c_aa8f48265895dab1633056c2dcd796355}} 
\index{nic.\+c@{nic.\+c}!nic\+Get\+Physical\+Interface@{nic\+Get\+Physical\+Interface}}
\index{nic\+Get\+Physical\+Interface@{nic\+Get\+Physical\+Interface}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Get\+Physical\+Interface()}{nicGetPhysicalInterface()}}
{\footnotesize\ttfamily \hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface}$\ast$ nic\+Get\+Physical\+Interface (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface }\end{DoxyParamCaption})}



Retrieve physical interface. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Pointer to the network interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the physical interface 
\end{DoxyReturn}


Definition at line 84 of file nic.\+c.


\begin{DoxyCode}
85 \{
86 \textcolor{preprocessor}{#if (ETH\_VIRTUAL\_IF\_SUPPORT == ENABLED || ETH\_VLAN\_SUPPORT == ENABLED || \(\backslash\)}
87 \textcolor{preprocessor}{   ETH\_PORT\_TAGGING\_SUPPORT == ENABLED)}
88    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
89 
90    \textcolor{comment}{//A virtual interface can inherit from multiple parent interfaces}
91    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
92    \{
93       \textcolor{comment}{//Physical interface?}
94       \textcolor{keywordflow}{if}(interface->nicDriver != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} || interface->parent == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
95          \textcolor{keywordflow}{break};
96 
97       \textcolor{comment}{//Point to the interface on top of which the virtual interface runs}
98       \textcolor{keyword}{interface }= interface->parent;
99    \}
100 \textcolor{preprocessor}{#endif}
101 
102    \textcolor{comment}{//Return a pointer to the physical interface}
103    \textcolor{keywordflow}{return} interface;
104 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_a57cef1a0e3b5314d4d0c17fdc13ce56b}\label{nic_8c_a57cef1a0e3b5314d4d0c17fdc13ce56b}} 
\index{nic.\+c@{nic.\+c}!nic\+Get\+Switch\+Port@{nic\+Get\+Switch\+Port}}
\index{nic\+Get\+Switch\+Port@{nic\+Get\+Switch\+Port}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Get\+Switch\+Port()}{nicGetSwitchPort()}}
{\footnotesize\ttfamily \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} nic\+Get\+Switch\+Port (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface }\end{DoxyParamCaption})}



Retrieve switch port identifier. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Pointer to the network interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Switch port identifier 
\end{DoxyReturn}


Definition at line 113 of file nic.\+c.


\begin{DoxyCode}
114 \{
115 \textcolor{preprocessor}{#if (ETH\_PORT\_TAGGING\_SUPPORT == ENABLED)}
116    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
117 
118    \textcolor{comment}{//A virtual interface can inherit from multiple parent interfaces}
119    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
120    \{
121       \textcolor{comment}{//Valid switch port identifier?}
122       \textcolor{keywordflow}{if}(interface->port != 0 || interface->parent == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
123          \textcolor{keywordflow}{break};
124 
125       \textcolor{comment}{//Point to the interface on top of which the virtual interface runs}
126       \textcolor{keyword}{interface }= interface->parent;
127    \}
128 
129    \textcolor{comment}{//Return switch port identifier}
130    \textcolor{keywordflow}{return} interface->port;
131 \textcolor{preprocessor}{#else}
132    \textcolor{comment}{//Ethernet port multiplication (VLAN or tail tagging) is not supported}
133    \textcolor{keywordflow}{return} 0;
134 \textcolor{preprocessor}{#endif}
135 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_a6c931d644f65e0d18c4d4311eaefc68e}\label{nic_8c_a6c931d644f65e0d18c4d4311eaefc68e}} 
\index{nic.\+c@{nic.\+c}!nic\+Get\+Vlan\+Id@{nic\+Get\+Vlan\+Id}}
\index{nic\+Get\+Vlan\+Id@{nic\+Get\+Vlan\+Id}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Get\+Vlan\+Id()}{nicGetVlanId()}}
{\footnotesize\ttfamily \hyperlink{stdint_8h_a273cf69d639a59973b6019625df33e30}{uint16\+\_\+t} nic\+Get\+Vlan\+Id (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface }\end{DoxyParamCaption})}



Retrieve V\+L\+AN identifier. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Pointer to the network interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
V\+L\+AN identifier 
\end{DoxyReturn}


Definition at line 144 of file nic.\+c.


\begin{DoxyCode}
145 \{
146 \textcolor{preprocessor}{#if (ETH\_VLAN\_SUPPORT == ENABLED)}
147    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
148 
149    \textcolor{comment}{//A virtual interface can inherit from multiple parent interfaces}
150    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
151    \{
152       \textcolor{comment}{//Valid VLAN identifier?}
153       \textcolor{keywordflow}{if}(interface->vlanId != 0 || interface->parent == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
154          \textcolor{keywordflow}{break};
155 
156       \textcolor{comment}{//Point to the interface on top of which the virtual interface runs}
157       \textcolor{keyword}{interface }= interface->parent;
158    \}
159 
160    \textcolor{comment}{//Return VLAN identifier}
161    \textcolor{keywordflow}{return} interface->vlanId;
162 \textcolor{preprocessor}{#else}
163    \textcolor{comment}{//VLAN is not supported}
164    \textcolor{keywordflow}{return} 0;
165 \textcolor{preprocessor}{#endif}
166 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_a283192e9d12b5c863a2f5710da9fe1c8}\label{nic_8c_a283192e9d12b5c863a2f5710da9fe1c8}} 
\index{nic.\+c@{nic.\+c}!nic\+Get\+Vman\+Id@{nic\+Get\+Vman\+Id}}
\index{nic\+Get\+Vman\+Id@{nic\+Get\+Vman\+Id}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Get\+Vman\+Id()}{nicGetVmanId()}}
{\footnotesize\ttfamily \hyperlink{stdint_8h_a273cf69d639a59973b6019625df33e30}{uint16\+\_\+t} nic\+Get\+Vman\+Id (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface }\end{DoxyParamCaption})}



Retrieve V\+M\+AN identifier. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Pointer to the network interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
V\+M\+AN identifier 
\end{DoxyReturn}


Definition at line 175 of file nic.\+c.


\begin{DoxyCode}
176 \{
177 \textcolor{preprocessor}{#if (ETH\_VMAN\_SUPPORT == ENABLED)}
178    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
179 
180    \textcolor{comment}{//A virtual interface can inherit from multiple parent interfaces}
181    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
182    \{
183       \textcolor{comment}{//Valid VMAN identifier?}
184       \textcolor{keywordflow}{if}(interface->vmanId != 0 || interface->parent == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
185          \textcolor{keywordflow}{break};
186 
187       \textcolor{comment}{//Point to the interface on top of which the virtual interface runs}
188       \textcolor{keyword}{interface }= interface->parent;
189    \}
190 
191    \textcolor{comment}{//Return VMAN identifier}
192    \textcolor{keywordflow}{return} interface->vmanId;
193 \textcolor{preprocessor}{#else}
194    \textcolor{comment}{//VMAN is not supported}
195    \textcolor{keywordflow}{return} 0;
196 \textcolor{preprocessor}{#endif}
197 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_afa0628577c7cf893442123f89d0ad183}\label{nic_8c_afa0628577c7cf893442123f89d0ad183}} 
\index{nic.\+c@{nic.\+c}!nic\+Is\+Parent\+Interface@{nic\+Is\+Parent\+Interface}}
\index{nic\+Is\+Parent\+Interface@{nic\+Is\+Parent\+Interface}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Is\+Parent\+Interface()}{nicIsParentInterface()}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} nic\+Is\+Parent\+Interface (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface,  }\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{parent }\end{DoxyParamCaption})}



Test parent/child relationship between 2 interfaces. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Pointer to the child interface \\
\hline
\mbox{\tt in}  & {\em parent} & Pointer to the parent interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
T\+R\+UE is an existing parent/child relationship is found, else F\+A\+L\+SE 
\end{DoxyReturn}


Definition at line 207 of file nic.\+c.


\begin{DoxyCode}
208 \{
209 \textcolor{preprocessor}{#if (ETH\_VIRTUAL\_IF\_SUPPORT == ENABLED || ETH\_VLAN\_SUPPORT == ENABLED || \(\backslash\)}
210 \textcolor{preprocessor}{   ETH\_PORT\_TAGGING\_SUPPORT == ENABLED)}
211    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
212    \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\_t} flag;
213 
214    \textcolor{comment}{//Iterate through the parent interfaces}
215    \textcolor{keywordflow}{for}(flag = \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}, i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
216    \{
217       \textcolor{comment}{//Any parent/child relationship?}
218       \textcolor{keywordflow}{if}(interface == parent)
219       \{
220          flag = \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
221          \textcolor{keywordflow}{break};
222       \}
223 
224       \textcolor{comment}{//Last interface in the list?}
225       \textcolor{keywordflow}{if}(interface->parent == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
226          \textcolor{keywordflow}{break};
227 
228       \textcolor{comment}{//Point to the interface on top of which the virtual interface runs}
229       \textcolor{keyword}{interface }= interface->parent;
230    \}
231 
232    \textcolor{comment}{//Return TRUE is an existing parent/child relationship is found}
233    \textcolor{keywordflow}{return} flag;
234 \textcolor{preprocessor}{#else}
235    \textcolor{comment}{//Virtual interfaces are not supported}
236    \textcolor{keywordflow}{return} (interface == parent) ? \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE} : \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
237 \textcolor{preprocessor}{#endif}
238 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_ae9054795c5d49a4db97396bf1d16b413}\label{nic_8c_ae9054795c5d49a4db97396bf1d16b413}} 
\index{nic.\+c@{nic.\+c}!nic\+Notify\+Link\+Change@{nic\+Notify\+Link\+Change}}
\index{nic\+Notify\+Link\+Change@{nic\+Notify\+Link\+Change}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Notify\+Link\+Change()}{nicNotifyLinkChange()}}
{\footnotesize\ttfamily void nic\+Notify\+Link\+Change (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface }\end{DoxyParamCaption})}



Process link state change notification. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Underlying network interface \\
\hline
\end{DoxyParams}


Definition at line 525 of file nic.\+c.


\begin{DoxyCode}
526 \{
527    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
528    \hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{NetInterface} *physicalInterface;
529    \hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{NetInterface} *virtualInterface;
530 
531    \textcolor{comment}{//Point to the physical interface}
532    physicalInterface = \hyperlink{nic_8c_aa8f48265895dab1633056c2dcd796355}{nicGetPhysicalInterface}(interface);
533 
534    \textcolor{comment}{//Re-enable interrupts if necessary}
535    \textcolor{keywordflow}{if}(physicalInterface->configured)
536    \{
537       physicalInterface->nicDriver->enableIrq(physicalInterface);
538    \}
539 
540    \textcolor{comment}{//Loop through network interfaces}
541    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
542    \{
543       \textcolor{comment}{//Point to the current interface}
544       virtualInterface = &\hyperlink{net_8c_a7ecafab0039ec54d1d7a1e9e7402379b}{netInterface}[i];
545 
546       \textcolor{comment}{//Check whether the current virtual interface is attached to the physical}
547       \textcolor{comment}{//interface}
548       \textcolor{keywordflow}{if}(\hyperlink{nic_8c_afa0628577c7cf893442123f89d0ad183}{nicIsParentInterface}(virtualInterface, interface) &&
549          \hyperlink{nic_8c_a57cef1a0e3b5314d4d0c17fdc13ce56b}{nicGetSwitchPort}(virtualInterface) == \hyperlink{nic_8c_a57cef1a0e3b5314d4d0c17fdc13ce56b}{nicGetSwitchPort}(interface))
550       \{
551          \textcolor{comment}{//Set operation mode}
552          virtualInterface->linkSpeed = interface->linkSpeed;
553          virtualInterface->duplexMode = interface->duplexMode;
554 
555          \textcolor{comment}{//Update link state}
556          virtualInterface->linkState = interface->linkState;
557 
558          \textcolor{comment}{//Process link state change event}
559          \hyperlink{net_8c_a640aeb84055d730ae11aaa7aaab61d8e}{netProcessLinkChange}(virtualInterface);
560       \}
561    \}
562 
563    \textcolor{comment}{//Disable interrupts}
564    physicalInterface->nicDriver->disableIrq(physicalInterface);
565 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_a5e5ef3b84649c36ebfe1e70edb1a0f75}\label{nic_8c_a5e5ef3b84649c36ebfe1e70edb1a0f75}} 
\index{nic.\+c@{nic.\+c}!nic\+Process\+Packet@{nic\+Process\+Packet}}
\index{nic\+Process\+Packet@{nic\+Process\+Packet}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Process\+Packet()}{nicProcessPacket()}}
{\footnotesize\ttfamily void nic\+Process\+Packet (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface,  }\item[{\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$}]{packet,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Handle a packet received by the network controller. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Underlying network interface \\
\hline
\mbox{\tt in}  & {\em packet} & Incoming packet to process \\
\hline
\mbox{\tt in}  & {\em length} & Total packet length \\
\hline
\end{DoxyParams}


Definition at line 383 of file nic.\+c.


\begin{DoxyCode}
384 \{
385    \hyperlink{nic_8h_ac1ce8659a9797513ecd9cc1afedce40b}{NicType} \hyperlink{resource__manager_8h_a12e46a33bfe90638e58ef067c6fd4a6e}{type};
386 
387    \textcolor{comment}{//Check whether the interface is enabled for operation}
388    \textcolor{keywordflow}{if}(interface->configured)
389    \{
390       \textcolor{comment}{//Re-enable interrupts}
391       interface->nicDriver->enableIrq(interface);
392 
393       \textcolor{comment}{//Debug message}
394       \hyperlink{debug_8h_a67a8f9bc74358aa21745a76e23768dae}{TRACE\_DEBUG}(\textcolor{stringliteral}{"Packet received (%"} \hyperlink{compiler__port_8h_a2b7b0557dc6cd786df02dafbb51f5292}{PRIuSIZE} \textcolor{stringliteral}{" bytes)...\(\backslash\)r\(\backslash\)n"}, 
      \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
395       \hyperlink{debug_8h_a1f71019169d85407d8827300ed43bdf0}{TRACE\_DEBUG\_ARRAY}(\textcolor{stringliteral}{"  "}, packet, \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
396 
397       \textcolor{comment}{//Retrieve network interface type}
398       type = interface->nicDriver->type;
399 
400 \textcolor{preprocessor}{#if (ETH\_SUPPORT == ENABLED)}
401       \textcolor{comment}{//Ethernet interface?}
402       \textcolor{keywordflow}{if}(type == \hyperlink{nic_8h_ac1ce8659a9797513ecd9cc1afedce40ba84802cab6ee937691c3d76122ffaffcd}{NIC\_TYPE\_ETHERNET})
403       \{
404          \textcolor{comment}{//Process incoming Ethernet frame}
405          \hyperlink{ethernet_8c_a8a0785e8ca268a2c93145d32eac66757}{ethProcessFrame}(interface, packet, \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
406       \}
407       \textcolor{keywordflow}{else}
408 \textcolor{preprocessor}{#endif}
409 \textcolor{preprocessor}{#if (PPP\_SUPPORT == ENABLED)}
410       \textcolor{comment}{//PPP interface?}
411       \textcolor{keywordflow}{if}(type == \hyperlink{nic_8h_ac1ce8659a9797513ecd9cc1afedce40bafe21fcd3851e27a8b4ac8f6ea0a692df}{NIC\_TYPE\_PPP})
412       \{
413          \textcolor{comment}{//Process incoming PPP frame}
414          \hyperlink{ppp_8c_acf85af1268ca737c3e4b07d39befa40c}{pppProcessFrame}(interface, packet, \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
415       \}
416       \textcolor{keywordflow}{else}
417 \textcolor{preprocessor}{#endif}
418 \textcolor{preprocessor}{#if (IPV6\_SUPPORT == ENABLED)}
419       \textcolor{comment}{//6LoWPAN interface?}
420       \textcolor{keywordflow}{if}(type == \hyperlink{nic_8h_ac1ce8659a9797513ecd9cc1afedce40ba5b85ff07103ab20b9b081b4b263619ea}{NIC\_TYPE\_6LOWPAN})
421       \{
422          \hyperlink{structNetBuffer1}{NetBuffer1} buffer;
423 
424          \textcolor{comment}{//The incoming packet fits in a single chunk}
425          buffer.\hyperlink{structNetBuffer1_a05cff68539009da3dd878a7b7d38e1e6}{chunkCount} = 1;
426          buffer.\hyperlink{structNetBuffer1_a17baf9f6d2d0ea0520a6ee1b00e954de}{maxChunkCount} = 1;
427          buffer.\hyperlink{structNetBuffer1_a2450ee8ad02374a831693b3529283739}{chunk}[0].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} = packet;
428          buffer.\hyperlink{structNetBuffer1_a2450ee8ad02374a831693b3529283739}{chunk}[0].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = (\hyperlink{stdint_8h_a273cf69d639a59973b6019625df33e30}{uint16\_t}) \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
429          buffer.\hyperlink{structNetBuffer1_a2450ee8ad02374a831693b3529283739}{chunk}[0].\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} = 0;
430 
431          \textcolor{comment}{//Process incoming IPv6 packet}
432          \hyperlink{ipv6_8c_ae5a231be5cc78f474ac7fb73df8947bd}{ipv6ProcessPacket}(interface, (\hyperlink{structNetBuffer}{NetBuffer} *) &buffer, 0);
433       \}
434       \textcolor{keywordflow}{else}
435 \textcolor{preprocessor}{#endif}
436 \textcolor{preprocessor}{#if (NET\_LOOPBACK\_IF\_SUPPORT == ENABLED)}
437       \textcolor{comment}{//Loopback interface?}
438       \textcolor{keywordflow}{if}(type == \hyperlink{nic_8h_ac1ce8659a9797513ecd9cc1afedce40ba562c14f927fc4795741eb23aee4e4598}{NIC\_TYPE\_LOOPBACK})
439       \{
440 \textcolor{preprocessor}{#if (IPV4\_SUPPORT == ENABLED)}
441          \textcolor{comment}{//IPv4 packet received?}
442          \textcolor{keywordflow}{if}(\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} >= \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a294daf3717d3c22ffb24cbd3485ddbfc}{Ipv4Header}) && (packet[0] >> 4) == 4)
443          \{
444             \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\_t} error;
445             \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
446             \hyperlink{ipv4_8h_a294daf3717d3c22ffb24cbd3485ddbfc}{Ipv4Header} *header;
447 
448             \textcolor{comment}{//Point to the IPv4 header}
449             header = (\hyperlink{ipv4_8h_a294daf3717d3c22ffb24cbd3485ddbfc}{Ipv4Header} *) packet;
450 
451             \textcolor{comment}{//Loop through network interfaces}
452             \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
453             \{
454                \textcolor{comment}{//Check destination address}
455                error = \hyperlink{ipv4__misc_8c_aeed51fbc5f6dedba3c539939c1997a8d}{ipv4CheckDestAddr}(&\hyperlink{net_8c_a7ecafab0039ec54d1d7a1e9e7402379b}{netInterface}[i], header->destAddr);
456 
457                \textcolor{comment}{//Valid destination address?}
458                \textcolor{keywordflow}{if}(!error)
459                \{
460                   \textcolor{comment}{//Process incoming IPv4 packet}
461                   \hyperlink{ipv4_8c_a56bd5279686b3415f88d758b6a548978}{ipv4ProcessPacket}(&\hyperlink{net_8c_a7ecafab0039ec54d1d7a1e9e7402379b}{netInterface}[i], (
      \hyperlink{ipv4_8h_a294daf3717d3c22ffb24cbd3485ddbfc}{Ipv4Header} *) packet,
462                      \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
463                \}
464             \}
465          \}
466          \textcolor{keywordflow}{else}
467 \textcolor{preprocessor}{#endif}
468 \textcolor{preprocessor}{#if (IPV6\_SUPPORT == ENABLED)}
469          \textcolor{comment}{//IPv6 packet received?}
470          \textcolor{keywordflow}{if}(\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} >= \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_ad553284c12e3a0d96dc8a4da1c5f6ea0}{Ipv6Header}) && (packet[0] >> 4) == 6)
471          \{
472             \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\_t} error;
473             \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
474             \hyperlink{structNetBuffer1}{NetBuffer1} buffer;
475             \hyperlink{ipv6_8h_ad553284c12e3a0d96dc8a4da1c5f6ea0}{Ipv6Header} *header;
476 
477             \textcolor{comment}{//Point to the IPv6 header}
478             header = (\hyperlink{ipv6_8h_ad553284c12e3a0d96dc8a4da1c5f6ea0}{Ipv6Header} *) packet;
479 
480             \textcolor{comment}{//Loop through network interfaces}
481             \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net_8h_a116f850ebcb023ffa3e6b8de10c5cb35}{NET\_INTERFACE\_COUNT}; i++)
482             \{
483                \textcolor{comment}{//Check destination address}
484                error = \hyperlink{ipv6__misc_8c_acf063c0c23ac317d11b9973f3e05e1ac}{ipv6CheckDestAddr}(&\hyperlink{net_8c_a7ecafab0039ec54d1d7a1e9e7402379b}{netInterface}[i], &header->destAddr);
485 
486                \textcolor{comment}{//Valid destination address?}
487                \textcolor{keywordflow}{if}(!error)
488                \{
489                   \textcolor{comment}{//The incoming packet fits in a single chunk}
490                   buffer.\hyperlink{structNetBuffer1_a05cff68539009da3dd878a7b7d38e1e6}{chunkCount} = 1;
491                   buffer.\hyperlink{structNetBuffer1_a17baf9f6d2d0ea0520a6ee1b00e954de}{maxChunkCount} = 1;
492                   buffer.\hyperlink{structNetBuffer1_a2450ee8ad02374a831693b3529283739}{chunk}[0].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} = packet;
493                   buffer.\hyperlink{structNetBuffer1_a2450ee8ad02374a831693b3529283739}{chunk}[0].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = (\hyperlink{stdint_8h_a273cf69d639a59973b6019625df33e30}{uint16\_t}) \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
494                   buffer.\hyperlink{structNetBuffer1_a2450ee8ad02374a831693b3529283739}{chunk}[0].\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} = 0;
495 
496                   \textcolor{comment}{//Process incoming IPv6 packet}
497                   \hyperlink{ipv6_8c_ae5a231be5cc78f474ac7fb73df8947bd}{ipv6ProcessPacket}(&\hyperlink{net_8c_a7ecafab0039ec54d1d7a1e9e7402379b}{netInterface}[i], (
      \hyperlink{structNetBuffer}{NetBuffer} *) &buffer, 0);
498                \}
499             \}
500          \}
501          \textcolor{keywordflow}{else}
502 \textcolor{preprocessor}{#endif}
503          \{
504             \textcolor{comment}{//Invalid version number}
505          \}
506       \}
507       \textcolor{keywordflow}{else}
508 \textcolor{preprocessor}{#endif}
509       \textcolor{comment}{//Unknown interface type?}
510       \{
511          \textcolor{comment}{//Silently discard the received packet}
512       \}
513 
514       \textcolor{comment}{//Disable interrupts}
515       interface->nicDriver->disableIrq(interface);
516    \}
517 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_af480b2743ecb07bc0312f2bbcecdb287}\label{nic_8c_af480b2743ecb07bc0312f2bbcecdb287}} 
\index{nic.\+c@{nic.\+c}!nic\+Send\+Packet@{nic\+Send\+Packet}}
\index{nic\+Send\+Packet@{nic\+Send\+Packet}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Send\+Packet()}{nicSendPacket()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} nic\+Send\+Packet (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface,  }\item[{const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{buffer,  }\item[{size\+\_\+t}]{offset }\end{DoxyParamCaption})}



Send a packet to the network controller. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Underlying network interface \\
\hline
\mbox{\tt in}  & {\em buffer} & Multi-\/part buffer containing the data to send \\
\hline
\mbox{\tt in}  & {\em offset} & Offset to the first data byte \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 278 of file nic.\+c.


\begin{DoxyCode}
280 \{
281    \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\_t} error;
282    \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\_t} status;
283 
284 \textcolor{preprocessor}{#if (TRACE\_LEVEL >= TRACE\_LEVEL\_DEBUG)}
285    \textcolor{comment}{//Retrieve the length of the packet}
286    \textcolor{keywordtype}{size\_t} \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} = \hyperlink{net__mem_8c_ac9dbcd9e28e61d8f4f6d2e9af2607b68}{netBufferGetLength}(buffer) - \hyperlink{pic32mz_2isr__support_8h_a12a5aed8a193ebbf9a641104a310610d}{offset};
287 
288    \textcolor{comment}{//Debug message}
289    \hyperlink{debug_8h_a67a8f9bc74358aa21745a76e23768dae}{TRACE\_DEBUG}(\textcolor{stringliteral}{"Sending packet (%"} \hyperlink{compiler__port_8h_a2b7b0557dc6cd786df02dafbb51f5292}{PRIuSIZE} \textcolor{stringliteral}{" bytes)...\(\backslash\)r\(\backslash\)n"}, length);
290    \hyperlink{debug_8h_a5fb2ec20bc5626d859c3c51db0d2ea88}{TRACE\_DEBUG\_NET\_BUFFER}(\textcolor{stringliteral}{"  "}, buffer, \hyperlink{pic32mz_2isr__support_8h_a12a5aed8a193ebbf9a641104a310610d}{offset}, length);
291 \textcolor{preprocessor}{#endif}
292 
293    \textcolor{comment}{//Check whether the interface is enabled for operation}
294    \textcolor{keywordflow}{if}(interface->configured && interface->nicDriver != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
295    \{
296       \textcolor{comment}{//Loopback interface?}
297       \textcolor{keywordflow}{if}(interface->nicDriver->type == \hyperlink{nic_8h_ac1ce8659a9797513ecd9cc1afedce40ba562c14f927fc4795741eb23aee4e4598}{NIC\_TYPE\_LOOPBACK})
298       \{
299          \textcolor{comment}{//The loopback interface is always available}
300          status = \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
301       \}
302       \textcolor{keywordflow}{else}
303       \{
304          \textcolor{comment}{//Wait for the transmitter to be ready to send}
305          status = \hyperlink{os__port__chibios_8c_a1dc707247e44dfefae5bec4a322fc78a}{osWaitForEvent}(&interface->nicTxEvent, 
      \hyperlink{nic_8h_a519984a512a8f611d1a1d86750b25a1e}{NIC\_MAX\_BLOCKING\_TIME});
306       \}
307 
308       \textcolor{comment}{//Check whether the specified event is in signaled state}
309       \textcolor{keywordflow}{if}(status)
310       \{
311          \textcolor{comment}{//Disable interrupts}
312          interface->nicDriver->disableIrq(interface);
313 
314          \textcolor{comment}{//Send Ethernet frame}
315          error = interface->nicDriver->sendPacket(interface, buffer, \hyperlink{pic32mz_2isr__support_8h_a12a5aed8a193ebbf9a641104a310610d}{offset});
316 
317          \textcolor{comment}{//Re-enable interrupts if necessary}
318          \textcolor{keywordflow}{if}(interface->configured)
319          \{
320             interface->nicDriver->enableIrq(interface);
321          \}
322       \}
323       \textcolor{keywordflow}{else}
324       \{
325          \textcolor{comment}{//The transmitter is busy}
326          error = \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689caa336c55211847e9cc11a4e95e7479a1c}{ERROR\_TRANSMITTER\_BUSY};
327       \}
328    \}
329    \textcolor{keywordflow}{else}
330    \{
331       \textcolor{comment}{//Report an error}
332       error = \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689ca18648c6804c77e30234b0e60e646718b}{ERROR\_INVALID\_INTERFACE};
333    \}
334 
335    \textcolor{comment}{//Return status code}
336    \textcolor{keywordflow}{return} error;
337 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_aa357a772d6985d2516db87e35c39d148}\label{nic_8c_aa357a772d6985d2516db87e35c39d148}} 
\index{nic.\+c@{nic.\+c}!nic\+Tick@{nic\+Tick}}
\index{nic\+Tick@{nic\+Tick}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Tick()}{nicTick()}}
{\footnotesize\ttfamily void nic\+Tick (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface }\end{DoxyParamCaption})}



Network controller timer handler. 

This routine is periodically called by the T\+C\+P/\+IP stack to handle periodic operations such as polling the link state


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Underlying network interface \\
\hline
\end{DoxyParams}


Definition at line 250 of file nic.\+c.


\begin{DoxyCode}
251 \{
252    \textcolor{comment}{//Valid NIC driver?}
253    \textcolor{keywordflow}{if}(interface->nicDriver != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
254    \{
255       \textcolor{comment}{//Disable interrupts}
256       interface->nicDriver->disableIrq(interface);
257 
258       \textcolor{comment}{//Handle periodic operations}
259       interface->nicDriver->tick(interface);
260 
261       \textcolor{comment}{//Re-enable interrupts if necessary}
262       \textcolor{keywordflow}{if}(interface->configured)
263       \{
264          interface->nicDriver->enableIrq(interface);
265       \}
266    \}
267 \}
\end{DoxyCode}
\mbox{\Hypertarget{nic_8c_a9aa22ecc6ff76481bd33224fda34cb90}\label{nic_8c_a9aa22ecc6ff76481bd33224fda34cb90}} 
\index{nic.\+c@{nic.\+c}!nic\+Update\+Mac\+Addr\+Filter@{nic\+Update\+Mac\+Addr\+Filter}}
\index{nic\+Update\+Mac\+Addr\+Filter@{nic\+Update\+Mac\+Addr\+Filter}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Update\+Mac\+Addr\+Filter()}{nicUpdateMacAddrFilter()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} nic\+Update\+Mac\+Addr\+Filter (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface }\end{DoxyParamCaption})}



Configure M\+AC address filtering. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Underlying network interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 346 of file nic.\+c.


\begin{DoxyCode}
347 \{
348    \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\_t} error;
349 
350    \textcolor{comment}{//Valid NIC driver?}
351    \textcolor{keywordflow}{if}(interface->nicDriver != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
352    \{
353       \textcolor{comment}{//Disable interrupts}
354       interface->nicDriver->disableIrq(interface);
355 
356       \textcolor{comment}{//Update MAC filter table}
357       error = interface->nicDriver->updateMacAddrFilter(interface);
358 
359       \textcolor{comment}{//Re-enable interrupts if necessary}
360       \textcolor{keywordflow}{if}(interface->configured)
361       \{
362          interface->nicDriver->enableIrq(interface);
363       \}
364    \}
365    \textcolor{keywordflow}{else}
366    \{
367       \textcolor{comment}{//Report an error}
368       error = \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689ca18648c6804c77e30234b0e60e646718b}{ERROR\_INVALID\_INTERFACE};
369    \}
370 
371    \textcolor{comment}{//Return status code}
372    \textcolor{keywordflow}{return} error;
373 \}
\end{DoxyCode}


\subsection{Variable Documentation}
\mbox{\Hypertarget{nic_8c_a1dd89f7555db6c62a9228c8a0f0c9806}\label{nic_8c_a1dd89f7555db6c62a9228c8a0f0c9806}} 
\index{nic.\+c@{nic.\+c}!nic\+Tick\+Counter@{nic\+Tick\+Counter}}
\index{nic\+Tick\+Counter@{nic\+Tick\+Counter}!nic.\+c@{nic.\+c}}
\subsubsection{\texorpdfstring{nic\+Tick\+Counter}{nicTickCounter}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_ae3e32a98d431a02106616da3071832dd}{systime\+\_\+t} nic\+Tick\+Counter}



Definition at line 43 of file nic.\+c.

