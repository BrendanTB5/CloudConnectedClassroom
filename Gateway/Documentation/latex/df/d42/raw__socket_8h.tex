\hypertarget{raw__socket_8h}{}\section{cyclone\+\_\+tcp/core/raw\+\_\+socket.h File Reference}
\label{raw__socket_8h}\index{cyclone\+\_\+tcp/core/raw\+\_\+socket.\+h@{cyclone\+\_\+tcp/core/raw\+\_\+socket.\+h}}


T\+C\+P/\+IP raw sockets.  


{\ttfamily \#include \char`\"{}core/net.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}core/ip.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}core/socket.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{raw__socket_8h_aeebc36a89d2911a4b0a40b4ea0d8a0f7}{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+S\+U\+P\+P\+O\+RT}~\hyperlink{os__port_8h_abd5c8ab57c190a6522ccdbf0ed7577da}{D\+I\+S\+A\+B\+L\+ED}
\item 
\#define \hyperlink{raw__socket_8h_a1a47fb68e2fe9b4282dd3945fba8bfbb}{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+R\+X\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE}~4
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{raw__socket_8h_a2c4a6c90ef9d2bf9d2c98b305d421401}{raw\+Socket\+Process\+Ip\+Packet} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface, \hyperlink{structIpPseudoHeader}{Ip\+Pseudo\+Header} $\ast$pseudo\+Header, const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$buffer, size\+\_\+t \hyperlink{pic32mz_2isr__support_8h_ac0542d92dfcd62c19170fd963f9e5052}{offset})
\begin{DoxyCompactList}\small\item\em Process incoming IP packet. \end{DoxyCompactList}\item 
void \hyperlink{raw__socket_8h_a2ee1d9d86cdd10807baa8ea962fb40c3}{raw\+Socket\+Process\+Eth\+Packet} (\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$interface, \hyperlink{ethernet_8h_a431dfb940d831c1426e2f13891116519}{Eth\+Header} $\ast$header, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$\hyperlink{tftp__common_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Process incoming Ethernet packet. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{raw__socket_8h_a97dedb8c93bbc612d09563f523140a9c}{raw\+Socket\+Send\+Ip\+Packet} (\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$\hyperlink{bsd__socket_8h_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}, const \hyperlink{structIpAddr}{Ip\+Addr} $\ast$\hyperlink{ipcp_8h_a752e1719cf65f78dfec6274352cb56df}{dest\+Ip\+Addr}, const void $\ast$\hyperlink{tftp__common_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length}, size\+\_\+t $\ast$written, \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} \hyperlink{nbns__common_8h_a1e87af3c18a2fd36c61faf89949bdc3f}{flags})
\begin{DoxyCompactList}\small\item\em Send an raw IP packet. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{raw__socket_8h_a9999b3d59ed200a7a72114da765f1577}{raw\+Socket\+Send\+Eth\+Packet} (\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$\hyperlink{bsd__socket_8h_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}, const void $\ast$\hyperlink{tftp__common_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length}, size\+\_\+t $\ast$written)
\begin{DoxyCompactList}\small\item\em Send an raw Ethernet packet. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{raw__socket_8h_a3a4847947846250d316321659feb0e52}{raw\+Socket\+Receive\+Ip\+Packet} (\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$\hyperlink{bsd__socket_8h_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}, \hyperlink{structIpAddr}{Ip\+Addr} $\ast$\hyperlink{ipcp_8h_a8ddffb4d02fcd8ad856313d3e208c34f}{src\+Ip\+Addr}, \hyperlink{structIpAddr}{Ip\+Addr} $\ast$\hyperlink{ipcp_8h_a752e1719cf65f78dfec6274352cb56df}{dest\+Ip\+Addr}, void $\ast$\hyperlink{tftp__common_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, size\+\_\+t size, size\+\_\+t $\ast$received, \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} \hyperlink{nbns__common_8h_a1e87af3c18a2fd36c61faf89949bdc3f}{flags})
\begin{DoxyCompactList}\small\item\em Receive an IP packet from a raw socket. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{raw__socket_8h_a464cbc1f822724be352807f23357b762}{raw\+Socket\+Receive\+Eth\+Packet} (\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$\hyperlink{bsd__socket_8h_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}, void $\ast$\hyperlink{tftp__common_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, size\+\_\+t size, size\+\_\+t $\ast$received, \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} \hyperlink{nbns__common_8h_a1e87af3c18a2fd36c61faf89949bdc3f}{flags})
\begin{DoxyCompactList}\small\item\em Receive an Ethernet packet from a raw socket. \end{DoxyCompactList}\item 
void \hyperlink{raw__socket_8h_ad2549c2b0b0ee5cdab3fb45dbb5770d4}{raw\+Socket\+Update\+Events} (\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$\hyperlink{bsd__socket_8h_a3f8f3a2707fbc87fc30aa70f31f53218}{socket})
\begin{DoxyCompactList}\small\item\em Update event state for raw sockets. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
T\+C\+P/\+IP raw sockets. 

\hypertarget{pic32mz__ef__curiosity_8h_License}{}\subsection{License}\label{pic32mz__ef__curiosity_8h_License}
S\+P\+D\+X-\/\+License-\/\+Identifier\+: G\+P\+L-\/2.\+0-\/or-\/later

Copyright (C) 2010-\/2019 Oryx Embedded S\+A\+RL. All rights reserved.

This file is part of Cyclone\+T\+CP Open.

This program is free software; you can redistribute it and/or modify it under the terms of the G\+NU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but W\+I\+T\+H\+O\+UT A\+NY W\+A\+R\+R\+A\+N\+TY; without even the implied warranty of M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY or F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE. See the G\+NU General Public License for more details.

You should have received a copy of the G\+NU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-\/1301, U\+SA.

\begin{DoxyAuthor}{Author}
Oryx Embedded S\+A\+RL (www.\+oryx-\/embedded.\+com) 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+9.\+6 
\end{DoxyVersion}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{raw__socket_8h_a1a47fb68e2fe9b4282dd3945fba8bfbb}\label{raw__socket_8h_a1a47fb68e2fe9b4282dd3945fba8bfbb}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+R\+X\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE@{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+R\+X\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE}}
\index{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+R\+X\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE@{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+R\+X\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+R\+X\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE}{RAW\_SOCKET\_RX\_QUEUE\_SIZE}}
{\footnotesize\ttfamily \#define R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+R\+X\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE~4}



Definition at line 48 of file raw\+\_\+socket.\+h.

\mbox{\Hypertarget{raw__socket_8h_aeebc36a89d2911a4b0a40b4ea0d8a0f7}\label{raw__socket_8h_aeebc36a89d2911a4b0a40b4ea0d8a0f7}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+S\+U\+P\+P\+O\+RT@{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+S\+U\+P\+P\+O\+RT}}
\index{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+S\+U\+P\+P\+O\+RT@{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+S\+U\+P\+P\+O\+RT}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+S\+U\+P\+P\+O\+RT}{RAW\_SOCKET\_SUPPORT}}
{\footnotesize\ttfamily \#define R\+A\+W\+\_\+\+S\+O\+C\+K\+E\+T\+\_\+\+S\+U\+P\+P\+O\+RT~\hyperlink{os__port_8h_abd5c8ab57c190a6522ccdbf0ed7577da}{D\+I\+S\+A\+B\+L\+ED}}



Definition at line 41 of file raw\+\_\+socket.\+h.



\subsection{Function Documentation}
\mbox{\Hypertarget{raw__socket_8h_a2ee1d9d86cdd10807baa8ea962fb40c3}\label{raw__socket_8h_a2ee1d9d86cdd10807baa8ea962fb40c3}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!raw\+Socket\+Process\+Eth\+Packet@{raw\+Socket\+Process\+Eth\+Packet}}
\index{raw\+Socket\+Process\+Eth\+Packet@{raw\+Socket\+Process\+Eth\+Packet}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{raw\+Socket\+Process\+Eth\+Packet()}{rawSocketProcessEthPacket()}}
{\footnotesize\ttfamily void raw\+Socket\+Process\+Eth\+Packet (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface,  }\item[{\hyperlink{ethernet_8h_a431dfb940d831c1426e2f13891116519}{Eth\+Header} $\ast$}]{header,  }\item[{const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$}]{data,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Process incoming Ethernet packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Underlying network interface \\
\hline
\mbox{\tt in}  & {\em header} & Pointer to the Ethernet header \\
\hline
\mbox{\tt in}  & {\em data} & Pointer to the payload data \\
\hline
\mbox{\tt in}  & {\em length} & Length of the payload data, in bytes \\
\hline
\end{DoxyParams}


Definition at line 274 of file raw\+\_\+socket.\+c.


\begin{DoxyCode}
276 \{
277    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
278    \hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} *\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket};
279    \hyperlink{struct__SocketQueueItem}{SocketQueueItem} *queueItem;
280    \hyperlink{structNetBuffer}{NetBuffer} *\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
281 
282    \textcolor{comment}{//Loop through opened sockets}
283    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{socket_8h_ab793a8c76592a00fa3ea0510cd2ffe3a}{SOCKET\_MAX\_COUNT}; i++)
284    \{
285       \textcolor{comment}{//Point to the current socket}
286       socket = \hyperlink{socket_8c_acdd76d8e01b4715c774c404b10f958da}{socketTable} + i;
287 
288       \textcolor{comment}{//Raw socket found?}
289       \textcolor{keywordflow}{if}(socket->type != \hyperlink{socket_8h_aa78c7398fa81f7f62aa233159d4d8d97a4cdd66d5c35beeed721c6b43a779315c}{SOCKET\_TYPE\_RAW\_ETH})
290          \textcolor{keywordflow}{continue};
291       \textcolor{comment}{//Check whether the socket is bound to a particular interface}
292       \textcolor{keywordflow}{if}(socket->interface && socket->interface != interface)
293          \textcolor{keywordflow}{continue};
294 
295       \textcolor{comment}{//Check protocol field}
296       \textcolor{keywordflow}{if}(socket->protocol == \hyperlink{socket_8h_a13a758cbaa024df59cfcce2897ecd471a2a1b42dc97939ea1c665b9bbe9971668}{SOCKET\_ETH\_PROTO\_ALL})
297       \{
298          \textcolor{comment}{//Accept all EtherType values}
299       \}
300       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(socket->protocol == \hyperlink{socket_8h_a13a758cbaa024df59cfcce2897ecd471a8d42013404df6a17f27a89e3b73fb3b1}{SOCKET\_ETH\_PROTO\_LLC})
301       \{
302          \textcolor{comment}{//Only accept LLC frames}
303          \textcolor{keywordflow}{if}(\hyperlink{cpu__endian_8h_a9312c6eb72e64f748ae0d0e0dc3ec9b9}{ntohs}(header->type) > \hyperlink{ethernet_8h_a6f29d2b24a262d91b7158713728d45f2}{ETH\_MTU})
304             \textcolor{keywordflow}{continue};
305       \}
306       \textcolor{keywordflow}{else}
307       \{
308          \textcolor{comment}{//Only accept frames with the correct EtherType value}
309          \textcolor{keywordflow}{if}(\hyperlink{cpu__endian_8h_a9312c6eb72e64f748ae0d0e0dc3ec9b9}{ntohs}(header->type) != socket->protocol)
310             \textcolor{keywordflow}{continue};
311       \}
312 
313       \textcolor{comment}{//The current socket meets all the criteria}
314       \textcolor{keywordflow}{break};
315    \}
316 
317    \textcolor{comment}{//Drop incoming packet if no matching socket was found}
318    \textcolor{keywordflow}{if}(i >= SOCKET\_MAX\_COUNT)
319       \textcolor{keywordflow}{return};
320 
321    \textcolor{comment}{//Empty receive queue?}
322    \textcolor{keywordflow}{if}(!socket->receiveQueue)
323    \{
324       \textcolor{comment}{//Allocate a memory buffer to hold the data and the associated descriptor}
325       p = \hyperlink{net__mem_8c_a986c9991e530e99528faa4c43efadc6f}{netBufferAlloc}(\textcolor{keyword}{sizeof}(\hyperlink{struct__SocketQueueItem}{SocketQueueItem}) + \textcolor{keyword}{sizeof}(
      \hyperlink{ethernet_8h_a431dfb940d831c1426e2f13891116519}{EthHeader}) + \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
326 
327       \textcolor{comment}{//Successful memory allocation?}
328       \textcolor{keywordflow}{if}(p != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
329       \{
330          \textcolor{comment}{//Point to the newly created item}
331          queueItem = \hyperlink{net__mem_8c_a20d30c9db547b3b2743368b589cf482b}{netBufferAt}(p, 0);
332          queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer} = \hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
333          \textcolor{comment}{//Add the newly created item to the queue}
334          socket->receiveQueue = queueItem;
335       \}
336       \textcolor{keywordflow}{else}
337       \{
338          \textcolor{comment}{//Memory allocation failed}
339          queueItem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
340       \}
341    \}
342    \textcolor{keywordflow}{else}
343    \{
344       \textcolor{comment}{//Point to the very first item}
345       queueItem = socket->receiveQueue;
346       \textcolor{comment}{//Reach the last item in the receive queue}
347       \textcolor{keywordflow}{for}(i = 1; queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next}; i++)
348          queueItem = queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next};
349 
350       \textcolor{comment}{//Make sure the receive queue is not full}
351       \textcolor{keywordflow}{if}(i >= \hyperlink{raw__socket_8h_a1a47fb68e2fe9b4282dd3945fba8bfbb}{RAW\_SOCKET\_RX\_QUEUE\_SIZE})
352          \textcolor{keywordflow}{return};
353 
354       \textcolor{comment}{//Allocate a memory buffer to hold the data and the associated descriptor}
355       p = \hyperlink{net__mem_8c_a986c9991e530e99528faa4c43efadc6f}{netBufferAlloc}(\textcolor{keyword}{sizeof}(\hyperlink{struct__SocketQueueItem}{SocketQueueItem}) + \textcolor{keyword}{sizeof}(
      \hyperlink{ethernet_8h_a431dfb940d831c1426e2f13891116519}{EthHeader}) + \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
356 
357       \textcolor{comment}{//Successful memory allocation?}
358       \textcolor{keywordflow}{if}(p != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
359       \{
360          \textcolor{comment}{//Add the newly created item to the queue}
361          queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next} = \hyperlink{net__mem_8c_a20d30c9db547b3b2743368b589cf482b}{netBufferAt}(p, 0);
362          \textcolor{comment}{//Point to the newly created item}
363          queueItem = queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next};
364          queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer} = \hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
365       \}
366       \textcolor{keywordflow}{else}
367       \{
368          \textcolor{comment}{//Memory allocation failed}
369          queueItem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
370       \}
371    \}
372 
373    \textcolor{comment}{//Failed to allocate memory?}
374    \textcolor{keywordflow}{if}(queueItem == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
375       \textcolor{keywordflow}{return};
376 
377    \textcolor{comment}{//Initialize next field}
378    queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
379    \textcolor{comment}{//Other fields are meaningless}
380    queueItem->\hyperlink{struct__SocketQueueItem_aae5da9b297543edc1b28914115ee928b}{srcPort} = 0;
381    queueItem->\hyperlink{struct__SocketQueueItem_a35f1157ded7017ef108d8875d2cedfa7}{srcIpAddr} = \hyperlink{ip_8c_a132481a9d89ddf554ea8bbbe342e5d5a}{IP\_ADDR\_ANY};
382    queueItem->\hyperlink{struct__SocketQueueItem_a208025c884c682cf54c95b0d12f76962}{destIpAddr} = \hyperlink{ip_8c_a132481a9d89ddf554ea8bbbe342e5d5a}{IP\_ADDR\_ANY};
383 
384    \textcolor{comment}{//Offset to the raw datagram}
385    queueItem->\hyperlink{struct__SocketQueueItem_a059508c5f38241e226e5d713c0fa98a1}{offset} = \textcolor{keyword}{sizeof}(\hyperlink{socket_8h_a3de9721a15d5f4c878df4e2dfccc078f}{SocketQueueItem});
386 
387    \textcolor{comment}{//Copy the Ethernet header}
388    \hyperlink{net__mem_8c_a977e79aab71b4b39772ff8256abb8b55}{netBufferWrite}(queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer}, queueItem->\hyperlink{struct__SocketQueueItem_a059508c5f38241e226e5d713c0fa98a1}{offset}, header,
389       \textcolor{keyword}{sizeof}(\hyperlink{ethernet_8h_a431dfb940d831c1426e2f13891116519}{EthHeader}));
390 
391    \textcolor{comment}{//Copy the payload}
392    \hyperlink{net__mem_8c_a977e79aab71b4b39772ff8256abb8b55}{netBufferWrite}(queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer}, queueItem->\hyperlink{struct__SocketQueueItem_a059508c5f38241e226e5d713c0fa98a1}{offset} + \textcolor{keyword}{sizeof}(
      \hyperlink{ethernet_8h_a431dfb940d831c1426e2f13891116519}{EthHeader}),
393       \hyperlink{dtls__misc_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
394 
395    \textcolor{comment}{//Notify user that data is available}
396    \hyperlink{raw__socket_8c_ad2549c2b0b0ee5cdab3fb45dbb5770d4}{rawSocketUpdateEvents}(socket);
397 \}
\end{DoxyCode}
\mbox{\Hypertarget{raw__socket_8h_a2c4a6c90ef9d2bf9d2c98b305d421401}\label{raw__socket_8h_a2c4a6c90ef9d2bf9d2c98b305d421401}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!raw\+Socket\+Process\+Ip\+Packet@{raw\+Socket\+Process\+Ip\+Packet}}
\index{raw\+Socket\+Process\+Ip\+Packet@{raw\+Socket\+Process\+Ip\+Packet}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{raw\+Socket\+Process\+Ip\+Packet()}{rawSocketProcessIpPacket()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} raw\+Socket\+Process\+Ip\+Packet (\begin{DoxyParamCaption}\item[{\hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{Net\+Interface} $\ast$}]{interface,  }\item[{\hyperlink{structIpPseudoHeader}{Ip\+Pseudo\+Header} $\ast$}]{pseudo\+Header,  }\item[{const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{buffer,  }\item[{size\+\_\+t}]{offset }\end{DoxyParamCaption})}



Process incoming IP packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface} & Underlying network interface \\
\hline
\mbox{\tt in}  & {\em pseudo\+Header} & I\+Pv4 or I\+Pv6 pseudo header \\
\hline
\mbox{\tt in}  & {\em buffer} & Multi-\/part buffer containing the IP packet \\
\hline
\mbox{\tt in}  & {\em offset} & Offset to the first byte of the IP packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 64 of file raw\+\_\+socket.\+c.


\begin{DoxyCode}
66 \{
67    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
68    \textcolor{keywordtype}{size\_t} \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
69    \hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} *\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket};
70    \hyperlink{struct__SocketQueueItem}{SocketQueueItem} *queueItem;
71    \hyperlink{structNetBuffer}{NetBuffer} *\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
72 
73    \textcolor{comment}{//Retrieve the length of the raw IP packet}
74    length = \hyperlink{net__mem_8c_ac9dbcd9e28e61d8f4f6d2e9af2607b68}{netBufferGetLength}(buffer) - \hyperlink{pic32mz_2isr__support_8h_a12a5aed8a193ebbf9a641104a310610d}{offset};
75 
76    \textcolor{comment}{//Loop through opened sockets}
77    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{socket_8h_ab793a8c76592a00fa3ea0510cd2ffe3a}{SOCKET\_MAX\_COUNT}; i++)
78    \{
79       \textcolor{comment}{//Point to the current socket}
80       socket = \hyperlink{socket_8c_acdd76d8e01b4715c774c404b10f958da}{socketTable} + i;
81 
82       \textcolor{comment}{//Raw socket found?}
83       \textcolor{keywordflow}{if}(socket->type != \hyperlink{socket_8h_aa78c7398fa81f7f62aa233159d4d8d97a3db886c9e1e99cf877623ee040af71c5}{SOCKET\_TYPE\_RAW\_IP})
84          \textcolor{keywordflow}{continue};
85       \textcolor{comment}{//Check whether the socket is bound to a particular interface}
86       \textcolor{keywordflow}{if}(socket->interface && socket->interface != interface)
87          \textcolor{keywordflow}{continue};
88 
89 \textcolor{preprocessor}{#if (IPV4\_SUPPORT == ENABLED)}
90       \textcolor{comment}{//IPv4 packet received?}
91       \textcolor{keywordflow}{if}(pseudoHeader->\hyperlink{structIpPseudoHeader_aeff06b8d9c3e7e2ef3cdb8a3a14e8ad2}{length} == \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a0e92b64e038199f1bb6383f2a76f30b6}{Ipv4PseudoHeader}))
92       \{
93          \textcolor{comment}{//Check protocol field}
94          \textcolor{keywordflow}{if}(socket->protocol != pseudoHeader->\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.protocol)
95             \textcolor{keywordflow}{continue};
96 
97          \textcolor{comment}{//Destination IP address filtering}
98          \textcolor{keywordflow}{if}(socket->localIpAddr.length != 0)
99          \{
100             \textcolor{comment}{//An IPv4 address is expected}
101             \textcolor{keywordflow}{if}(socket->localIpAddr.length != \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a411debb3d770caa0c06d3f73367da37f}{Ipv4Addr}))
102                \textcolor{keywordflow}{continue};
103             \textcolor{comment}{//Filter out non-matching addresses}
104             \textcolor{keywordflow}{if}(socket->localIpAddr.ipv4Addr != pseudoHeader->\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.destAddr)
105                \textcolor{keywordflow}{continue};
106          \}
107 
108          \textcolor{comment}{//Source IP address filtering}
109          \textcolor{keywordflow}{if}(socket->remoteIpAddr.length != 0)
110          \{
111             \textcolor{comment}{//An IPv4 address is expected}
112             \textcolor{keywordflow}{if}(socket->remoteIpAddr.length != \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a411debb3d770caa0c06d3f73367da37f}{Ipv4Addr}))
113                \textcolor{keywordflow}{continue};
114             \textcolor{comment}{//Filter out non-matching addresses}
115             \textcolor{keywordflow}{if}(socket->remoteIpAddr.ipv4Addr != pseudoHeader->\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.srcAddr)
116                \textcolor{keywordflow}{continue};
117          \}
118       \}
119       \textcolor{keywordflow}{else}
120 \textcolor{preprocessor}{#endif}
121 \textcolor{preprocessor}{#if (IPV6\_SUPPORT == ENABLED)}
122       \textcolor{comment}{//IPv6 packet received?}
123       \textcolor{keywordflow}{if}(pseudoHeader->\hyperlink{structIpPseudoHeader_aeff06b8d9c3e7e2ef3cdb8a3a14e8ad2}{length} == \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_a68061e0a0b502d880cbe60b645cfa2b7}{Ipv6PseudoHeader}))
124       \{
125          \textcolor{comment}{//Check protocol field}
126          \textcolor{keywordflow}{if}(socket->protocol != pseudoHeader->\hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.nextHeader)
127             \textcolor{keywordflow}{continue};
128 
129          \textcolor{comment}{//Destination IP address filtering}
130          \textcolor{keywordflow}{if}(socket->localIpAddr.length != 0)
131          \{
132             \textcolor{comment}{//An IPv6 address is expected}
133             \textcolor{keywordflow}{if}(socket->localIpAddr.length != \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_aed0cbc40c61ed5b4fb681ebc55237e89}{Ipv6Addr}))
134                \textcolor{keywordflow}{continue};
135             \textcolor{comment}{//Filter out non-matching addresses}
136             \textcolor{keywordflow}{if}(!\hyperlink{ipv6_8h_ab1e93bd2152bc3f3b5642fd0216384d7}{ipv6CompAddr}(&socket->localIpAddr.ipv6Addr, &pseudoHeader->
      \hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.destAddr))
137                \textcolor{keywordflow}{continue};
138          \}
139 
140          \textcolor{comment}{//Source IP address filtering}
141          \textcolor{keywordflow}{if}(socket->remoteIpAddr.length != 0)
142          \{
143             \textcolor{comment}{//An IPv6 address is expected}
144             \textcolor{keywordflow}{if}(socket->remoteIpAddr.length != \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_aed0cbc40c61ed5b4fb681ebc55237e89}{Ipv6Addr}))
145                \textcolor{keywordflow}{continue};
146             \textcolor{comment}{//Filter out non-matching addresses}
147             \textcolor{keywordflow}{if}(!\hyperlink{ipv6_8h_ab1e93bd2152bc3f3b5642fd0216384d7}{ipv6CompAddr}(&socket->remoteIpAddr.ipv6Addr, &pseudoHeader->
      \hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.srcAddr))
148                \textcolor{keywordflow}{continue};
149          \}
150       \}
151       \textcolor{keywordflow}{else}
152 \textcolor{preprocessor}{#endif}
153       \textcolor{comment}{//Invalid packet received?}
154       \{
155          \textcolor{comment}{//This should never occur...}
156          \textcolor{keywordflow}{continue};
157       \}
158 
159       \textcolor{comment}{//The current socket meets all the criteria}
160       \textcolor{keywordflow}{break};
161    \}
162 
163    \textcolor{comment}{//Drop incoming packet if no matching socket was found}
164    \textcolor{keywordflow}{if}(i >= SOCKET\_MAX\_COUNT)
165       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cad80456d511d340377794c81eb5137d10}{ERROR\_PROTOCOL\_UNREACHABLE};
166 
167    \textcolor{comment}{//Empty receive queue?}
168    \textcolor{keywordflow}{if}(!socket->receiveQueue)
169    \{
170       \textcolor{comment}{//Allocate a memory buffer to hold the data and the associated descriptor}
171       p = \hyperlink{net__mem_8c_a986c9991e530e99528faa4c43efadc6f}{netBufferAlloc}(\textcolor{keyword}{sizeof}(\hyperlink{struct__SocketQueueItem}{SocketQueueItem}) + length);
172 
173       \textcolor{comment}{//Successful memory allocation?}
174       \textcolor{keywordflow}{if}(p != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
175       \{
176          \textcolor{comment}{//Point to the newly created item}
177          queueItem = \hyperlink{net__mem_8c_a20d30c9db547b3b2743368b589cf482b}{netBufferAt}(p, 0);
178          queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer} = \hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
179          \textcolor{comment}{//Add the newly created item to the queue}
180          socket->receiveQueue = queueItem;
181       \}
182       \textcolor{keywordflow}{else}
183       \{
184          \textcolor{comment}{//Memory allocation failed}
185          queueItem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
186       \}
187    \}
188    \textcolor{keywordflow}{else}
189    \{
190       \textcolor{comment}{//Point to the very first item}
191       queueItem = socket->receiveQueue;
192       \textcolor{comment}{//Reach the last item in the receive queue}
193       \textcolor{keywordflow}{for}(i = 1; queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next}; i++)
194          queueItem = queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next};
195 
196       \textcolor{comment}{//Make sure the receive queue is not full}
197       \textcolor{keywordflow}{if}(i >= \hyperlink{raw__socket_8h_a1a47fb68e2fe9b4282dd3945fba8bfbb}{RAW\_SOCKET\_RX\_QUEUE\_SIZE})
198          \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689ca9403fdb452694b8129df4baf3b899da9}{ERROR\_RECEIVE\_QUEUE\_FULL};
199 
200       \textcolor{comment}{//Allocate a memory buffer to hold the data and the associated descriptor}
201       p = \hyperlink{net__mem_8c_a986c9991e530e99528faa4c43efadc6f}{netBufferAlloc}(\textcolor{keyword}{sizeof}(\hyperlink{struct__SocketQueueItem}{SocketQueueItem}) + length);
202 
203       \textcolor{comment}{//Successful memory allocation?}
204       \textcolor{keywordflow}{if}(p != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
205       \{
206          \textcolor{comment}{//Add the newly created item to the queue}
207          queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next} = \hyperlink{net__mem_8c_a20d30c9db547b3b2743368b589cf482b}{netBufferAt}(p, 0);
208          \textcolor{comment}{//Point to the newly created item}
209          queueItem = queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next};
210          queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer} = \hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
211       \}
212       \textcolor{keywordflow}{else}
213       \{
214          \textcolor{comment}{//Memory allocation failed}
215          queueItem = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
216       \}
217    \}
218 
219    \textcolor{comment}{//Failed to allocate memory?}
220    \textcolor{keywordflow}{if}(queueItem == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
221       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cac0a554045048d2fb61387cf735676f69}{ERROR\_OUT\_OF\_MEMORY};
222 
223    \textcolor{comment}{//Initialize next field}
224    queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
225    \textcolor{comment}{//Port number is unused}
226    queueItem->\hyperlink{struct__SocketQueueItem_aae5da9b297543edc1b28914115ee928b}{srcPort} = 0;
227 
228 \textcolor{preprocessor}{#if (IPV4\_SUPPORT == ENABLED)}
229    \textcolor{comment}{//IPv4 remote address?}
230    \textcolor{keywordflow}{if}(pseudoHeader->\hyperlink{structIpPseudoHeader_aeff06b8d9c3e7e2ef3cdb8a3a14e8ad2}{length} == \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a0e92b64e038199f1bb6383f2a76f30b6}{Ipv4PseudoHeader}))
231    \{
232       \textcolor{comment}{//Save the source IPv4 address}
233       queueItem->\hyperlink{struct__SocketQueueItem_a35f1157ded7017ef108d8875d2cedfa7}{srcIpAddr}.\hyperlink{structIpAddr_ae61478bd1e79361fca7dd04a21aeb2f8}{length} = \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a411debb3d770caa0c06d3f73367da37f}{Ipv4Addr});
234       queueItem->\hyperlink{struct__SocketQueueItem_a35f1157ded7017ef108d8875d2cedfa7}{srcIpAddr}.\hyperlink{structIpAddr_a8de6f49cb0461f57c1eda49bb1088916}{ipv4Addr} = pseudoHeader->\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.srcAddr;
235       \textcolor{comment}{//Save the destination IPv4 address}
236       queueItem->\hyperlink{struct__SocketQueueItem_a208025c884c682cf54c95b0d12f76962}{destIpAddr}.\hyperlink{structIpAddr_ae61478bd1e79361fca7dd04a21aeb2f8}{length} = \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a411debb3d770caa0c06d3f73367da37f}{Ipv4Addr});
237       queueItem->\hyperlink{struct__SocketQueueItem_a208025c884c682cf54c95b0d12f76962}{destIpAddr}.\hyperlink{structIpAddr_a8de6f49cb0461f57c1eda49bb1088916}{ipv4Addr} = pseudoHeader->\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.destAddr;
238    \}
239 \textcolor{preprocessor}{#endif}
240 \textcolor{preprocessor}{#if (IPV6\_SUPPORT == ENABLED)}
241    \textcolor{comment}{//IPv6 remote address?}
242    \textcolor{keywordflow}{if}(pseudoHeader->\hyperlink{structIpPseudoHeader_aeff06b8d9c3e7e2ef3cdb8a3a14e8ad2}{length} == \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_a68061e0a0b502d880cbe60b645cfa2b7}{Ipv6PseudoHeader}))
243    \{
244       \textcolor{comment}{//Save the source IPv6 address}
245       queueItem->\hyperlink{struct__SocketQueueItem_a35f1157ded7017ef108d8875d2cedfa7}{srcIpAddr}.\hyperlink{structIpAddr_ae61478bd1e79361fca7dd04a21aeb2f8}{length} = \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_aed0cbc40c61ed5b4fb681ebc55237e89}{Ipv6Addr});
246       queueItem->\hyperlink{struct__SocketQueueItem_a35f1157ded7017ef108d8875d2cedfa7}{srcIpAddr}.\hyperlink{structIpAddr_a9bc2340a9c0bc5a0b8aa9695b74e2ee6}{ipv6Addr} = pseudoHeader->\hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.srcAddr;
247       \textcolor{comment}{//Save the destination IPv6 address}
248       queueItem->\hyperlink{struct__SocketQueueItem_a208025c884c682cf54c95b0d12f76962}{destIpAddr}.\hyperlink{structIpAddr_ae61478bd1e79361fca7dd04a21aeb2f8}{length} = \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_aed0cbc40c61ed5b4fb681ebc55237e89}{Ipv6Addr});
249       queueItem->\hyperlink{struct__SocketQueueItem_a208025c884c682cf54c95b0d12f76962}{destIpAddr}.\hyperlink{structIpAddr_a9bc2340a9c0bc5a0b8aa9695b74e2ee6}{ipv6Addr} = pseudoHeader->\hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.destAddr;
250    \}
251 \textcolor{preprocessor}{#endif}
252 
253    \textcolor{comment}{//Offset to the raw IP packet}
254    queueItem->\hyperlink{struct__SocketQueueItem_a059508c5f38241e226e5d713c0fa98a1}{offset} = \textcolor{keyword}{sizeof}(\hyperlink{socket_8h_a3de9721a15d5f4c878df4e2dfccc078f}{SocketQueueItem});
255    \textcolor{comment}{//Copy the raw data}
256    \hyperlink{net__mem_8c_a553a02631efd217192800ad3cdf9bbba}{netBufferCopy}(queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer}, queueItem->\hyperlink{struct__SocketQueueItem_a059508c5f38241e226e5d713c0fa98a1}{offset}, buffer, 
      \hyperlink{pic32mz_2isr__support_8h_a12a5aed8a193ebbf9a641104a310610d}{offset}, length);
257 
258    \textcolor{comment}{//Notify user that data is available}
259    \hyperlink{raw__socket_8c_ad2549c2b0b0ee5cdab3fb45dbb5770d4}{rawSocketUpdateEvents}(socket);
260 
261    \textcolor{comment}{//Successful processing}
262    \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cabf350750d0d4fabd8954c0f1e9bbae94}{NO\_ERROR};
263 \}
\end{DoxyCode}
\mbox{\Hypertarget{raw__socket_8h_a464cbc1f822724be352807f23357b762}\label{raw__socket_8h_a464cbc1f822724be352807f23357b762}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!raw\+Socket\+Receive\+Eth\+Packet@{raw\+Socket\+Receive\+Eth\+Packet}}
\index{raw\+Socket\+Receive\+Eth\+Packet@{raw\+Socket\+Receive\+Eth\+Packet}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{raw\+Socket\+Receive\+Eth\+Packet()}{rawSocketReceiveEthPacket()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} raw\+Socket\+Receive\+Eth\+Packet (\begin{DoxyParamCaption}\item[{\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$}]{socket,  }\item[{void $\ast$}]{data,  }\item[{size\+\_\+t}]{size,  }\item[{size\+\_\+t $\ast$}]{received,  }\item[{\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t}}]{flags }\end{DoxyParamCaption})}



Receive an Ethernet packet from a raw socket. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em socket} & Handle referencing the socket \\
\hline
\mbox{\tt out}  & {\em data} & Buffer where to store the incoming data \\
\hline
\mbox{\tt in}  & {\em size} & Maximum number of bytes that can be received \\
\hline
\mbox{\tt out}  & {\em received} & Number of bytes that have been received \\
\hline
\mbox{\tt in}  & {\em flags} & Set of flags that influences the behavior of this function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 718 of file raw\+\_\+socket.\+c.


\begin{DoxyCode}
720 \{
721    \hyperlink{struct__SocketQueueItem}{SocketQueueItem} *queueItem;
722 
723    \textcolor{comment}{//The SOCKET\_FLAG\_DONT\_WAIT enables non-blocking operation}
724    \textcolor{keywordflow}{if}(!(\hyperlink{tcp_8h_aa2585d779da0ab21273a8d92de9a0ebe}{flags} & \hyperlink{socket_8h_a36c1d45d435e2f0ebe609c31d0c2da16abbdb82a09cc4206db646e1b31ac3224e}{SOCKET\_FLAG\_DONT\_WAIT}))
725    \{
726       \textcolor{comment}{//The receive queue is empty?}
727       \textcolor{keywordflow}{if}(!\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue)
728       \{
729          \textcolor{comment}{//Set the events the application is interested in}
730          \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventMask = \hyperlink{socket_8h_add8a4c36456f478ab23bd4372aebde6ea72985d7e82625f037ca8a6734f49996c}{SOCKET\_EVENT\_RX\_READY};
731          \textcolor{comment}{//Reset the event object}
732          \hyperlink{os__port__chibios_8c_a9122a1cf258caef553a6b224ef8ef6bf}{osResetEvent}(&\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->event);
733 
734          \textcolor{comment}{//Release exclusive access}
735          \hyperlink{os__port__chibios_8c_a8e10e5b2c6d3877b5ba60e375ac45d79}{osReleaseMutex}(&\hyperlink{net_8c_afe31551ad26115fae8e575654346d441}{netMutex});
736          \textcolor{comment}{//Wait until an event is triggered}
737          \hyperlink{os__port__chibios_8c_a1dc707247e44dfefae5bec4a322fc78a}{osWaitForEvent}(&\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->event, \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->timeout);
738          \textcolor{comment}{//Get exclusive access}
739          \hyperlink{os__port__chibios_8c_a58485224df4bfa522246d55b35bbd83a}{osAcquireMutex}(&\hyperlink{net_8c_afe31551ad26115fae8e575654346d441}{netMutex});
740       \}
741    \}
742 
743    \textcolor{comment}{//Check whether the read operation timed out}
744    \textcolor{keywordflow}{if}(!\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue)
745    \{
746       \textcolor{comment}{//No data can be read}
747       *received = 0;
748       \textcolor{comment}{//Report a timeout error}
749       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689ca4d0f7be53b837f004379ac6bbd56f1e2}{ERROR\_TIMEOUT};
750    \}
751 
752    \textcolor{comment}{//Point to the first item in the receive queue}
753    queueItem = \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue;
754    \textcolor{comment}{//Copy data to user buffer}
755    *received = \hyperlink{net__mem_8c_af3ed1bc3f7d55f830cbbe6aa12e61af0}{netBufferRead}(\hyperlink{dtls__misc_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer}, queueItem->
      \hyperlink{struct__SocketQueueItem_a059508c5f38241e226e5d713c0fa98a1}{offset}, size);
756 
757    \textcolor{comment}{//If the SOCKET\_FLAG\_PEEK flag is set, the data is copied}
758    \textcolor{comment}{//into the buffer but is not removed from the input queue}
759    \textcolor{keywordflow}{if}(!(\hyperlink{tcp_8h_aa2585d779da0ab21273a8d92de9a0ebe}{flags} & \hyperlink{socket_8h_a36c1d45d435e2f0ebe609c31d0c2da16a46bda9fd028af8bdb3f0daa9e8a806f6}{SOCKET\_FLAG\_PEEK}))
760    \{
761       \textcolor{comment}{//Remove the item from the receive queue}
762       \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue = queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next};
763       \textcolor{comment}{//Deallocate memory buffer}
764       \hyperlink{net__mem_8c_aa33fc4dd2a71649194052f297c707d08}{netBufferFree}(queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer});
765    \}
766 
767    \textcolor{comment}{//Update the state of events}
768    \hyperlink{raw__socket_8c_ad2549c2b0b0ee5cdab3fb45dbb5770d4}{rawSocketUpdateEvents}(\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket});
769 
770    \textcolor{comment}{//Successful read operation}
771    \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cabf350750d0d4fabd8954c0f1e9bbae94}{NO\_ERROR};
772 \}
\end{DoxyCode}
\mbox{\Hypertarget{raw__socket_8h_a3a4847947846250d316321659feb0e52}\label{raw__socket_8h_a3a4847947846250d316321659feb0e52}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!raw\+Socket\+Receive\+Ip\+Packet@{raw\+Socket\+Receive\+Ip\+Packet}}
\index{raw\+Socket\+Receive\+Ip\+Packet@{raw\+Socket\+Receive\+Ip\+Packet}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{raw\+Socket\+Receive\+Ip\+Packet()}{rawSocketReceiveIpPacket()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} raw\+Socket\+Receive\+Ip\+Packet (\begin{DoxyParamCaption}\item[{\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$}]{socket,  }\item[{\hyperlink{structIpAddr}{Ip\+Addr} $\ast$}]{src\+Ip\+Addr,  }\item[{\hyperlink{structIpAddr}{Ip\+Addr} $\ast$}]{dest\+Ip\+Addr,  }\item[{void $\ast$}]{data,  }\item[{size\+\_\+t}]{size,  }\item[{size\+\_\+t $\ast$}]{received,  }\item[{\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t}}]{flags }\end{DoxyParamCaption})}



Receive an IP packet from a raw socket. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em socket} & Handle referencing the socket \\
\hline
\mbox{\tt out}  & {\em src\+Ip\+Addr} & Source IP address (optional) \\
\hline
\mbox{\tt out}  & {\em dest\+Ip\+Addr} & Destination IP address (optional) \\
\hline
\mbox{\tt out}  & {\em data} & Buffer where to store the incoming data \\
\hline
\mbox{\tt in}  & {\em size} & Maximum number of bytes that can be received \\
\hline
\mbox{\tt out}  & {\em received} & Number of bytes that have been received \\
\hline
\mbox{\tt in}  & {\em flags} & Set of flags that influences the behavior of this function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 644 of file raw\+\_\+socket.\+c.


\begin{DoxyCode}
646 \{
647    \hyperlink{struct__SocketQueueItem}{SocketQueueItem} *queueItem;
648 
649    \textcolor{comment}{//The SOCKET\_FLAG\_DONT\_WAIT enables non-blocking operation}
650    \textcolor{keywordflow}{if}(!(\hyperlink{tcp_8h_aa2585d779da0ab21273a8d92de9a0ebe}{flags} & \hyperlink{socket_8h_a36c1d45d435e2f0ebe609c31d0c2da16abbdb82a09cc4206db646e1b31ac3224e}{SOCKET\_FLAG\_DONT\_WAIT}))
651    \{
652       \textcolor{comment}{//The receive queue is empty?}
653       \textcolor{keywordflow}{if}(!\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue)
654       \{
655          \textcolor{comment}{//Set the events the application is interested in}
656          \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventMask = \hyperlink{socket_8h_add8a4c36456f478ab23bd4372aebde6ea72985d7e82625f037ca8a6734f49996c}{SOCKET\_EVENT\_RX\_READY};
657          \textcolor{comment}{//Reset the event object}
658          \hyperlink{os__port__chibios_8c_a9122a1cf258caef553a6b224ef8ef6bf}{osResetEvent}(&\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->event);
659 
660          \textcolor{comment}{//Release exclusive access}
661          \hyperlink{os__port__chibios_8c_a8e10e5b2c6d3877b5ba60e375ac45d79}{osReleaseMutex}(&\hyperlink{net_8c_afe31551ad26115fae8e575654346d441}{netMutex});
662          \textcolor{comment}{//Wait until an event is triggered}
663          \hyperlink{os__port__chibios_8c_a1dc707247e44dfefae5bec4a322fc78a}{osWaitForEvent}(&\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->event, \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->timeout);
664          \textcolor{comment}{//Get exclusive access}
665          \hyperlink{os__port__chibios_8c_a58485224df4bfa522246d55b35bbd83a}{osAcquireMutex}(&\hyperlink{net_8c_afe31551ad26115fae8e575654346d441}{netMutex});
666       \}
667    \}
668 
669    \textcolor{comment}{//Check whether the read operation timed out}
670    \textcolor{keywordflow}{if}(!\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue)
671    \{
672       \textcolor{comment}{//No data can be read}
673       *received = 0;
674       \textcolor{comment}{//Report a timeout error}
675       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689ca4d0f7be53b837f004379ac6bbd56f1e2}{ERROR\_TIMEOUT};
676    \}
677 
678    \textcolor{comment}{//Point to the first item in the receive queue}
679    queueItem = \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue;
680    \textcolor{comment}{//Copy data to user buffer}
681    *received = \hyperlink{net__mem_8c_af3ed1bc3f7d55f830cbbe6aa12e61af0}{netBufferRead}(\hyperlink{dtls__misc_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer}, queueItem->
      \hyperlink{struct__SocketQueueItem_a059508c5f38241e226e5d713c0fa98a1}{offset}, size);
682 
683    \textcolor{comment}{//Save the source IP address}
684    \textcolor{keywordflow}{if}(srcIpAddr)
685       *srcIpAddr = queueItem->\hyperlink{struct__SocketQueueItem_a35f1157ded7017ef108d8875d2cedfa7}{srcIpAddr};
686    \textcolor{comment}{//Save the destination IP address}
687    \textcolor{keywordflow}{if}(destIpAddr)
688       *destIpAddr = queueItem->\hyperlink{struct__SocketQueueItem_a208025c884c682cf54c95b0d12f76962}{destIpAddr};
689 
690    \textcolor{comment}{//If the SOCKET\_FLAG\_PEEK flag is set, the data is copied}
691    \textcolor{comment}{//into the buffer but is not removed from the input queue}
692    \textcolor{keywordflow}{if}(!(\hyperlink{tcp_8h_aa2585d779da0ab21273a8d92de9a0ebe}{flags} & \hyperlink{socket_8h_a36c1d45d435e2f0ebe609c31d0c2da16a46bda9fd028af8bdb3f0daa9e8a806f6}{SOCKET\_FLAG\_PEEK}))
693    \{
694       \textcolor{comment}{//Remove the item from the receive queue}
695       \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue = queueItem->\hyperlink{struct__SocketQueueItem_a1160810dc2a18cd5fe63d9fc9dbf5f26}{next};
696       \textcolor{comment}{//Deallocate memory buffer}
697       \hyperlink{net__mem_8c_aa33fc4dd2a71649194052f297c707d08}{netBufferFree}(queueItem->\hyperlink{struct__SocketQueueItem_a31b5c1ca345095021d7af269deefdb42}{buffer});
698    \}
699 
700    \textcolor{comment}{//Update the state of events}
701    \hyperlink{raw__socket_8c_ad2549c2b0b0ee5cdab3fb45dbb5770d4}{rawSocketUpdateEvents}(\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket});
702 
703    \textcolor{comment}{//Successful read operation}
704    \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cabf350750d0d4fabd8954c0f1e9bbae94}{NO\_ERROR};
705 \}
\end{DoxyCode}
\mbox{\Hypertarget{raw__socket_8h_a9999b3d59ed200a7a72114da765f1577}\label{raw__socket_8h_a9999b3d59ed200a7a72114da765f1577}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!raw\+Socket\+Send\+Eth\+Packet@{raw\+Socket\+Send\+Eth\+Packet}}
\index{raw\+Socket\+Send\+Eth\+Packet@{raw\+Socket\+Send\+Eth\+Packet}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{raw\+Socket\+Send\+Eth\+Packet()}{rawSocketSendEthPacket()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} raw\+Socket\+Send\+Eth\+Packet (\begin{DoxyParamCaption}\item[{\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$}]{socket,  }\item[{const void $\ast$}]{data,  }\item[{size\+\_\+t}]{length,  }\item[{size\+\_\+t $\ast$}]{written }\end{DoxyParamCaption})}



Send an raw Ethernet packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em socket} & Handle referencing the socket \\
\hline
\mbox{\tt in}  & {\em data} & Pointer to raw data \\
\hline
\mbox{\tt in}  & {\em length} & Length of the raw data \\
\hline
\mbox{\tt out}  & {\em written} & Actual number of bytes written (optional parameter) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 524 of file raw\+\_\+socket.\+c.


\begin{DoxyCode}
526 \{
527    \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\_t} error;
528 
529 \textcolor{preprocessor}{#if (ETH\_SUPPORT == ENABLED)}
530    \hyperlink{structNetBuffer}{NetBuffer} *buffer;
531    \hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{NetInterface} *interface;
532 
533    \textcolor{comment}{//Select the relevant network interface}
534    \textcolor{keywordflow}{if}(!\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->interface)
535       \textcolor{keyword}{interface }= \hyperlink{net_8c_a991aba7eae4de79f30c6889d95cc6870}{netGetDefaultInterface}();
536    \textcolor{keywordflow}{else}
537       \textcolor{keyword}{interface }= \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->interface;
538 
539    \textcolor{comment}{//Forward the frame to the physical interface}
540    \textcolor{keyword}{interface }= nicGetPhysicalInterface(interface);
541 
542    \textcolor{comment}{//Ethernet interface?}
543    \textcolor{keywordflow}{if}(interface->nicDriver != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} &&
544       interface->nicDriver->type == \hyperlink{nic_8h_ac1ce8659a9797513ecd9cc1afedce40ba84802cab6ee937691c3d76122ffaffcd}{NIC\_TYPE\_ETHERNET})
545    \{
546       \textcolor{comment}{//Allocate a buffer memory to hold the raw Ethernet packet}
547       buffer = \hyperlink{net__mem_8c_a986c9991e530e99528faa4c43efadc6f}{netBufferAlloc}(0);
548       \textcolor{comment}{//Failed to allocate buffer?}
549       \textcolor{keywordflow}{if}(buffer == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
550          \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cac0a554045048d2fb61387cf735676f69}{ERROR\_OUT\_OF\_MEMORY};
551 
552       \textcolor{comment}{//Copy the raw data}
553       error = \hyperlink{net__mem_8c_aceae1188a93321e1d4daed11bb8005df}{netBufferAppend}(buffer, \hyperlink{dtls__misc_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
554 
555       \textcolor{comment}{//Successful processing?}
556       \textcolor{keywordflow}{if}(!error)
557       \{
558          \textcolor{comment}{//Automatic padding not supported by hardware?}
559          \textcolor{keywordflow}{if}(!interface->nicDriver->autoPadding)
560          \{
561             \textcolor{comment}{//The host controller should manually add padding}
562             \textcolor{comment}{//to the packet before transmitting it}
563             \textcolor{keywordflow}{if}(\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} < (\hyperlink{ethernet_8h_a8ec3ce465132401b12ea5409b14bea92}{ETH\_MIN\_FRAME\_SIZE} - 
      \hyperlink{ethernet_8h_a6be302136e0434536d049406760485b1}{ETH\_CRC\_SIZE}))
564             \{
565                \textcolor{keywordtype}{size\_t} \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
566 
567                \textcolor{comment}{//Add padding as necessary}
568                n = (\hyperlink{ethernet_8h_a8ec3ce465132401b12ea5409b14bea92}{ETH\_MIN\_FRAME\_SIZE} - \hyperlink{ethernet_8h_a6be302136e0434536d049406760485b1}{ETH\_CRC\_SIZE}) - 
      \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
569 
570                \textcolor{comment}{//Append padding bytes}
571                error = \hyperlink{net__mem_8c_aceae1188a93321e1d4daed11bb8005df}{netBufferAppend}(buffer, \hyperlink{ethernet__misc_8c_ade727849dd0a05220a66bf870c0a201f}{ethPadding}, n);
572                \textcolor{comment}{//Any error to report?}
573                \textcolor{keywordflow}{if}(error)
574                   \textcolor{keywordflow}{return} error;
575 
576                \textcolor{comment}{//Adjust frame length}
577                \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} += \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
578             \}
579          \}
580 
581          \textcolor{comment}{//CRC calculation not supported by hardware?}
582          \textcolor{keywordflow}{if}(!interface->nicDriver->autoCrcCalc)
583          \{
584             \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\_t} crc;
585 
586             \textcolor{comment}{//Compute CRC over the header and payload}
587             crc = \hyperlink{ethernet__misc_8c_a7f86288f9e2517184cc9f195f5d26f39}{ethCalcCrcEx}(buffer, 0, \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
588             \textcolor{comment}{//Convert from host byte order to little-endian byte order}
589             crc = \hyperlink{cpu__endian_8h_a336f132f175f47bfab3fa57f6a00276d}{htole32}(crc);
590 
591             \textcolor{comment}{//Append the calculated CRC value}
592             error = \hyperlink{net__mem_8c_aceae1188a93321e1d4daed11bb8005df}{netBufferAppend}(buffer, &crc, \textcolor{keyword}{sizeof}(crc));
593             \textcolor{comment}{//Any error to report?}
594             \textcolor{keywordflow}{if}(error)
595                \textcolor{keywordflow}{return} error;
596 
597             \textcolor{comment}{//Adjust frame length}
598             \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} += \textcolor{keyword}{sizeof}(crc);
599          \}
600 
601          \textcolor{comment}{//Debug message}
602          \hyperlink{debug_8h_a67a8f9bc74358aa21745a76e23768dae}{TRACE\_DEBUG}(\textcolor{stringliteral}{"Sending raw Ethernet frame (%"} \hyperlink{compiler__port_8h_a2b7b0557dc6cd786df02dafbb51f5292}{PRIuSIZE} \textcolor{stringliteral}{" bytes)...\(\backslash\)r\(\backslash\)n"}, 
      \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
603 
604          \textcolor{comment}{//Send the resulting packet over the specified link}
605          error = \hyperlink{nic_8c_af480b2743ecb07bc0312f2bbcecdb287}{nicSendPacket}(interface, buffer, 0);
606       \}
607 
608       \textcolor{comment}{//Free previously allocated memory block}
609       \hyperlink{net__mem_8c_aa33fc4dd2a71649194052f297c707d08}{netBufferFree}(buffer);
610    \}
611    \textcolor{keywordflow}{else}
612 \textcolor{preprocessor}{#endif}
613    \textcolor{comment}{//Unknown interface type?}
614    \{
615       \textcolor{comment}{//Report an error}
616       error = \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689ca18648c6804c77e30234b0e60e646718b}{ERROR\_INVALID\_INTERFACE};
617    \}
618 
619    \textcolor{comment}{//Successful processing?}
620    \textcolor{keywordflow}{if}(!error)
621    \{
622       \textcolor{comment}{//Total number of bytes successfully transmitted}
623       \textcolor{keywordflow}{if}(written != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
624          *written = \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
625    \}
626 
627    \textcolor{comment}{//Return status code}
628    \textcolor{keywordflow}{return} error;
629 \}
\end{DoxyCode}
\mbox{\Hypertarget{raw__socket_8h_a97dedb8c93bbc612d09563f523140a9c}\label{raw__socket_8h_a97dedb8c93bbc612d09563f523140a9c}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!raw\+Socket\+Send\+Ip\+Packet@{raw\+Socket\+Send\+Ip\+Packet}}
\index{raw\+Socket\+Send\+Ip\+Packet@{raw\+Socket\+Send\+Ip\+Packet}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{raw\+Socket\+Send\+Ip\+Packet()}{rawSocketSendIpPacket()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} raw\+Socket\+Send\+Ip\+Packet (\begin{DoxyParamCaption}\item[{\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$}]{socket,  }\item[{const \hyperlink{structIpAddr}{Ip\+Addr} $\ast$}]{dest\+Ip\+Addr,  }\item[{const void $\ast$}]{data,  }\item[{size\+\_\+t}]{length,  }\item[{size\+\_\+t $\ast$}]{written,  }\item[{\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t}}]{flags }\end{DoxyParamCaption})}



Send an raw IP packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em socket} & Handle referencing the socket \\
\hline
\mbox{\tt in}  & {\em dest\+Ip\+Addr} & IP address of the target host \\
\hline
\mbox{\tt in}  & {\em data} & Pointer to raw data \\
\hline
\mbox{\tt in}  & {\em length} & Length of the raw data \\
\hline
\mbox{\tt out}  & {\em written} & Actual number of bytes written (optional parameter) \\
\hline
\mbox{\tt in}  & {\em flags} & Set of flags that influences the behavior of this function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 411 of file raw\+\_\+socket.\+c.


\begin{DoxyCode}
413 \{
414    \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\_t} error;
415    \textcolor{keywordtype}{size\_t} \hyperlink{pic32mz_2isr__support_8h_a12a5aed8a193ebbf9a641104a310610d}{offset};
416    \hyperlink{structNetBuffer}{NetBuffer} *buffer;
417    \hyperlink{net_8h_a2234db8911a1148c9159979d8f5e0d6b}{NetInterface} *interface;
418    \hyperlink{structIpPseudoHeader}{IpPseudoHeader} pseudoHeader;
419 
420    \textcolor{comment}{//Ignore unused flags}
421    \hyperlink{tcp_8h_aa2585d779da0ab21273a8d92de9a0ebe}{flags} &= \hyperlink{socket_8h_a36c1d45d435e2f0ebe609c31d0c2da16a93ad8a933525cd2643183ec07e107236}{SOCKET\_FLAG\_DONT\_ROUTE};
422 
423    \textcolor{comment}{//The socket may be bound to a particular network interface}
424    \textcolor{keyword}{interface }= \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->interface;
425 
426    \textcolor{comment}{//Allocate a buffer memory to hold the raw IP datagram}
427    buffer = \hyperlink{ip_8c_a2222fb64b1b18140283119eea309c1b3}{ipAllocBuffer}(0, &offset);
428    \textcolor{comment}{//Failed to allocate memory?}
429    \textcolor{keywordflow}{if}(buffer == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
430       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cac0a554045048d2fb61387cf735676f69}{ERROR\_OUT\_OF\_MEMORY};
431 
432    \textcolor{comment}{//Start of exception handling block}
433    \textcolor{keywordflow}{do}
434    \{
435       \textcolor{comment}{//Copy the raw data}
436       error = \hyperlink{net__mem_8c_aceae1188a93321e1d4daed11bb8005df}{netBufferAppend}(buffer, \hyperlink{dtls__misc_8h_a5c239a1bb87b52b0f1d6d68c4749cd2a}{data}, \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
437       \textcolor{comment}{//Any error to report?}
438       \textcolor{keywordflow}{if}(error)
439          \textcolor{keywordflow}{break};
440 
441 \textcolor{preprocessor}{#if (IPV4\_SUPPORT == ENABLED)}
442       \textcolor{comment}{//Destination address is an IPv4 address?}
443       \textcolor{keywordflow}{if}(destIpAddr->\hyperlink{structIpAddr_ae61478bd1e79361fca7dd04a21aeb2f8}{length} == \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a411debb3d770caa0c06d3f73367da37f}{Ipv4Addr}))
444       \{
445          \hyperlink{ipv4_8h_a411debb3d770caa0c06d3f73367da37f}{Ipv4Addr} \hyperlink{ipcp_8h_a8ddffb4d02fcd8ad856313d3e208c34f}{srcIpAddr};
446 
447          \textcolor{comment}{//Select the source IPv4 address and the relevant network interface}
448          \textcolor{comment}{//to use when sending data to the specified destination host}
449          error = \hyperlink{ipv4__misc_8c_af1ec532996ca54986f87e67a354e03e1}{ipv4SelectSourceAddr}(&interface, destIpAddr->
      \hyperlink{structIpAddr_a8de6f49cb0461f57c1eda49bb1088916}{ipv4Addr},
450             &srcIpAddr);
451          \textcolor{comment}{//Any error to report?}
452          \textcolor{keywordflow}{if}(error)
453             \textcolor{keywordflow}{break};
454 
455          \textcolor{comment}{//Format IPv4 pseudo header}
456          pseudoHeader.\hyperlink{structIpPseudoHeader_aeff06b8d9c3e7e2ef3cdb8a3a14e8ad2}{length} = \textcolor{keyword}{sizeof}(\hyperlink{ipv4_8h_a0e92b64e038199f1bb6383f2a76f30b6}{Ipv4PseudoHeader});
457          pseudoHeader.\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.srcAddr = \hyperlink{ipcp_8h_a8ddffb4d02fcd8ad856313d3e208c34f}{srcIpAddr};
458          pseudoHeader.\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.destAddr = destIpAddr->\hyperlink{structIpAddr_a8de6f49cb0461f57c1eda49bb1088916}{ipv4Addr};
459          pseudoHeader.\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.reserved = 0;
460          pseudoHeader.\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.protocol = \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->protocol;
461          pseudoHeader.\hyperlink{structIpPseudoHeader_a4dd0d91580f30918dc7b5d5a430dba6a}{ipv4Data}.length = \hyperlink{cpu__endian_8h_a800cdbf435a85a9b3ad4f0edc518472a}{htons}(\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
462       \}
463       \textcolor{keywordflow}{else}
464 \textcolor{preprocessor}{#endif}
465 \textcolor{preprocessor}{#if (IPV6\_SUPPORT == ENABLED)}
466       \textcolor{comment}{//Destination address is an IPv6 address?}
467       \textcolor{keywordflow}{if}(destIpAddr->\hyperlink{structIpAddr_ae61478bd1e79361fca7dd04a21aeb2f8}{length} == \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_aed0cbc40c61ed5b4fb681ebc55237e89}{Ipv6Addr}))
468       \{
469          \textcolor{comment}{//Select the source IPv6 address and the relevant network interface}
470          \textcolor{comment}{//to use when sending data to the specified destination host}
471          error = \hyperlink{ipv6__misc_8c_a1d69e11a455ee8895ec67061f554a174}{ipv6SelectSourceAddr}(&interface, &destIpAddr->
      \hyperlink{structIpAddr_a9bc2340a9c0bc5a0b8aa9695b74e2ee6}{ipv6Addr},
472             &pseudoHeader.\hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.srcAddr);
473          \textcolor{comment}{//Any error to report?}
474          \textcolor{keywordflow}{if}(error)
475             \textcolor{keywordflow}{break};
476 
477          \textcolor{comment}{//Format IPv6 pseudo header}
478          pseudoHeader.\hyperlink{structIpPseudoHeader_aeff06b8d9c3e7e2ef3cdb8a3a14e8ad2}{length} = \textcolor{keyword}{sizeof}(\hyperlink{ipv6_8h_a68061e0a0b502d880cbe60b645cfa2b7}{Ipv6PseudoHeader});
479          pseudoHeader.\hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.destAddr = destIpAddr->\hyperlink{structIpAddr_a9bc2340a9c0bc5a0b8aa9695b74e2ee6}{ipv6Addr};
480          pseudoHeader.\hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.length = \hyperlink{cpu__endian_8h_a63baf217625b15caa7246af75b027380}{htonl}(\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
481          pseudoHeader.\hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.reserved = 0;
482          pseudoHeader.\hyperlink{structIpPseudoHeader_a5155846ca7e85218407a8374d035aab7}{ipv6Data}.nextHeader = \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->protocol;
483       \}
484       \textcolor{keywordflow}{else}
485 \textcolor{preprocessor}{#endif}
486       \textcolor{comment}{//Invalid destination address?}
487       \{
488          \textcolor{comment}{//An internal error has occurred}
489          error = \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cae9be6449970fca5714ab9957b16562a5}{ERROR\_FAILURE};
490          \textcolor{comment}{//Exit immediately}
491          \textcolor{keywordflow}{break};
492       \}
493 
494       \textcolor{comment}{//Send raw IP datagram}
495       error = \hyperlink{ip_8c_ac39710faa96e88364ef7007fee711c5e}{ipSendDatagram}(interface, &pseudoHeader, buffer, offset,
496          \hyperlink{tcp_8h_aa2585d779da0ab21273a8d92de9a0ebe}{flags} | \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->ttl);
497       \textcolor{comment}{//Failed to send data?}
498       \textcolor{keywordflow}{if}(error)
499          \textcolor{keywordflow}{break};
500 
501       \textcolor{comment}{//Total number of bytes successfully transmitted}
502       \textcolor{keywordflow}{if}(written != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
503          *written = \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
504 
505       \textcolor{comment}{//End of exception handling block}
506    \} \textcolor{keywordflow}{while}(0);
507 
508    \textcolor{comment}{//Free previously allocated memory block}
509    \hyperlink{net__mem_8c_aa33fc4dd2a71649194052f297c707d08}{netBufferFree}(buffer);
510    \textcolor{comment}{//Return status code}
511    \textcolor{keywordflow}{return} error;
512 \}
\end{DoxyCode}
\mbox{\Hypertarget{raw__socket_8h_ad2549c2b0b0ee5cdab3fb45dbb5770d4}\label{raw__socket_8h_ad2549c2b0b0ee5cdab3fb45dbb5770d4}} 
\index{raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}!raw\+Socket\+Update\+Events@{raw\+Socket\+Update\+Events}}
\index{raw\+Socket\+Update\+Events@{raw\+Socket\+Update\+Events}!raw\+\_\+socket.\+h@{raw\+\_\+socket.\+h}}
\subsubsection{\texorpdfstring{raw\+Socket\+Update\+Events()}{rawSocketUpdateEvents()}}
{\footnotesize\ttfamily void raw\+Socket\+Update\+Events (\begin{DoxyParamCaption}\item[{\hyperlink{socket_8h_aa85acfb0fa336ef495e6ba87fb88fc48}{Socket} $\ast$}]{socket }\end{DoxyParamCaption})}



Update event state for raw sockets. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em socket} & Handle referencing the socket \\
\hline
\end{DoxyParams}


Definition at line 780 of file raw\+\_\+socket.\+c.


\begin{DoxyCode}
781 \{
782    \textcolor{comment}{//Clear event flags}
783    \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventFlags = 0;
784 
785    \textcolor{comment}{//The socket is marked as readable if a datagram is pending in the queue}
786    \textcolor{keywordflow}{if}(\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->receiveQueue)
787       \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventFlags |= \hyperlink{socket_8h_add8a4c36456f478ab23bd4372aebde6ea72985d7e82625f037ca8a6734f49996c}{SOCKET\_EVENT\_RX\_READY};
788 
789    \textcolor{comment}{//Check whether the socket is bound to a particular network interface}
790    \textcolor{keywordflow}{if}(\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->interface != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
791    \{
792       \textcolor{comment}{//Handle link up and link down events}
793       \textcolor{keywordflow}{if}(\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->interface->linkState)
794          \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventFlags |= \hyperlink{socket_8h_add8a4c36456f478ab23bd4372aebde6eafe461e492995403ea5964dd740210c2e}{SOCKET\_EVENT\_LINK\_UP};
795       \textcolor{keywordflow}{else}
796          \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventFlags |= \hyperlink{socket_8h_add8a4c36456f478ab23bd4372aebde6eab971918883e240c24d301f7eb44f08cd}{SOCKET\_EVENT\_LINK\_DOWN};
797    \}
798 
799    \textcolor{comment}{//Mask unused events}
800    \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventFlags &= \hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventMask;
801 
802    \textcolor{comment}{//Any event to signal?}
803    \textcolor{keywordflow}{if}(\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->eventFlags)
804    \{
805       \textcolor{comment}{//Unblock I/O operations currently in waiting state}
806       \hyperlink{os__port__chibios_8c_afc1d64fc90afbf03baecfa636bb99ff7}{osSetEvent}(&\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->event);
807 
808       \textcolor{comment}{//Set user event to signaled state if necessary}
809       \textcolor{keywordflow}{if}(\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->userEvent != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
810          \hyperlink{os__port__chibios_8c_afc1d64fc90afbf03baecfa636bb99ff7}{osSetEvent}(\hyperlink{bsd__socket_8c_a3f8f3a2707fbc87fc30aa70f31f53218}{socket}->userEvent);
811    \}
812 \}
\end{DoxyCode}
