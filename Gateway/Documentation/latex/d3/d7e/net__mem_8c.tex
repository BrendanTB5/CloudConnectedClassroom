\hypertarget{net__mem_8c}{}\section{cyclone\+\_\+tcp/core/net\+\_\+mem.c File Reference}
\label{net__mem_8c}\index{cyclone\+\_\+tcp/core/net\+\_\+mem.\+c@{cyclone\+\_\+tcp/core/net\+\_\+mem.\+c}}


Memory management.  


{\ttfamily \#include \char`\"{}core/net.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}core/net\+\_\+mem.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}debug.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{net__mem_8c_afcdf5e66fd927a7f4cc64295acd20407}{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}~\hyperlink{net__config_8h_abeffca95d471585bfe42d56f517d2058}{M\+E\+M\+\_\+\+T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}
\item 
\#define \hyperlink{net__mem_8c_a719744462ec02b8b1a2fa29a15808264}{M\+A\+X\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+O\+U\+NT}~(\hyperlink{net__mem_8h_a5d7f6248b8dd365190e7562d4e14a4f3}{N}(\hyperlink{os__port_8h_afa99ec4acc4ecb2dc3c2d05da15d0e3f}{M\+AX}(\hyperlink{net__config_8h_a3f9a052384f25fdf9c6f5c32cb32e9ce}{I\+P\+V4\+\_\+\+M\+A\+X\+\_\+\+F\+R\+A\+G\+\_\+\+D\+A\+T\+A\+G\+R\+A\+M\+\_\+\+S\+I\+ZE}, \hyperlink{net__config_8h_ac016101236364e74fc7e0729bf2d8d16}{I\+P\+V6\+\_\+\+M\+A\+X\+\_\+\+F\+R\+A\+G\+\_\+\+D\+A\+T\+A\+G\+R\+A\+M\+\_\+\+S\+I\+ZE})) + 3)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{net__mem_8c_a0c7065e3d9c41e36d2b0f3411269578c}{mem\+Pool\+Init} (void)
\begin{DoxyCompactList}\small\item\em Memory pool initialization. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{net__mem_8c_abe64a91cd872768817509cc08eed6689}{mem\+Pool\+Alloc} (size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Allocate a memory block. \end{DoxyCompactList}\item 
void \hyperlink{net__mem_8c_a5e8a514f3dfcb35008de9beb39bcdcde}{mem\+Pool\+Free} (void $\ast$\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p})
\begin{DoxyCompactList}\small\item\em Release a memory block. \end{DoxyCompactList}\item 
void \hyperlink{net__mem_8c_a721162a208000371888501ea0389f333}{mem\+Pool\+Get\+Stats} (\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} $\ast$current\+Usage, \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} $\ast$max\+Usage, \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} $\ast$size)
\begin{DoxyCompactList}\small\item\em Get memory pool usage. \end{DoxyCompactList}\item 
\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$ \hyperlink{net__mem_8c_a986c9991e530e99528faa4c43efadc6f}{net\+Buffer\+Alloc} (size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Allocate a multi-\/part buffer. \end{DoxyCompactList}\item 
void \hyperlink{net__mem_8c_aa33fc4dd2a71649194052f297c707d08}{net\+Buffer\+Free} (\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Dispose a multi-\/part buffer. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{net__mem_8c_ac9dbcd9e28e61d8f4f6d2e9af2607b68}{net\+Buffer\+Get\+Length} (const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Get the actual length of a multi-\/part buffer. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{net__mem_8c_ac0a46f396754e069dd1ee65cdc559b28}{net\+Buffer\+Set\+Length} (\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$buffer, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Adjust the length of a multi-\/part buffer. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{net__mem_8c_a20d30c9db547b3b2743368b589cf482b}{net\+Buffer\+At} (const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$buffer, size\+\_\+t \hyperlink{pic32mz_2isr__support_8h_ac0542d92dfcd62c19170fd963f9e5052}{offset})
\begin{DoxyCompactList}\small\item\em Returns a pointer to the data at the specified position. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{net__mem_8c_aba4fe2d850142e40a9a668afeb2a0c8a}{net\+Buffer\+Concat} (\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$dest, const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$src, size\+\_\+t src\+Offset, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Concatenate two multi-\/part buffers. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{net__mem_8c_a553a02631efd217192800ad3cdf9bbba}{net\+Buffer\+Copy} (\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$dest, size\+\_\+t dest\+Offset, const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$src, size\+\_\+t src\+Offset, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Copy data between multi-\/part buffers. \end{DoxyCompactList}\item 
\hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} \hyperlink{net__mem_8c_aceae1188a93321e1d4daed11bb8005df}{net\+Buffer\+Append} (\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$dest, const void $\ast$src, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Append data a multi-\/part buffer. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{net__mem_8c_a977e79aab71b4b39772ff8256abb8b55}{net\+Buffer\+Write} (\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$dest, size\+\_\+t dest\+Offset, const void $\ast$src, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Write data to a multi-\/part buffer. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{net__mem_8c_af3ed1bc3f7d55f830cbbe6aa12e61af0}{net\+Buffer\+Read} (void $\ast$dest, const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$src, size\+\_\+t src\+Offset, size\+\_\+t \hyperlink{ppp_8h_ab2b3adeb2a67e656ff030b56727fd0ac}{length})
\begin{DoxyCompactList}\small\item\em Read data from a multi-\/part buffer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{structOsMutex}{Os\+Mutex} \hyperlink{net__mem_8c_a0a048e1478fe2bef7ad3219a1e8f477a}{mem\+Pool\+Mutex}
\item 
static \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} \hyperlink{net__mem_8c_ae9e0f60959c4354bb1de17b1f225efe0}{mem\+Pool} \mbox{[}\hyperlink{net__mem_8h_ac7239e39563611040763402dac4d640b}{N\+E\+T\+\_\+\+M\+E\+M\+\_\+\+P\+O\+O\+L\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+C\+O\+U\+NT}\mbox{]}\mbox{[}\hyperlink{net__mem_8h_a8870c81bed70c77d981277a24c0174bc}{N\+E\+T\+\_\+\+M\+E\+M\+\_\+\+P\+O\+O\+L\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}\mbox{]}
\item 
static \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} \hyperlink{net__mem_8c_a7f25b4c3e8950cca5cf7ee28caedf037}{mem\+Pool\+Alloc\+Table} \mbox{[}\hyperlink{net__mem_8h_ac7239e39563611040763402dac4d640b}{N\+E\+T\+\_\+\+M\+E\+M\+\_\+\+P\+O\+O\+L\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+C\+O\+U\+NT}\mbox{]}
\item 
\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} \hyperlink{net__mem_8c_a8104bc3ab6ec936da2fec0ab3a651821}{mem\+Pool\+Current\+Usage}
\item 
\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} \hyperlink{net__mem_8c_ad61bc6e030d82b6add827fa5d5e8f060}{mem\+Pool\+Max\+Usage}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Memory management. 

\hypertarget{pic32mz__ef__curiosity_8h_License}{}\subsection{License}\label{pic32mz__ef__curiosity_8h_License}
S\+P\+D\+X-\/\+License-\/\+Identifier\+: G\+P\+L-\/2.\+0-\/or-\/later

Copyright (C) 2010-\/2019 Oryx Embedded S\+A\+RL. All rights reserved.

This file is part of Cyclone\+T\+CP Open.

This program is free software; you can redistribute it and/or modify it under the terms of the G\+NU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but W\+I\+T\+H\+O\+UT A\+NY W\+A\+R\+R\+A\+N\+TY; without even the implied warranty of M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY or F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE. See the G\+NU General Public License for more details.

You should have received a copy of the G\+NU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-\/1301, U\+SA.

\begin{DoxyAuthor}{Author}
Oryx Embedded S\+A\+RL (www.\+oryx-\/embedded.\+com) 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+9.\+6 
\end{DoxyVersion}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{net__mem_8c_a719744462ec02b8b1a2fa29a15808264}\label{net__mem_8c_a719744462ec02b8b1a2fa29a15808264}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!M\+A\+X\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+O\+U\+NT@{M\+A\+X\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+O\+U\+NT}}
\index{M\+A\+X\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+O\+U\+NT@{M\+A\+X\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+O\+U\+NT}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{M\+A\+X\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+O\+U\+NT}{MAX\_CHUNK\_COUNT}}
{\footnotesize\ttfamily \#define M\+A\+X\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+O\+U\+NT~(\hyperlink{net__mem_8h_a5d7f6248b8dd365190e7562d4e14a4f3}{N}(\hyperlink{os__port_8h_afa99ec4acc4ecb2dc3c2d05da15d0e3f}{M\+AX}(\hyperlink{net__config_8h_a3f9a052384f25fdf9c6f5c32cb32e9ce}{I\+P\+V4\+\_\+\+M\+A\+X\+\_\+\+F\+R\+A\+G\+\_\+\+D\+A\+T\+A\+G\+R\+A\+M\+\_\+\+S\+I\+ZE}, \hyperlink{net__config_8h_ac016101236364e74fc7e0729bf2d8d16}{I\+P\+V6\+\_\+\+M\+A\+X\+\_\+\+F\+R\+A\+G\+\_\+\+D\+A\+T\+A\+G\+R\+A\+M\+\_\+\+S\+I\+ZE})) + 3)}



Definition at line 41 of file net\+\_\+mem.\+c.

\mbox{\Hypertarget{net__mem_8c_afcdf5e66fd927a7f4cc64295acd20407}\label{net__mem_8c_afcdf5e66fd927a7f4cc64295acd20407}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL@{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}}
\index{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL@{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}{TRACE\_LEVEL}}
{\footnotesize\ttfamily \#define T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL~\hyperlink{net__config_8h_abeffca95d471585bfe42d56f517d2058}{M\+E\+M\+\_\+\+T\+R\+A\+C\+E\+\_\+\+L\+E\+V\+EL}}



Definition at line 32 of file net\+\_\+mem.\+c.



\subsection{Function Documentation}
\mbox{\Hypertarget{net__mem_8c_abe64a91cd872768817509cc08eed6689}\label{net__mem_8c_abe64a91cd872768817509cc08eed6689}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool\+Alloc@{mem\+Pool\+Alloc}}
\index{mem\+Pool\+Alloc@{mem\+Pool\+Alloc}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool\+Alloc()}{memPoolAlloc()}}
{\footnotesize\ttfamily void$\ast$ mem\+Pool\+Alloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Allocate a memory block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em size} & Bytes to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the allocated space or N\+U\+LL if there is insufficient memory available 
\end{DoxyReturn}


Definition at line 100 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
101 \{
102 \textcolor{preprocessor}{#if (NET\_MEM\_POOL\_SUPPORT == ENABLED)}
103    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
104 \textcolor{preprocessor}{#endif}
105 
106    \textcolor{comment}{//Pointer to the allocated memory block}
107    \textcolor{keywordtype}{void} *\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
108 
109    \textcolor{comment}{//Debug message}
110    \hyperlink{debug_8h_a67a8f9bc74358aa21745a76e23768dae}{TRACE\_DEBUG}(\textcolor{stringliteral}{"Allocating %"} \hyperlink{compiler__port_8h_a2b7b0557dc6cd786df02dafbb51f5292}{PRIuSIZE} \textcolor{stringliteral}{" bytes...\(\backslash\)r\(\backslash\)n"}, size);
111 
112 \textcolor{comment}{//Use fixed-size blocks allocation?}
113 \textcolor{preprocessor}{#if (NET\_MEM\_POOL\_SUPPORT == ENABLED)}
114    \textcolor{comment}{//Acquire exclusive access to the memory pool}
115    \hyperlink{os__port__chibios_8c_a58485224df4bfa522246d55b35bbd83a}{osAcquireMutex}(&\hyperlink{net__mem_8c_a0a048e1478fe2bef7ad3219a1e8f477a}{memPoolMutex});
116 
117    \textcolor{comment}{//Enforce block size}
118    \textcolor{keywordflow}{if}(size <= \hyperlink{net__mem_8h_a8870c81bed70c77d981277a24c0174bc}{NET\_MEM\_POOL\_BUFFER\_SIZE})
119    \{
120       \textcolor{comment}{//Loop through allocation table}
121       \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net__mem_8h_ac7239e39563611040763402dac4d640b}{NET\_MEM\_POOL\_BUFFER\_COUNT}; i++)
122       \{
123          \textcolor{comment}{//Check whether the current block is free}
124          \textcolor{keywordflow}{if}(!\hyperlink{net__mem_8c_a7f25b4c3e8950cca5cf7ee28caedf037}{memPoolAllocTable}[i])
125          \{
126             \textcolor{comment}{//Mark the current entry as used}
127             \hyperlink{net__mem_8c_a7f25b4c3e8950cca5cf7ee28caedf037}{memPoolAllocTable}[i] = \hyperlink{os__port_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE};
128             \textcolor{comment}{//Point to the corresponding memory block}
129             p = \hyperlink{net__mem_8c_ae9e0f60959c4354bb1de17b1f225efe0}{memPool}[i];
130 
131             \textcolor{comment}{//Update statistics}
132             \hyperlink{net__mem_8c_a8104bc3ab6ec936da2fec0ab3a651821}{memPoolCurrentUsage}++;
133             \textcolor{comment}{//Maximum number of buffers that have been allocated so far}
134             \hyperlink{net__mem_8c_ad61bc6e030d82b6add827fa5d5e8f060}{memPoolMaxUsage} = \hyperlink{os__port_8h_afa99ec4acc4ecb2dc3c2d05da15d0e3f}{MAX}(\hyperlink{net__mem_8c_a8104bc3ab6ec936da2fec0ab3a651821}{memPoolCurrentUsage}, 
      \hyperlink{net__mem_8c_ad61bc6e030d82b6add827fa5d5e8f060}{memPoolMaxUsage});
135 
136             \textcolor{comment}{//Exit immediately}
137             \textcolor{keywordflow}{break};
138          \}
139       \}
140    \}
141 
142    \textcolor{comment}{//Release exclusive access to the memory pool}
143    \hyperlink{os__port__chibios_8c_a8e10e5b2c6d3877b5ba60e375ac45d79}{osReleaseMutex}(&\hyperlink{net__mem_8c_a0a048e1478fe2bef7ad3219a1e8f477a}{memPoolMutex});
144 \textcolor{preprocessor}{#else}
145    \textcolor{comment}{//Allocate a memory block}
146    p = \hyperlink{os__port__chibios_8c_ae86758dcd9fc3c98247ae19815987c9a}{osAllocMem}(size);
147 \textcolor{preprocessor}{#endif}
148 
149    \textcolor{comment}{//Failed to allocate memory?}
150    \textcolor{keywordflow}{if}(!p)
151    \{
152       \textcolor{comment}{//Debug message}
153       \hyperlink{debug_8h_a72b9761add7486364dba449091cd2579}{TRACE\_WARNING}(\textcolor{stringliteral}{"Memory allocation failed!\(\backslash\)r\(\backslash\)n"});
154    \}
155 
156    \textcolor{comment}{//Return a pointer to the allocated memory block}
157    \textcolor{keywordflow}{return} \hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
158 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_a5e8a514f3dfcb35008de9beb39bcdcde}\label{net__mem_8c_a5e8a514f3dfcb35008de9beb39bcdcde}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool\+Free@{mem\+Pool\+Free}}
\index{mem\+Pool\+Free@{mem\+Pool\+Free}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool\+Free()}{memPoolFree()}}
{\footnotesize\ttfamily void mem\+Pool\+Free (\begin{DoxyParamCaption}\item[{void $\ast$}]{p }\end{DoxyParamCaption})}



Release a memory block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em p} & Previously allocated memory block to be freed \\
\hline
\end{DoxyParams}


Definition at line 166 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
167 \{
168 \textcolor{comment}{//Use fixed-size blocks allocation?}
169 \textcolor{preprocessor}{#if (NET\_MEM\_POOL\_SUPPORT == ENABLED)}
170    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
171 
172    \textcolor{comment}{//Acquire exclusive access to the memory pool}
173    \hyperlink{os__port__chibios_8c_a58485224df4bfa522246d55b35bbd83a}{osAcquireMutex}(&\hyperlink{net__mem_8c_a0a048e1478fe2bef7ad3219a1e8f477a}{memPoolMutex});
174 
175    \textcolor{comment}{//Loop through allocation table}
176    \textcolor{keywordflow}{for}(i = 0; i < \hyperlink{net__mem_8h_ac7239e39563611040763402dac4d640b}{NET\_MEM\_POOL\_BUFFER\_COUNT}; i++)
177    \{
178       \textcolor{keywordflow}{if}(\hyperlink{net__mem_8c_ae9e0f60959c4354bb1de17b1f225efe0}{memPool}[i] == \hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p})
179       \{
180          \textcolor{comment}{//Mark the current block as free}
181          \hyperlink{net__mem_8c_a7f25b4c3e8950cca5cf7ee28caedf037}{memPoolAllocTable}[i] = \hyperlink{os__port_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE};
182 
183          \textcolor{comment}{//Update statistics}
184          \hyperlink{net__mem_8c_a8104bc3ab6ec936da2fec0ab3a651821}{memPoolCurrentUsage}--;
185 
186          \textcolor{comment}{//Exit immediately}
187          \textcolor{keywordflow}{break};
188       \}
189    \}
190 
191    \textcolor{comment}{//Release exclusive access to the memory pool}
192    \hyperlink{os__port__chibios_8c_a8e10e5b2c6d3877b5ba60e375ac45d79}{osReleaseMutex}(&\hyperlink{net__mem_8c_a0a048e1478fe2bef7ad3219a1e8f477a}{memPoolMutex});
193 \textcolor{preprocessor}{#else}
194    \textcolor{comment}{//Release memory block}
195    \hyperlink{os__port__chibios_8c_a68e4fa4326f2031eab28b92a25f2d68d}{osFreeMem}(\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p});
196 \textcolor{preprocessor}{#endif}
197 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_a721162a208000371888501ea0389f333}\label{net__mem_8c_a721162a208000371888501ea0389f333}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool\+Get\+Stats@{mem\+Pool\+Get\+Stats}}
\index{mem\+Pool\+Get\+Stats@{mem\+Pool\+Get\+Stats}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool\+Get\+Stats()}{memPoolGetStats()}}
{\footnotesize\ttfamily void mem\+Pool\+Get\+Stats (\begin{DoxyParamCaption}\item[{\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} $\ast$}]{current\+Usage,  }\item[{\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} $\ast$}]{max\+Usage,  }\item[{\hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} $\ast$}]{size }\end{DoxyParamCaption})}



Get memory pool usage. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em current\+Usage} & Number of buffers currently allocated \\
\hline
\mbox{\tt out}  & {\em max\+Usage} & Maximum number of buffers that have been allocated so far \\
\hline
\mbox{\tt out}  & {\em size} & Total number of buffers in the memory pool \\
\hline
\end{DoxyParams}


Definition at line 207 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
208 \{
209 \textcolor{comment}{//Use fixed-size blocks allocation?}
210 \textcolor{preprocessor}{#if (NET\_MEM\_POOL\_SUPPORT == ENABLED)}
211    \textcolor{comment}{//Number of buffers currently allocated}
212    \textcolor{keywordflow}{if}(currentUsage != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
213       *currentUsage = \hyperlink{net__mem_8c_a8104bc3ab6ec936da2fec0ab3a651821}{memPoolCurrentUsage};
214 
215    \textcolor{comment}{//Maximum number of buffers that have been allocated so far}
216    \textcolor{keywordflow}{if}(maxUsage != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
217       *maxUsage = \hyperlink{net__mem_8c_ad61bc6e030d82b6add827fa5d5e8f060}{memPoolMaxUsage};
218 
219    \textcolor{comment}{//Total number of buffers in the memory pool}
220    \textcolor{keywordflow}{if}(size != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
221       *size = \hyperlink{net__mem_8h_ac7239e39563611040763402dac4d640b}{NET\_MEM\_POOL\_BUFFER\_COUNT};
222 \textcolor{preprocessor}{#else}
223    \textcolor{comment}{//Memory pool is not used...}
224    \textcolor{keywordflow}{if}(currentUsage != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
225       *currentUsage = 0;
226 
227    \textcolor{keywordflow}{if}(maxUsage != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
228       *maxUsage = 0;
229 
230    \textcolor{keywordflow}{if}(size != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
231       *size = 0;
232 \textcolor{preprocessor}{#endif}
233 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_a0c7065e3d9c41e36d2b0f3411269578c}\label{net__mem_8c_a0c7065e3d9c41e36d2b0f3411269578c}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool\+Init@{mem\+Pool\+Init}}
\index{mem\+Pool\+Init@{mem\+Pool\+Init}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool\+Init()}{memPoolInit()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} mem\+Pool\+Init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Memory pool initialization. 

\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 70 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
71 \{
72 \textcolor{comment}{//Use fixed-size blocks allocation?}
73 \textcolor{preprocessor}{#if (NET\_MEM\_POOL\_SUPPORT == ENABLED)}
74    \textcolor{comment}{//Create a mutex to prevent simultaneous access to the memory pool}
75    \textcolor{keywordflow}{if}(!\hyperlink{os__port__chibios_8c_a16627f901c807c29adf29a38fb1af16a}{osCreateMutex}(&\hyperlink{net__mem_8c_a0a048e1478fe2bef7ad3219a1e8f477a}{memPoolMutex}))
76    \{
77       \textcolor{comment}{//Failed to create mutex}
78       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689ca528efe91b7a7e4bcc9a6de7d4b778c67}{ERROR\_OUT\_OF\_RESOURCES};
79    \}
80 
81    \textcolor{comment}{//Clear allocation table}
82    memset(\hyperlink{net__mem_8c_a7f25b4c3e8950cca5cf7ee28caedf037}{memPoolAllocTable}, 0, \textcolor{keyword}{sizeof}(\hyperlink{net__mem_8c_a7f25b4c3e8950cca5cf7ee28caedf037}{memPoolAllocTable}));
83 
84    \textcolor{comment}{//Clear statistics}
85    \hyperlink{net__mem_8c_a8104bc3ab6ec936da2fec0ab3a651821}{memPoolCurrentUsage} = 0;
86    \hyperlink{net__mem_8c_ad61bc6e030d82b6add827fa5d5e8f060}{memPoolMaxUsage} = 0;
87 \textcolor{preprocessor}{#endif}
88 
89    \textcolor{comment}{//Successful initialization}
90    \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cabf350750d0d4fabd8954c0f1e9bbae94}{NO\_ERROR};
91 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_a986c9991e530e99528faa4c43efadc6f}\label{net__mem_8c_a986c9991e530e99528faa4c43efadc6f}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Alloc@{net\+Buffer\+Alloc}}
\index{net\+Buffer\+Alloc@{net\+Buffer\+Alloc}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Alloc()}{netBufferAlloc()}}
{\footnotesize\ttfamily \hyperlink{structNetBuffer}{Net\+Buffer}$\ast$ net\+Buffer\+Alloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Allocate a multi-\/part buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em length} & Desired length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the allocated buffer or N\+U\+LL if there is insufficient memory available 
\end{DoxyReturn}


Definition at line 243 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
244 \{
245    \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\_t} error;
246    \hyperlink{structNetBuffer}{NetBuffer} *buffer;
247 
248    \textcolor{comment}{//Allocate memory to hold the multi-part buffer}
249    buffer = \hyperlink{net__mem_8c_abe64a91cd872768817509cc08eed6689}{memPoolAlloc}(\hyperlink{net__mem_8h_a8870c81bed70c77d981277a24c0174bc}{NET\_MEM\_POOL\_BUFFER\_SIZE});
250    \textcolor{comment}{//Failed to allocate memory?}
251    \textcolor{keywordflow}{if}(buffer == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})
252       \textcolor{keywordflow}{return} \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
253 
254    \textcolor{comment}{//The multi-part buffer consists of a single chunk}
255    buffer->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount} = 1;
256    buffer->\hyperlink{structNetBuffer_a6c71e1c9f8122aa63841d14b2a426734}{maxChunkCount} = \hyperlink{net__mem_8c_a719744462ec02b8b1a2fa29a15808264}{MAX\_CHUNK\_COUNT};
257    buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[0].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) buffer + 
      \hyperlink{net__mem_8h_a488f69000a2152fc12831cb7ed05d6da}{CHUNKED\_BUFFER\_HEADER\_SIZE};
258    buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[0].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = \hyperlink{net__mem_8h_a8870c81bed70c77d981277a24c0174bc}{NET\_MEM\_POOL\_BUFFER\_SIZE} - 
      \hyperlink{net__mem_8h_a488f69000a2152fc12831cb7ed05d6da}{CHUNKED\_BUFFER\_HEADER\_SIZE};
259    buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[0].\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} = 0;
260 
261    \textcolor{comment}{//Adjust the length of the buffer}
262    error = \hyperlink{net__mem_8c_ac0a46f396754e069dd1ee65cdc559b28}{netBufferSetLength}(buffer, \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length});
263    \textcolor{comment}{//Any error to report?}
264    \textcolor{keywordflow}{if}(error)
265    \{
266       \textcolor{comment}{//Clean up side effects}
267       \hyperlink{net__mem_8c_aa33fc4dd2a71649194052f297c707d08}{netBufferFree}(buffer);
268       \textcolor{comment}{//Report an failure}
269       \textcolor{keywordflow}{return} \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
270    \}
271 
272    \textcolor{comment}{//Successful memory allocation}
273    \textcolor{keywordflow}{return} buffer;
274 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_aceae1188a93321e1d4daed11bb8005df}\label{net__mem_8c_aceae1188a93321e1d4daed11bb8005df}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Append@{net\+Buffer\+Append}}
\index{net\+Buffer\+Append@{net\+Buffer\+Append}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Append()}{netBufferAppend()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} net\+Buffer\+Append (\begin{DoxyParamCaption}\item[{\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{dest,  }\item[{const void $\ast$}]{src,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Append data a multi-\/part buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em dest} & Pointer to a multi-\/part buffer \\
\hline
\mbox{\tt in}  & {\em src} & User buffer containing the data to be appended \\
\hline
\mbox{\tt in}  & {\em length} & Number of bytes in the user buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 586 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
587 \{
588    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
589 
590    \textcolor{comment}{//Make sure there is enough space to add an extra chunk}
591    \textcolor{keywordflow}{if}(dest->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount} >= dest->\hyperlink{structNetBuffer_a6c71e1c9f8122aa63841d14b2a426734}{maxChunkCount})
592       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cae9be6449970fca5714ab9957b16562a5}{ERROR\_FAILURE};
593 
594    \textcolor{comment}{//Position to the end of the buffer}
595    i = dest->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount};
596 
597    \textcolor{comment}{//Insert a new chunk at the end of the list}
598    dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} = (\textcolor{keywordtype}{void} *) src;
599    dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
600    dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} = 0;
601 
602    \textcolor{comment}{//Increment the number of chunks}
603    dest->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount}++;
604 
605    \textcolor{comment}{//Successful processing}
606    \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cabf350750d0d4fabd8954c0f1e9bbae94}{NO\_ERROR};
607 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_a20d30c9db547b3b2743368b589cf482b}\label{net__mem_8c_a20d30c9db547b3b2743368b589cf482b}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+At@{net\+Buffer\+At}}
\index{net\+Buffer\+At@{net\+Buffer\+At}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+At()}{netBufferAt()}}
{\footnotesize\ttfamily void$\ast$ net\+Buffer\+At (\begin{DoxyParamCaption}\item[{const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{buffer,  }\item[{size\+\_\+t}]{offset }\end{DoxyParamCaption})}



Returns a pointer to the data at the specified position. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em buffer} & Pointer to a multi-\/part buffer \\
\hline
\mbox{\tt in}  & {\em offset} & Offset from the beginning of the buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer the data at the specified position 
\end{DoxyReturn}


Definition at line 413 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
414 \{
415    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
416 
417    \textcolor{comment}{//Loop through data chunks}
418    \textcolor{keywordflow}{for}(i = 0; i < buffer->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount}; i++)
419    \{
420       \textcolor{comment}{//The data at the specified offset resides in the current chunk?}
421       \textcolor{keywordflow}{if}(offset < buffer->chunk[i].\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length})
422          \textcolor{keywordflow}{return} (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} + \hyperlink{pic32mz_2isr__support_8h_a12a5aed8a193ebbf9a641104a310610d}{offset};
423 
424       \textcolor{comment}{//Jump to the next chunk}
425       \hyperlink{pic32mz_2isr__support_8h_a12a5aed8a193ebbf9a641104a310610d}{offset} -= buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
426    \}
427 
428    \textcolor{comment}{//Invalid offset...}
429    \textcolor{keywordflow}{return} \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
430 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_aba4fe2d850142e40a9a668afeb2a0c8a}\label{net__mem_8c_aba4fe2d850142e40a9a668afeb2a0c8a}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Concat@{net\+Buffer\+Concat}}
\index{net\+Buffer\+Concat@{net\+Buffer\+Concat}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Concat()}{netBufferConcat()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} net\+Buffer\+Concat (\begin{DoxyParamCaption}\item[{\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{dest,  }\item[{const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{src,  }\item[{size\+\_\+t}]{src\+Offset,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Concatenate two multi-\/part buffers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em dest} & Pointer to the destination buffer \\
\hline
\mbox{\tt in}  & {\em src} & Pointer to the source buffer \\
\hline
\mbox{\tt in}  & {\em src\+Offset} & Read offset \\
\hline
\mbox{\tt in}  & {\em length} & Number of bytes to read from the source buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 442 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
444 \{
445    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
446    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} j;
447 
448    \textcolor{comment}{//Skip the beginning of the source data}
449    \textcolor{keywordflow}{for}(j = 0; j < src->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount}; j++)
450    \{
451       \textcolor{comment}{//The data at the specified offset resides in the current chunk?}
452       \textcolor{keywordflow}{if}(srcOffset < src->chunk[j].\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length})
453          \textcolor{keywordflow}{break};
454 
455       \textcolor{comment}{//Jump to the next chunk}
456       srcOffset -= src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[j].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
457    \}
458 
459    \textcolor{comment}{//Invalid offset?}
460    \textcolor{keywordflow}{if}(j >= src->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount})
461       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689caeae4b12e06d727d085f75f79a820f2e8}{ERROR\_INVALID\_PARAMETER};
462 
463    \textcolor{comment}{//Position to the end of the destination data}
464    i = dest->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount};
465 
466    \textcolor{comment}{//Copy data blocks}
467    \textcolor{keywordflow}{while}(\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} > 0 && i < dest->maxChunkCount && j < src->chunkCount)
468    \{
469       \textcolor{comment}{//Copy current block}
470       dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[j].
      \hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} + srcOffset;
471       dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[j].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} - srcOffset;
472       dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} = 0;
473 
474       \textcolor{comment}{//Limit the number of bytes to copy}
475       \textcolor{keywordflow}{if}(length < dest->chunk[i].length)
476          dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
477 
478       \textcolor{comment}{//Decrement the number of remaining bytes}
479       \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} -= dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
480       \textcolor{comment}{//Increment the number of chunks}
481       dest->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount}++;
482 
483       \textcolor{comment}{//Adjust variables}
484       srcOffset = 0;
485       i++;
486       j++;
487    \}
488 
489    \textcolor{comment}{//Return status code}
490    \textcolor{keywordflow}{return} (\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} > 0) ? \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cae9be6449970fca5714ab9957b16562a5}{ERROR\_FAILURE} : \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cabf350750d0d4fabd8954c0f1e9bbae94}{NO\_ERROR};
491 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_a553a02631efd217192800ad3cdf9bbba}\label{net__mem_8c_a553a02631efd217192800ad3cdf9bbba}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Copy@{net\+Buffer\+Copy}}
\index{net\+Buffer\+Copy@{net\+Buffer\+Copy}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Copy()}{netBufferCopy()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} net\+Buffer\+Copy (\begin{DoxyParamCaption}\item[{\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{dest,  }\item[{size\+\_\+t}]{dest\+Offset,  }\item[{const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{src,  }\item[{size\+\_\+t}]{src\+Offset,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Copy data between multi-\/part buffers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em dest} & Pointer to the destination buffer \\
\hline
\mbox{\tt in}  & {\em dest\+Offset} & Write offset \\
\hline
\mbox{\tt in}  & {\em src} & Pointer to the source buffer \\
\hline
\mbox{\tt in}  & {\em src\+Offset} & Read offset \\
\hline
\mbox{\tt in}  & {\em length} & Number of bytes to be copied \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 504 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
506 \{
507    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
508    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} j;
509    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
510    \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
511    \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *q;
512 
513    \textcolor{comment}{//Skip the beginning of the source data}
514    \textcolor{keywordflow}{for}(i = 0; i < dest->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount}; i++)
515    \{
516       \textcolor{comment}{//The data at the specified offset resides in the current chunk?}
517       \textcolor{keywordflow}{if}(destOffset < dest->chunk[i].\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length})
518          \textcolor{keywordflow}{break};
519 
520       \textcolor{comment}{//Jump to the next chunk}
521       destOffset -= dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
522    \}
523 
524    \textcolor{comment}{//Invalid offset?}
525    \textcolor{keywordflow}{if}(i >= dest->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount})
526       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689caeae4b12e06d727d085f75f79a820f2e8}{ERROR\_INVALID\_PARAMETER};
527 
528    \textcolor{comment}{//Skip the beginning of the source data}
529    \textcolor{keywordflow}{for}(j = 0; j < src->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount}; j++)
530    \{
531       \textcolor{comment}{//The data at the specified offset resides in the current chunk?}
532       \textcolor{keywordflow}{if}(srcOffset < src->chunk[j].\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length})
533          \textcolor{keywordflow}{break};
534 
535       \textcolor{comment}{//Jump to the next chunk}
536       srcOffset -= src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[j].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
537    \}
538 
539    \textcolor{comment}{//Invalid offset?}
540    \textcolor{keywordflow}{if}(j >= src->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount})
541       \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689caeae4b12e06d727d085f75f79a820f2e8}{ERROR\_INVALID\_PARAMETER};
542 
543    \textcolor{keywordflow}{while}(\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} > 0 && i < dest->chunkCount && j < src->chunkCount)
544    \{
545       \textcolor{comment}{//Point to the first data byte}
546       p = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} + destOffset;
547       q = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[j].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} + srcOffset;
548 
549       \textcolor{comment}{//Compute the number of bytes to copy}
550       n = \hyperlink{os__port_8h_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length}, dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} - destOffset);
551       n = \hyperlink{os__port_8h_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(n, src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[j].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} - srcOffset);
552 
553       \textcolor{comment}{//Copy data}
554       memcpy(p, q, n);
555 
556       destOffset += \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
557       srcOffset += \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
558       \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} -= \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
559 
560       \textcolor{keywordflow}{if}(destOffset >= dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length})
561       \{
562          destOffset = 0;
563          i++;
564       \}
565 
566       \textcolor{keywordflow}{if}(srcOffset >= src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[j].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length})
567       \{
568          srcOffset = 0;
569          j++;
570       \}
571    \}
572 
573    \textcolor{comment}{//Return status code}
574    \textcolor{keywordflow}{return} (\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} > 0) ? \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cae9be6449970fca5714ab9957b16562a5}{ERROR\_FAILURE} : \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cabf350750d0d4fabd8954c0f1e9bbae94}{NO\_ERROR};
575 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_aa33fc4dd2a71649194052f297c707d08}\label{net__mem_8c_aa33fc4dd2a71649194052f297c707d08}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Free@{net\+Buffer\+Free}}
\index{net\+Buffer\+Free@{net\+Buffer\+Free}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Free()}{netBufferFree()}}
{\footnotesize\ttfamily void net\+Buffer\+Free (\begin{DoxyParamCaption}\item[{\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{buffer }\end{DoxyParamCaption})}



Dispose a multi-\/part buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em buffer} & Pointer to the multi-\/part buffer to be released \\
\hline
\end{DoxyParams}


Definition at line 282 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
283 \{
284    \textcolor{comment}{//Properly dispose data chunks}
285    \hyperlink{net__mem_8c_ac0a46f396754e069dd1ee65cdc559b28}{netBufferSetLength}(buffer, 0);
286    \textcolor{comment}{//Release multi-part buffer}
287    \hyperlink{net__mem_8c_a5e8a514f3dfcb35008de9beb39bcdcde}{memPoolFree}(buffer);
288 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_ac9dbcd9e28e61d8f4f6d2e9af2607b68}\label{net__mem_8c_ac9dbcd9e28e61d8f4f6d2e9af2607b68}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Get\+Length@{net\+Buffer\+Get\+Length}}
\index{net\+Buffer\+Get\+Length@{net\+Buffer\+Get\+Length}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Get\+Length()}{netBufferGetLength()}}
{\footnotesize\ttfamily size\+\_\+t net\+Buffer\+Get\+Length (\begin{DoxyParamCaption}\item[{const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{buffer }\end{DoxyParamCaption})}



Get the actual length of a multi-\/part buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em buffer} & Pointer to a multi-\/part buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Actual length in bytes 
\end{DoxyReturn}


Definition at line 297 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
298 \{
299    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
300 
301    \textcolor{comment}{//Total length}
302    \textcolor{keywordtype}{size\_t} \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length} = 0;
303 
304    \textcolor{comment}{//Loop through data chunks}
305    \textcolor{keywordflow}{for}(i = 0; i < buffer->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount}; i++)
306       length += buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
307 
308    \textcolor{comment}{//Return total length}
309    \textcolor{keywordflow}{return} length;
310 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_af3ed1bc3f7d55f830cbbe6aa12e61af0}\label{net__mem_8c_af3ed1bc3f7d55f830cbbe6aa12e61af0}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Read@{net\+Buffer\+Read}}
\index{net\+Buffer\+Read@{net\+Buffer\+Read}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Read()}{netBufferRead()}}
{\footnotesize\ttfamily size\+\_\+t net\+Buffer\+Read (\begin{DoxyParamCaption}\item[{void $\ast$}]{dest,  }\item[{const \hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{src,  }\item[{size\+\_\+t}]{src\+Offset,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Read data from a multi-\/part buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em dest} & Pointer to the buffer where to return the data \\
\hline
\mbox{\tt in}  & {\em src} & Pointer to a multi-\/part buffer \\
\hline
\mbox{\tt in}  & {\em src\+Offset} & Offset from the beginning of the multi-\/part buffer \\
\hline
\mbox{\tt in}  & {\em length} & Number of bytes to copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Actual number of bytes copied 
\end{DoxyReturn}


Definition at line 672 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
674 \{
675    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
676    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
677    \textcolor{keywordtype}{size\_t} totalLength;
678    \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
679 
680    \textcolor{comment}{//Total number of bytes copied}
681    totalLength = 0;
682 
683    \textcolor{comment}{//Loop through data chunks}
684    \textcolor{keywordflow}{for}(i = 0; i < src->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount} && totalLength < \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length}; i++)
685    \{
686       \textcolor{comment}{//Is there any data to copy from the current chunk?}
687       \textcolor{keywordflow}{if}(srcOffset < src->chunk[i].length)
688       \{
689          \textcolor{comment}{//Point to the first byte to be read}
690          p = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} + srcOffset;
691          \textcolor{comment}{//Compute the number of bytes to copy at a time}
692          n = \hyperlink{os__port_8h_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(length - totalLength, src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} - srcOffset);
693 
694          \textcolor{comment}{//Copy data}
695          memcpy(dest, p, n);
696 
697          \textcolor{comment}{//Advance write pointer}
698          dest = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) dest + n;
699          \textcolor{comment}{//Total number of bytes copied}
700          totalLength += \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
701          \textcolor{comment}{//Process the next block from the start}
702          srcOffset = 0;
703       \}
704       \textcolor{keywordflow}{else}
705       \{
706          \textcolor{comment}{//Skip the current chunk}
707          srcOffset -= src->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
708       \}
709    \}
710 
711    \textcolor{comment}{//Return the actual number of bytes copied}
712    \textcolor{keywordflow}{return} totalLength;
713 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_ac0a46f396754e069dd1ee65cdc559b28}\label{net__mem_8c_ac0a46f396754e069dd1ee65cdc559b28}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Set\+Length@{net\+Buffer\+Set\+Length}}
\index{net\+Buffer\+Set\+Length@{net\+Buffer\+Set\+Length}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Set\+Length()}{netBufferSetLength()}}
{\footnotesize\ttfamily \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689c}{error\+\_\+t} net\+Buffer\+Set\+Length (\begin{DoxyParamCaption}\item[{\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{buffer,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Adjust the length of a multi-\/part buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em buffer} & Pointer to the multi-\/part buffer whose length is to be changed \\
\hline
\mbox{\tt in}  & {\em length} & Desired length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error code 
\end{DoxyReturn}


Definition at line 320 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
321 \{
322    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
323    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} chunkCount;
324    \hyperlink{structChunkDesc}{ChunkDesc} *chunk;
325 
326    \textcolor{comment}{//Get the actual number of chunks}
327    chunkCount = buffer->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount};
328 
329    \textcolor{comment}{//Loop through data chunks}
330    \textcolor{keywordflow}{for}(i = 0; i < chunkCount && length > 0; i++)
331    \{
332       \textcolor{comment}{//Point to the chunk descriptor;}
333       chunk = &buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i];
334 
335       \textcolor{comment}{//Adjust the length of the current chunk when possible}
336       \textcolor{keywordflow}{if}(length <= chunk->\hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length})
337       \{
338          chunk->\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length};
339       \}
340       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(chunk->\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} > 0 && i == (chunkCount - 1))
341       \{
342          chunk->\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = \hyperlink{os__port_8h_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(length, chunk->\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size});
343       \}
344 
345       \textcolor{comment}{//Prepare to process next chunk}
346       length -= chunk->\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
347    \}
348 
349    \textcolor{comment}{//The size of the buffer should be decreased?}
350    \textcolor{keywordflow}{if}(!length)
351    \{
352       \textcolor{comment}{//Adjust the number of chunks}
353       buffer->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount} = i;
354 
355       \textcolor{comment}{//Delete unnecessary data chunks}
356       \textcolor{keywordflow}{while}(i < chunkCount)
357       \{
358          \textcolor{comment}{//Point to the chunk descriptor;}
359          chunk = &buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i];
360 
361          \textcolor{comment}{//Release previously allocated memory}
362          \textcolor{keywordflow}{if}(chunk->\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} > 0)
363             \hyperlink{net__mem_8c_a5e8a514f3dfcb35008de9beb39bcdcde}{memPoolFree}(chunk->\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address});
364 
365          \textcolor{comment}{//Mark the current chunk as free}
366          chunk->\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
367          chunk->\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = 0;
368          chunk->\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} = 0;
369 
370          \textcolor{comment}{//Next chunk}
371          i++;
372       \}
373    \}
374    \textcolor{comment}{//The size of the buffer should be increased?}
375    \textcolor{keywordflow}{else}
376    \{
377       \textcolor{comment}{//Add as many chunks as necessary}
378       \textcolor{keywordflow}{while}(i < buffer->maxChunkCount && length > 0)
379       \{
380          \textcolor{comment}{//Point to the chunk descriptor;}
381          chunk = &buffer->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i];
382 
383          \textcolor{comment}{//Allocate memory to hold a new chunk}
384          chunk->\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} = \hyperlink{net__mem_8c_abe64a91cd872768817509cc08eed6689}{memPoolAlloc}(
      \hyperlink{net__mem_8h_a8870c81bed70c77d981277a24c0174bc}{NET\_MEM\_POOL\_BUFFER\_SIZE});
385          \textcolor{comment}{//Failed to allocate memory?}
386          \textcolor{keywordflow}{if}(!chunk->\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address})
387             \textcolor{keywordflow}{return} \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cac0a554045048d2fb61387cf735676f69}{ERROR\_OUT\_OF\_MEMORY};
388 
389          \textcolor{comment}{//Allocated memory}
390          chunk->\hyperlink{structChunkDesc_ab06232d65ee252651962c202651910c4}{size} = \hyperlink{net__mem_8h_a8870c81bed70c77d981277a24c0174bc}{NET\_MEM\_POOL\_BUFFER\_SIZE};
391          \textcolor{comment}{//Actual length of the data chunk}
392          chunk->\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} = \hyperlink{os__port_8h_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(length, \hyperlink{net__mem_8h_a8870c81bed70c77d981277a24c0174bc}{NET\_MEM\_POOL\_BUFFER\_SIZE});
393 
394          \textcolor{comment}{//Prepare to process next chunk}
395          length -= chunk->\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
396          buffer->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount}++;
397          i++;
398       \}
399    \}
400 
401    \textcolor{comment}{//Return status code}
402    \textcolor{keywordflow}{return} (length > 0) ? \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689ca528efe91b7a7e4bcc9a6de7d4b778c67}{ERROR\_OUT\_OF\_RESOURCES} : \hyperlink{error_8h_ac7659d73a8cdedc08e9f566bb406689cabf350750d0d4fabd8954c0f1e9bbae94}{NO\_ERROR};
403 \}
\end{DoxyCode}
\mbox{\Hypertarget{net__mem_8c_a977e79aab71b4b39772ff8256abb8b55}\label{net__mem_8c_a977e79aab71b4b39772ff8256abb8b55}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!net\+Buffer\+Write@{net\+Buffer\+Write}}
\index{net\+Buffer\+Write@{net\+Buffer\+Write}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{net\+Buffer\+Write()}{netBufferWrite()}}
{\footnotesize\ttfamily size\+\_\+t net\+Buffer\+Write (\begin{DoxyParamCaption}\item[{\hyperlink{structNetBuffer}{Net\+Buffer} $\ast$}]{dest,  }\item[{size\+\_\+t}]{dest\+Offset,  }\item[{const void $\ast$}]{src,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Write data to a multi-\/part buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em dest} & Pointer to a multi-\/part buffer \\
\hline
\mbox{\tt in}  & {\em dest\+Offset} & Offset from the beginning of the multi-\/part buffer \\
\hline
\mbox{\tt in}  & {\em src} & User buffer containing the data to be written \\
\hline
\mbox{\tt in}  & {\em length} & Number of bytes to copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Actual number of bytes copied 
\end{DoxyReturn}


Definition at line 619 of file net\+\_\+mem.\+c.


\begin{DoxyCode}
621 \{
622    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} i;
623    \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\_t} \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
624    \textcolor{keywordtype}{size\_t} totalLength;
625    \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *\hyperlink{ndp_8h_a6519522ad9a6f45e7a8d25d31392a977}{p};
626 
627    \textcolor{comment}{//Total number of bytes written}
628    totalLength = 0;
629 
630    \textcolor{comment}{//Loop through data chunks}
631    \textcolor{keywordflow}{for}(i = 0; i < dest->\hyperlink{structNetBuffer_a43ab1f87d0236d4e01c19ff14f899618}{chunkCount} && totalLength < \hyperlink{dtls__misc_8h_ab43ca82dd7fa2a0e56f941032ef324c4}{length}; i++)
632    \{
633       \textcolor{comment}{//Is there any data to copy in the current chunk?}
634       \textcolor{keywordflow}{if}(destOffset < dest->chunk[i].length)
635       \{
636          \textcolor{comment}{//Point to the first byte to be written}
637          p = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a014aac6efdc5722e058a9b67ca5f8358}{address} + destOffset;
638          \textcolor{comment}{//Compute the number of bytes to copy at a time}
639          n = \hyperlink{os__port_8h_a3acffbd305ee72dcd4593c0d8af64a4f}{MIN}(length - totalLength, dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length} - destOffset);
640 
641          \textcolor{comment}{//Copy data}
642          memcpy(p, src, n);
643 
644          \textcolor{comment}{//Advance read pointer}
645          src = (\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} *) src + n;
646          \textcolor{comment}{//Total number of bytes written}
647          totalLength += \hyperlink{dhcpv6__common_8h_a5a648f5ec00c526b0dfa2df7a272c6c0}{n};
648          \textcolor{comment}{//Process the next block from the start}
649          destOffset = 0;
650       \}
651       \textcolor{keywordflow}{else}
652       \{
653          \textcolor{comment}{//Skip the current chunk}
654          destOffset -= dest->\hyperlink{structNetBuffer_a5d399f3f37224030dcac9c4da3ca41eb}{chunk}[i].\hyperlink{structChunkDesc_a4bdd57a9363511126fe5cd6d30c51c81}{length};
655       \}
656    \}
657 
658    \textcolor{comment}{//Return the actual number of bytes written}
659    \textcolor{keywordflow}{return} totalLength;
660 \}
\end{DoxyCode}


\subsection{Variable Documentation}
\mbox{\Hypertarget{net__mem_8c_ae9e0f60959c4354bb1de17b1f225efe0}\label{net__mem_8c_ae9e0f60959c4354bb1de17b1f225efe0}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool@{mem\+Pool}}
\index{mem\+Pool@{mem\+Pool}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool}{memPool}}
{\footnotesize\ttfamily \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} mem\+Pool\mbox{[}\hyperlink{net__mem_8h_ac7239e39563611040763402dac4d640b}{N\+E\+T\+\_\+\+M\+E\+M\+\_\+\+P\+O\+O\+L\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+C\+O\+U\+NT}\mbox{]}\mbox{[}\hyperlink{net__mem_8h_a8870c81bed70c77d981277a24c0174bc}{N\+E\+T\+\_\+\+M\+E\+M\+\_\+\+P\+O\+O\+L\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 54 of file net\+\_\+mem.\+c.

\mbox{\Hypertarget{net__mem_8c_a7f25b4c3e8950cca5cf7ee28caedf037}\label{net__mem_8c_a7f25b4c3e8950cca5cf7ee28caedf037}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool\+Alloc\+Table@{mem\+Pool\+Alloc\+Table}}
\index{mem\+Pool\+Alloc\+Table@{mem\+Pool\+Alloc\+Table}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool\+Alloc\+Table}{memPoolAllocTable}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a812d16e5494522586b3784e55d479912}{bool\+\_\+t} mem\+Pool\+Alloc\+Table\mbox{[}\hyperlink{net__mem_8h_ac7239e39563611040763402dac4d640b}{N\+E\+T\+\_\+\+M\+E\+M\+\_\+\+P\+O\+O\+L\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+C\+O\+U\+NT}\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 56 of file net\+\_\+mem.\+c.

\mbox{\Hypertarget{net__mem_8c_a8104bc3ab6ec936da2fec0ab3a651821}\label{net__mem_8c_a8104bc3ab6ec936da2fec0ab3a651821}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool\+Current\+Usage@{mem\+Pool\+Current\+Usage}}
\index{mem\+Pool\+Current\+Usage@{mem\+Pool\+Current\+Usage}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool\+Current\+Usage}{memPoolCurrentUsage}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} mem\+Pool\+Current\+Usage}



Definition at line 58 of file net\+\_\+mem.\+c.

\mbox{\Hypertarget{net__mem_8c_ad61bc6e030d82b6add827fa5d5e8f060}\label{net__mem_8c_ad61bc6e030d82b6add827fa5d5e8f060}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool\+Max\+Usage@{mem\+Pool\+Max\+Usage}}
\index{mem\+Pool\+Max\+Usage@{mem\+Pool\+Max\+Usage}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool\+Max\+Usage}{memPoolMaxUsage}}
{\footnotesize\ttfamily \hyperlink{compiler__port_8h_a12a1e9b3ce141648783a82445d02b58d}{uint\+\_\+t} mem\+Pool\+Max\+Usage}



Definition at line 60 of file net\+\_\+mem.\+c.

\mbox{\Hypertarget{net__mem_8c_a0a048e1478fe2bef7ad3219a1e8f477a}\label{net__mem_8c_a0a048e1478fe2bef7ad3219a1e8f477a}} 
\index{net\+\_\+mem.\+c@{net\+\_\+mem.\+c}!mem\+Pool\+Mutex@{mem\+Pool\+Mutex}}
\index{mem\+Pool\+Mutex@{mem\+Pool\+Mutex}!net\+\_\+mem.\+c@{net\+\_\+mem.\+c}}
\subsubsection{\texorpdfstring{mem\+Pool\+Mutex}{memPoolMutex}}
{\footnotesize\ttfamily \hyperlink{structOsMutex}{Os\+Mutex} mem\+Pool\+Mutex\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 52 of file net\+\_\+mem.\+c.

