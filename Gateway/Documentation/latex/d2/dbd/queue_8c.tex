\hypertarget{queue_8c}{}\section{third\+\_\+party/freertos/queue.c File Reference}
\label{queue_8c}\index{third\+\_\+party/freertos/queue.\+c@{third\+\_\+party/freertos/queue.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include \char`\"{}Free\+R\+T\+O\+S.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}task.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}queue.\+h\char`\"{}}\newline
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structQueuePointers}{Queue\+Pointers}
\item 
struct \hyperlink{structSemaphoreData}{Semaphore\+Data}
\item 
struct \hyperlink{structQueueDefinition}{Queue\+Definition}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{queue_8c_ab622d8c674f2a417a666a7ed89109e79}{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}
\item 
\#define \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queue\+U\+N\+L\+O\+C\+K\+ED}~( ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\+\_\+t} ) -\/1 )
\item 
\#define \hyperlink{queue_8c_a60a95aa91f84782416755f38616231fd}{queue\+L\+O\+C\+K\+E\+D\+\_\+\+U\+N\+M\+O\+D\+I\+F\+I\+ED}~( ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\+\_\+t} ) 0 )
\item 
\#define \hyperlink{queue_8c_afe3f7afb2a02c085f2d634003902cbc0}{ux\+Queue\+Type}~pc\+Head
\item 
\#define \hyperlink{queue_8c_a0799077a434aea43f5cca3cda3625aa8}{queue\+Q\+U\+E\+U\+E\+\_\+\+I\+S\+\_\+\+M\+U\+T\+EX}~\hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL}
\item 
\#define \hyperlink{queue_8c_adfb14d07644ad4da4bd2303105884227}{queue\+S\+E\+M\+A\+P\+H\+O\+R\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+I\+T\+E\+M\+\_\+\+L\+E\+N\+G\+TH}~( ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} ) 0 )
\item 
\#define \hyperlink{queue_8c_a166c89c5c3a213c7e52283e024bb1d50}{queue\+M\+U\+T\+E\+X\+\_\+\+G\+I\+V\+E\+\_\+\+B\+L\+O\+C\+K\+\_\+\+T\+I\+ME}~( ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} ) 0\+U )
\item 
\#define \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queue\+Y\+I\+E\+L\+D\+\_\+\+I\+F\+\_\+\+U\+S\+I\+N\+G\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON}()
\item 
\#define \hyperlink{queue_8c_ae4efd14c0f4dee7f189ef2e4d9ce1f1b}{prv\+Lock\+Queue}(px\+Queue)
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structQueuePointers}{Queue\+Pointers} \hyperlink{queue_8c_ad04ba6edfecdbdee6406cdd62a72671c}{Queue\+Pointers\+\_\+t}
\item 
typedef struct \hyperlink{structSemaphoreData}{Semaphore\+Data} \hyperlink{queue_8c_a37643b46fd5893e70242848a22aef310}{Semaphore\+Data\+\_\+t}
\item 
typedef struct \hyperlink{structQueueDefinition}{Queue\+Definition} \hyperlink{queue_8c_a0a752aab32c1d5543a2aa40618ad453f}{x\+Q\+U\+E\+UE}
\item 
typedef \hyperlink{queue_8c_a0a752aab32c1d5543a2aa40618ad453f}{x\+Q\+U\+E\+UE} \hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prv\+Unlock\+Queue} (\hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$const px\+Queue) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
static \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a8f21d4b7a21be0d109953120c93f6741}{prv\+Is\+Queue\+Empty} (const \hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$px\+Queue) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
static \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a70546f6b48a8b715eae3dd84e0546045}{prv\+Is\+Queue\+Full} (const \hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$px\+Queue) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
static \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a77098159b7735e0c27e27aa7072376c6}{prv\+Copy\+Data\+To\+Queue} (\hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$const px\+Queue, const void $\ast$pv\+Item\+To\+Queue, const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Position) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
static void \hyperlink{queue_8c_ad9a2e17b2b13d4878f7af1361437320e}{prv\+Copy\+Data\+From\+Queue} (\hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$const px\+Queue, void $\ast$const pv\+Buffer) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
static void \hyperlink{queue_8c_a0f632268707981dea3f177f5fba36e22}{prv\+Initialise\+New\+Queue} (const \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} ux\+Queue\+Length, const \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} ux\+Item\+Size, \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$puc\+Queue\+Storage, const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} uc\+Queue\+Type, \hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$px\+New\+Queue) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a5e54273dbe3f56b8bdc8f7abee67a871}{x\+Queue\+Generic\+Reset} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+New\+Queue)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_acb67c81366c00896b21cd826e07d885d}{x\+Queue\+Generic\+Send} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, const void $\ast$const pv\+Item\+To\+Queue, \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} x\+Ticks\+To\+Wait, const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Copy\+Position)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a0fb58b25eb396a5cf8e1688b7e1a56cb}{x\+Queue\+Generic\+Send\+From\+I\+SR} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, const void $\ast$const pv\+Item\+To\+Queue, \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} $\ast$const px\+Higher\+Priority\+Task\+Woken, const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Copy\+Position)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a4df49fafb6ba4400ede6f2d07a40865f}{x\+Queue\+Give\+From\+I\+SR} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} $\ast$const px\+Higher\+Priority\+Task\+Woken)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_ad0a166f3b1219a5e37e31f8090d4800d}{x\+Queue\+Receive} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, void $\ast$const pv\+Buffer, \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} x\+Ticks\+To\+Wait)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_ade45e48664e5ec17ea091f00cd34394f}{x\+Queue\+Semaphore\+Take} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} x\+Ticks\+To\+Wait)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a8f68e37e931bbf95440c8845f512e090}{x\+Queue\+Peek} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, void $\ast$const pv\+Buffer, \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} x\+Ticks\+To\+Wait)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_ac61ec62828e70ed35d18559a35550462}{x\+Queue\+Receive\+From\+I\+SR} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, void $\ast$const pv\+Buffer, \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} $\ast$const px\+Higher\+Priority\+Task\+Woken)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_af67763957452955ac663c374d71278ce}{x\+Queue\+Peek\+From\+I\+SR} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue, void $\ast$const pv\+Buffer)
\item 
\hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} \hyperlink{queue_8c_a4158a6134c9d1c60ffdb18d279d475b1}{ux\+Queue\+Messages\+Waiting} (const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue)
\item 
\hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} \hyperlink{queue_8c_a27d6fb77ce7a0b5a16f6471730d33201}{ux\+Queue\+Spaces\+Available} (const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue)
\item 
\hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} \hyperlink{queue_8c_ad5d110bc27c691ff8da238e0116bf92a}{ux\+Queue\+Messages\+Waiting\+From\+I\+SR} (const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue)
\item 
void \hyperlink{queue_8c_a35c0b4f9a0e940cb3a86ca4c5e84c41c}{v\+Queue\+Delete} (\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a7d076f57a56ef50315418f8bbfba96fd}{x\+Queue\+Is\+Queue\+Empty\+From\+I\+SR} (const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue)
\item 
\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} \hyperlink{queue_8c_a76bbe8ebd21b3e89784e865d06f1058c}{x\+Queue\+Is\+Queue\+Full\+From\+I\+SR} (const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t} x\+Queue)
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{queue_8c_ab622d8c674f2a417a666a7ed89109e79}\label{queue_8c_ab622d8c674f2a417a666a7ed89109e79}} 
\index{queue.\+c@{queue.\+c}!M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE@{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}}
\index{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE@{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}{MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE}}
{\footnotesize\ttfamily \#define M\+P\+U\+\_\+\+W\+R\+A\+P\+P\+E\+R\+S\+\_\+\+I\+N\+C\+L\+U\+D\+E\+D\+\_\+\+F\+R\+O\+M\+\_\+\+A\+P\+I\+\_\+\+F\+I\+LE}



Definition at line 34 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_ae4efd14c0f4dee7f189ef2e4d9ce1f1b}\label{queue_8c_ae4efd14c0f4dee7f189ef2e4d9ce1f1b}} 
\index{queue.\+c@{queue.\+c}!prv\+Lock\+Queue@{prv\+Lock\+Queue}}
\index{prv\+Lock\+Queue@{prv\+Lock\+Queue}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{prv\+Lock\+Queue}{prvLockQueue}}
{\footnotesize\ttfamily \#define prv\+Lock\+Queue(\begin{DoxyParamCaption}\item[{}]{px\+Queue }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
\hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();                                 \(\backslash\)
    \{                                                       \(\backslash\)
        if( ( pxQueue )->cRxLock == \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED} )            \(\backslash\)
        \{                                                   \(\backslash\)
            ( pxQueue )->cRxLock = \hyperlink{queue_8c_a60a95aa91f84782416755f38616231fd}{queueLOCKED\_UNMODIFIED};    \(\backslash\)
        \}                                                   \(\backslash\)
        if( ( pxQueue )->cTxLock == \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED} )            \(\backslash\)
        \{                                                   \(\backslash\)
            ( pxQueue )->cTxLock = \hyperlink{queue_8c_a60a95aa91f84782416755f38616231fd}{queueLOCKED\_UNMODIFIED};    \(\backslash\)
        \}                                                   \(\backslash\)
    \}                                                       \(\backslash\)
    taskEXIT\_CRITICAL()
\end{DoxyCode}


Definition at line 240 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_a60a95aa91f84782416755f38616231fd}\label{queue_8c_a60a95aa91f84782416755f38616231fd}} 
\index{queue.\+c@{queue.\+c}!queue\+L\+O\+C\+K\+E\+D\+\_\+\+U\+N\+M\+O\+D\+I\+F\+I\+ED@{queue\+L\+O\+C\+K\+E\+D\+\_\+\+U\+N\+M\+O\+D\+I\+F\+I\+ED}}
\index{queue\+L\+O\+C\+K\+E\+D\+\_\+\+U\+N\+M\+O\+D\+I\+F\+I\+ED@{queue\+L\+O\+C\+K\+E\+D\+\_\+\+U\+N\+M\+O\+D\+I\+F\+I\+ED}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{queue\+L\+O\+C\+K\+E\+D\+\_\+\+U\+N\+M\+O\+D\+I\+F\+I\+ED}{queueLOCKED\_UNMODIFIED}}
{\footnotesize\ttfamily \#define queue\+L\+O\+C\+K\+E\+D\+\_\+\+U\+N\+M\+O\+D\+I\+F\+I\+ED~( ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\+\_\+t} ) 0 )}



Definition at line 53 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_a166c89c5c3a213c7e52283e024bb1d50}\label{queue_8c_a166c89c5c3a213c7e52283e024bb1d50}} 
\index{queue.\+c@{queue.\+c}!queue\+M\+U\+T\+E\+X\+\_\+\+G\+I\+V\+E\+\_\+\+B\+L\+O\+C\+K\+\_\+\+T\+I\+ME@{queue\+M\+U\+T\+E\+X\+\_\+\+G\+I\+V\+E\+\_\+\+B\+L\+O\+C\+K\+\_\+\+T\+I\+ME}}
\index{queue\+M\+U\+T\+E\+X\+\_\+\+G\+I\+V\+E\+\_\+\+B\+L\+O\+C\+K\+\_\+\+T\+I\+ME@{queue\+M\+U\+T\+E\+X\+\_\+\+G\+I\+V\+E\+\_\+\+B\+L\+O\+C\+K\+\_\+\+T\+I\+ME}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{queue\+M\+U\+T\+E\+X\+\_\+\+G\+I\+V\+E\+\_\+\+B\+L\+O\+C\+K\+\_\+\+T\+I\+ME}{queueMUTEX\_GIVE\_BLOCK\_TIME}}
{\footnotesize\ttfamily \#define queue\+M\+U\+T\+E\+X\+\_\+\+G\+I\+V\+E\+\_\+\+B\+L\+O\+C\+K\+\_\+\+T\+I\+ME~( ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} ) 0\+U )}



Definition at line 82 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_a0799077a434aea43f5cca3cda3625aa8}\label{queue_8c_a0799077a434aea43f5cca3cda3625aa8}} 
\index{queue.\+c@{queue.\+c}!queue\+Q\+U\+E\+U\+E\+\_\+\+I\+S\+\_\+\+M\+U\+T\+EX@{queue\+Q\+U\+E\+U\+E\+\_\+\+I\+S\+\_\+\+M\+U\+T\+EX}}
\index{queue\+Q\+U\+E\+U\+E\+\_\+\+I\+S\+\_\+\+M\+U\+T\+EX@{queue\+Q\+U\+E\+U\+E\+\_\+\+I\+S\+\_\+\+M\+U\+T\+EX}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{queue\+Q\+U\+E\+U\+E\+\_\+\+I\+S\+\_\+\+M\+U\+T\+EX}{queueQUEUE\_IS\_MUTEX}}
{\footnotesize\ttfamily \#define queue\+Q\+U\+E\+U\+E\+\_\+\+I\+S\+\_\+\+M\+U\+T\+EX~\hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL}}



Definition at line 65 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_adfb14d07644ad4da4bd2303105884227}\label{queue_8c_adfb14d07644ad4da4bd2303105884227}} 
\index{queue.\+c@{queue.\+c}!queue\+S\+E\+M\+A\+P\+H\+O\+R\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+I\+T\+E\+M\+\_\+\+L\+E\+N\+G\+TH@{queue\+S\+E\+M\+A\+P\+H\+O\+R\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+I\+T\+E\+M\+\_\+\+L\+E\+N\+G\+TH}}
\index{queue\+S\+E\+M\+A\+P\+H\+O\+R\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+I\+T\+E\+M\+\_\+\+L\+E\+N\+G\+TH@{queue\+S\+E\+M\+A\+P\+H\+O\+R\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+I\+T\+E\+M\+\_\+\+L\+E\+N\+G\+TH}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{queue\+S\+E\+M\+A\+P\+H\+O\+R\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+I\+T\+E\+M\+\_\+\+L\+E\+N\+G\+TH}{queueSEMAPHORE\_QUEUE\_ITEM\_LENGTH}}
{\footnotesize\ttfamily \#define queue\+S\+E\+M\+A\+P\+H\+O\+R\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+I\+T\+E\+M\+\_\+\+L\+E\+N\+G\+TH~( ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} ) 0 )}



Definition at line 81 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}\label{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}} 
\index{queue.\+c@{queue.\+c}!queue\+U\+N\+L\+O\+C\+K\+ED@{queue\+U\+N\+L\+O\+C\+K\+ED}}
\index{queue\+U\+N\+L\+O\+C\+K\+ED@{queue\+U\+N\+L\+O\+C\+K\+ED}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{queue\+U\+N\+L\+O\+C\+K\+ED}{queueUNLOCKED}}
{\footnotesize\ttfamily \#define queue\+U\+N\+L\+O\+C\+K\+ED~( ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\+\_\+t} ) -\/1 )}



Definition at line 52 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_adb4472163ac5b0e8ad72183d69387b81}\label{queue_8c_adb4472163ac5b0e8ad72183d69387b81}} 
\index{queue.\+c@{queue.\+c}!queue\+Y\+I\+E\+L\+D\+\_\+\+I\+F\+\_\+\+U\+S\+I\+N\+G\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON@{queue\+Y\+I\+E\+L\+D\+\_\+\+I\+F\+\_\+\+U\+S\+I\+N\+G\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON}}
\index{queue\+Y\+I\+E\+L\+D\+\_\+\+I\+F\+\_\+\+U\+S\+I\+N\+G\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON@{queue\+Y\+I\+E\+L\+D\+\_\+\+I\+F\+\_\+\+U\+S\+I\+N\+G\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{queue\+Y\+I\+E\+L\+D\+\_\+\+I\+F\+\_\+\+U\+S\+I\+N\+G\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON}{queueYIELD\_IF\_USING\_PREEMPTION}}
{\footnotesize\ttfamily \#define queue\+Y\+I\+E\+L\+D\+\_\+\+I\+F\+\_\+\+U\+S\+I\+N\+G\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON(\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 87 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_afe3f7afb2a02c085f2d634003902cbc0}\label{queue_8c_afe3f7afb2a02c085f2d634003902cbc0}} 
\index{queue.\+c@{queue.\+c}!ux\+Queue\+Type@{ux\+Queue\+Type}}
\index{ux\+Queue\+Type@{ux\+Queue\+Type}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{ux\+Queue\+Type}{uxQueueType}}
{\footnotesize\ttfamily \#define ux\+Queue\+Type~pc\+Head}



Definition at line 64 of file queue.\+c.



\subsection{Typedef Documentation}
\mbox{\Hypertarget{queue_8c_ade16d14675fc1ac34af04a1162a6b883}\label{queue_8c_ade16d14675fc1ac34af04a1162a6b883}} 
\index{queue.\+c@{queue.\+c}!Queue\+\_\+t@{Queue\+\_\+t}}
\index{Queue\+\_\+t@{Queue\+\_\+t}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{Queue\+\_\+t}{Queue\_t}}
{\footnotesize\ttfamily typedef \hyperlink{queue_8c_a0a752aab32c1d5543a2aa40618ad453f}{x\+Q\+U\+E\+UE} \hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t}}



Definition at line 135 of file queue.\+c.

\mbox{\Hypertarget{queue_8c_ad04ba6edfecdbdee6406cdd62a72671c}\label{queue_8c_ad04ba6edfecdbdee6406cdd62a72671c}} 
\index{queue.\+c@{queue.\+c}!Queue\+Pointers\+\_\+t@{Queue\+Pointers\+\_\+t}}
\index{Queue\+Pointers\+\_\+t@{Queue\+Pointers\+\_\+t}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{Queue\+Pointers\+\_\+t}{QueuePointers\_t}}
{\footnotesize\ttfamily typedef struct \hyperlink{structQueuePointers}{Queue\+Pointers}  \hyperlink{queue_8c_ad04ba6edfecdbdee6406cdd62a72671c}{Queue\+Pointers\+\_\+t}}

\mbox{\Hypertarget{queue_8c_a37643b46fd5893e70242848a22aef310}\label{queue_8c_a37643b46fd5893e70242848a22aef310}} 
\index{queue.\+c@{queue.\+c}!Semaphore\+Data\+\_\+t@{Semaphore\+Data\+\_\+t}}
\index{Semaphore\+Data\+\_\+t@{Semaphore\+Data\+\_\+t}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{Semaphore\+Data\+\_\+t}{SemaphoreData\_t}}
{\footnotesize\ttfamily typedef struct \hyperlink{structSemaphoreData}{Semaphore\+Data}  \hyperlink{queue_8c_a37643b46fd5893e70242848a22aef310}{Semaphore\+Data\+\_\+t}}

\mbox{\Hypertarget{queue_8c_a0a752aab32c1d5543a2aa40618ad453f}\label{queue_8c_a0a752aab32c1d5543a2aa40618ad453f}} 
\index{queue.\+c@{queue.\+c}!x\+Q\+U\+E\+UE@{x\+Q\+U\+E\+UE}}
\index{x\+Q\+U\+E\+UE@{x\+Q\+U\+E\+UE}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Q\+U\+E\+UE}{xQUEUE}}
{\footnotesize\ttfamily typedef struct \hyperlink{structQueueDefinition}{Queue\+Definition}  \hyperlink{queue_8c_a0a752aab32c1d5543a2aa40618ad453f}{x\+Q\+U\+E\+UE}}



\subsection{Function Documentation}
\mbox{\Hypertarget{queue_8c_ad9a2e17b2b13d4878f7af1361437320e}\label{queue_8c_ad9a2e17b2b13d4878f7af1361437320e}} 
\index{queue.\+c@{queue.\+c}!prv\+Copy\+Data\+From\+Queue@{prv\+Copy\+Data\+From\+Queue}}
\index{prv\+Copy\+Data\+From\+Queue@{prv\+Copy\+Data\+From\+Queue}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{prv\+Copy\+Data\+From\+Queue()}{prvCopyDataFromQueue()}}
{\footnotesize\ttfamily static void prv\+Copy\+Data\+From\+Queue (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$const}]{px\+Queue,  }\item[{void $\ast$const}]{pv\+Buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2149 of file queue.\+c.


\begin{DoxyCode}
2150 \{
2151     \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} != ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
2152     \{
2153         pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} += pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize}; \textcolor{comment}{/*lint !e9016
       Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying
       intent. */}
2154         \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} >= pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.
      \hyperlink{structQueuePointers_acbbdc8eb47b348a824c7bced41512a38}{pcTail} ) \textcolor{comment}{/*lint !e946 MISRA exception justified as use of the relational operator is the cleanest
       solutions. */}
2155         \{
2156             pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} = pxQueue->\hyperlink{structQueueDefinition_a487dc7e43b380c58212cba72bc33e0ed}{pcHead};
2157         \}
2158         \textcolor{keywordflow}{else}
2159         \{
2160             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2161         \}
2162         ( void ) memcpy( ( \textcolor{keywordtype}{void} * ) pvBuffer, ( \textcolor{keywordtype}{void} * ) pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.
      \hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom}, ( \textcolor{keywordtype}{size\_t} ) pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} ); \textcolor{comment}{/*lint !e961 !e418 !e9087 MISRA exception
       as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be
       passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment
       requirement and copy length specified in bytes. */}
2163     \}
2164 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a77098159b7735e0c27e27aa7072376c6}\label{queue_8c_a77098159b7735e0c27e27aa7072376c6}} 
\index{queue.\+c@{queue.\+c}!prv\+Copy\+Data\+To\+Queue@{prv\+Copy\+Data\+To\+Queue}}
\index{prv\+Copy\+Data\+To\+Queue@{prv\+Copy\+Data\+To\+Queue}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{prv\+Copy\+Data\+To\+Queue()}{prvCopyDataToQueue()}}
{\footnotesize\ttfamily static \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} prv\+Copy\+Data\+To\+Queue (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$const}]{px\+Queue,  }\item[{const void $\ast$}]{pv\+Item\+To\+Queue,  }\item[{const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t}}]{x\+Position }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2070 of file queue.\+c.


\begin{DoxyCode}
2071 \{
2072 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
2073 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxMessagesWaiting;
2074 
2075     \textcolor{comment}{/* This function is called from a critical section. */}
2076 
2077     uxMessagesWaiting = pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
2078 
2079     \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} == ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
2080     \{
2081 \textcolor{preprocessor}{        #if ( configUSE\_MUTEXES == 1 )}
2082         \{
2083             \textcolor{keywordflow}{if}( pxQueue->uxQueueType == \hyperlink{queue_8c_a0799077a434aea43f5cca3cda3625aa8}{queueQUEUE\_IS\_MUTEX} )
2084             \{
2085                 \textcolor{comment}{/* The mutex is no longer being held. */}
2086                 xReturn = \hyperlink{task_8h_a02fe2e1419fd6c35f75a1357c5e5ce22}{xTaskPriorityDisinherit}( pxQueue->
      \hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_adb2c0818274974553c619ff953b6f477}{xSemaphore}.\hyperlink{structSemaphoreData_ab1ed54c7b39dc45b3c310fae7ad08693}{xMutexHolder} );
2087                 pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_adb2c0818274974553c619ff953b6f477}{xSemaphore}.\hyperlink{structSemaphoreData_ab1ed54c7b39dc45b3c310fae7ad08693}{xMutexHolder} = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
2088             \}
2089             \textcolor{keywordflow}{else}
2090             \{
2091                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2092             \}
2093         \}
2094 \textcolor{preprocessor}{        #endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}
2095     \}
2096     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xPosition == \hyperlink{queue_8h_a4d78fa863fbeb90425a2dda08fae8b12}{queueSEND\_TO\_BACK} )
2097     \{
2098         ( void ) memcpy( ( \textcolor{keywordtype}{void} * ) pxQueue->\hyperlink{structQueueDefinition_abdf13cc013c8488848cee3fce4f0fed3}{pcWriteTo}, pvItemToQueue, ( size\_t ) pxQueue->
      \hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} ); \textcolor{comment}{/*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some
       ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. 
       Cast to void required by function signature and safe as no alignment requirement and copy length specified in
       bytes. */}
2099         pxQueue->\hyperlink{structQueueDefinition_abdf13cc013c8488848cee3fce4f0fed3}{pcWriteTo} += pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize}; \textcolor{comment}{/*lint !e9016 Pointer arithmetic on
       char types ok, especially in this use case where it is the clearest way of conveying intent. */}
2100         \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_abdf13cc013c8488848cee3fce4f0fed3}{pcWriteTo} >= pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_acbbdc8eb47b348a824c7bced41512a38}{pcTail} ) \textcolor{comment}{/*lint !e946 MISRA
       exception justified as comparison of pointers is the cleanest solution. */}
2101         \{
2102             pxQueue->\hyperlink{structQueueDefinition_abdf13cc013c8488848cee3fce4f0fed3}{pcWriteTo} = pxQueue->\hyperlink{structQueueDefinition_a487dc7e43b380c58212cba72bc33e0ed}{pcHead};
2103         \}
2104         \textcolor{keywordflow}{else}
2105         \{
2106             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2107         \}
2108     \}
2109     \textcolor{keywordflow}{else}
2110     \{
2111         ( void ) memcpy( ( \textcolor{keywordtype}{void} * ) pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom}, pvItemToQueue, ( size\_t 
      ) pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} ); \textcolor{comment}{/*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant
       for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy
       length specified in bytes.  Assert checks null pointer only used when length is 0. */}
2112         pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} -= pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize};
2113         \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} < pxQueue->\hyperlink{structQueueDefinition_a487dc7e43b380c58212cba72bc33e0ed}{pcHead} ) \textcolor{comment}{/*lint !e946 MISRA
       exception justified as comparison of pointers is the cleanest solution. */}
2114         \{
2115             pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} = ( pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.
      \hyperlink{structQueuePointers_acbbdc8eb47b348a824c7bced41512a38}{pcTail} - pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} );
2116         \}
2117         \textcolor{keywordflow}{else}
2118         \{
2119             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2120         \}
2121 
2122         \textcolor{keywordflow}{if}( xPosition == \hyperlink{queue_8h_a5bb1c4a46d4b08b6d35cf586983476ef}{queueOVERWRITE} )
2123         \{
2124             \textcolor{keywordflow}{if}( uxMessagesWaiting > ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
2125             \{
2126                 \textcolor{comment}{/* An item is not being added but overwritten, so subtract}
2127 \textcolor{comment}{                one from the recorded number of items in the queue so when}
2128 \textcolor{comment}{                one is added again below the number of recorded items remains}
2129 \textcolor{comment}{                correct. */}
2130                 --uxMessagesWaiting;
2131             \}
2132             \textcolor{keywordflow}{else}
2133             \{
2134                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2135             \}
2136         \}
2137         \textcolor{keywordflow}{else}
2138         \{
2139             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2140         \}
2141     \}
2142 
2143     pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} = uxMessagesWaiting + ( 
      \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 1;
2144 
2145     \textcolor{keywordflow}{return} xReturn;
2146 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a0f632268707981dea3f177f5fba36e22}\label{queue_8c_a0f632268707981dea3f177f5fba36e22}} 
\index{queue.\+c@{queue.\+c}!prv\+Initialise\+New\+Queue@{prv\+Initialise\+New\+Queue}}
\index{prv\+Initialise\+New\+Queue@{prv\+Initialise\+New\+Queue}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{prv\+Initialise\+New\+Queue()}{prvInitialiseNewQueue()}}
{\footnotesize\ttfamily static void prv\+Initialise\+New\+Queue (\begin{DoxyParamCaption}\item[{const \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t}}]{ux\+Queue\+Length,  }\item[{const \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t}}]{ux\+Item\+Size,  }\item[{\hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} $\ast$}]{puc\+Queue\+Storage,  }\item[{const \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t}}]{uc\+Queue\+Type,  }\item[{\hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$}]{px\+New\+Queue }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 429 of file queue.\+c.


\begin{DoxyCode}
430 \{
431     \textcolor{comment}{/* Remove compiler warnings about unused parameters should}
432 \textcolor{comment}{    configUSE\_TRACE\_FACILITY not be set to 1. */}
433     ( void ) ucQueueType;
434 
435     \textcolor{keywordflow}{if}( uxItemSize == ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
436     \{
437         \textcolor{comment}{/* No RAM was allocated for the queue storage area, but PC head cannot}
438 \textcolor{comment}{        be set to NULL because NULL is used as a key to say the queue is used as}
439 \textcolor{comment}{        a mutex.  Therefore just set pcHead to point to the queue as a benign}
440 \textcolor{comment}{        value that is known to be within the memory map. */}
441         pxNewQueue->\hyperlink{structQueueDefinition_a487dc7e43b380c58212cba72bc33e0ed}{pcHead} = ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} * ) pxNewQueue;
442     \}
443     \textcolor{keywordflow}{else}
444     \{
445         \textcolor{comment}{/* Set the head to the start of the queue storage area. */}
446         pxNewQueue->\hyperlink{structQueueDefinition_a487dc7e43b380c58212cba72bc33e0ed}{pcHead} = ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} * ) pucQueueStorage;
447     \}
448 
449     \textcolor{comment}{/* Initialise the queue members as described where the queue type is}
450 \textcolor{comment}{    defined. */}
451     pxNewQueue->\hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} = uxQueueLength;
452     pxNewQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} = uxItemSize;
453     ( void ) \hyperlink{queue_8c_a5e54273dbe3f56b8bdc8f7abee67a871}{xQueueGenericReset}( pxNewQueue, \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE} );
454 
455 \textcolor{preprocessor}{    #if ( configUSE\_TRACE\_FACILITY == 1 )}
456     \{
457         pxNewQueue->ucQueueType = ucQueueType;
458     \}
459 \textcolor{preprocessor}{    #endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}
460 
461 \textcolor{preprocessor}{    #if( configUSE\_QUEUE\_SETS == 1 )}
462     \{
463         pxNewQueue->pxQueueSetContainer = \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
464     \}
465 \textcolor{preprocessor}{    #endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
466 
467     \hyperlink{FreeRTOS_8h_a62dcc27e040063ec72e174c985740f96}{traceQUEUE\_CREATE}( pxNewQueue );
468 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a8f21d4b7a21be0d109953120c93f6741}\label{queue_8c_a8f21d4b7a21be0d109953120c93f6741}} 
\index{queue.\+c@{queue.\+c}!prv\+Is\+Queue\+Empty@{prv\+Is\+Queue\+Empty}}
\index{prv\+Is\+Queue\+Empty@{prv\+Is\+Queue\+Empty}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{prv\+Is\+Queue\+Empty()}{prvIsQueueEmpty()}}
{\footnotesize\ttfamily static \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} prv\+Is\+Queue\+Empty (\begin{DoxyParamCaption}\item[{const \hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$}]{px\+Queue }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2287 of file queue.\+c.


\begin{DoxyCode}
2288 \{
2289 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn;
2290 
2291     \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
2292     \{
2293         \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} == ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} )  0 )
2294         \{
2295             xReturn = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
2296         \}
2297         \textcolor{keywordflow}{else}
2298         \{
2299             xReturn = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
2300         \}
2301     \}
2302     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
2303 
2304     \textcolor{keywordflow}{return} xReturn;
2305 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a70546f6b48a8b715eae3dd84e0546045}\label{queue_8c_a70546f6b48a8b715eae3dd84e0546045}} 
\index{queue.\+c@{queue.\+c}!prv\+Is\+Queue\+Full@{prv\+Is\+Queue\+Full}}
\index{prv\+Is\+Queue\+Full@{prv\+Is\+Queue\+Full}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{prv\+Is\+Queue\+Full()}{prvIsQueueFull()}}
{\footnotesize\ttfamily static \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} prv\+Is\+Queue\+Full (\begin{DoxyParamCaption}\item[{const \hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$}]{px\+Queue }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2327 of file queue.\+c.


\begin{DoxyCode}
2328 \{
2329 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn;
2330 
2331     \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
2332     \{
2333         \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} == pxQueue->\hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} )
2334         \{
2335             xReturn = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
2336         \}
2337         \textcolor{keywordflow}{else}
2338         \{
2339             xReturn = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
2340         \}
2341     \}
2342     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
2343 
2344     \textcolor{keywordflow}{return} xReturn;
2345 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}\label{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}} 
\index{queue.\+c@{queue.\+c}!prv\+Unlock\+Queue@{prv\+Unlock\+Queue}}
\index{prv\+Unlock\+Queue@{prv\+Unlock\+Queue}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{prv\+Unlock\+Queue()}{prvUnlockQueue()}}
{\footnotesize\ttfamily static void prv\+Unlock\+Queue (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8c_ade16d14675fc1ac34af04a1162a6b883}{Queue\+\_\+t} $\ast$const}]{px\+Queue }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2167 of file queue.\+c.


\begin{DoxyCode}
2168 \{
2169     \textcolor{comment}{/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */}
2170 
2171     \textcolor{comment}{/* The lock counts contains the number of extra data items placed or}
2172 \textcolor{comment}{    removed from the queue while the queue was locked.  When a queue is}
2173 \textcolor{comment}{    locked items can be added or removed, but the event lists cannot be}
2174 \textcolor{comment}{    updated. */}
2175     \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
2176     \{
2177         \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} cTxLock = pxQueue->\hyperlink{structQueueDefinition_a24ac3f0707f098da2a22244d843fcf82}{cTxLock};
2178 
2179         \textcolor{comment}{/* See if data was added to the queue while it was locked. */}
2180         \textcolor{keywordflow}{while}( cTxLock > \hyperlink{queue_8c_a60a95aa91f84782416755f38616231fd}{queueLOCKED\_UNMODIFIED} )
2181         \{
2182             \textcolor{comment}{/* Data was posted while the queue was locked.  Are any tasks}
2183 \textcolor{comment}{            blocked waiting for data to become available? */}
2184 \textcolor{preprocessor}{            #if ( configUSE\_QUEUE\_SETS == 1 )}
2185             \{
2186                 \textcolor{keywordflow}{if}( pxQueue->pxQueueSetContainer != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
2187                 \{
2188                     \textcolor{keywordflow}{if}( prvNotifyQueueSetContainer( pxQueue, \hyperlink{queue_8h_a4d78fa863fbeb90425a2dda08fae8b12}{queueSEND\_TO\_BACK} ) != 
      \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
2189                     \{
2190                         \textcolor{comment}{/* The queue is a member of a queue set, and posting to}
2191 \textcolor{comment}{                        the queue set caused a higher priority task to unblock.}
2192 \textcolor{comment}{                        A context switch is required. */}
2193                         \hyperlink{task_8h_a998c69e37431a3a32c637b31ff60089a}{vTaskMissedYield}();
2194                     \}
2195                     \textcolor{keywordflow}{else}
2196                     \{
2197                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2198                     \}
2199                 \}
2200                 \textcolor{keywordflow}{else}
2201                 \{
2202                     \textcolor{comment}{/* Tasks that are removed from the event list will get}
2203 \textcolor{comment}{                    added to the pending ready list as the scheduler is still}
2204 \textcolor{comment}{                    suspended. */}
2205                     \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
2206                     \{
2207                         \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
2208                         \{
2209                             \textcolor{comment}{/* The task waiting has a higher priority so record that a}
2210 \textcolor{comment}{                            context switch is required. */}
2211                             \hyperlink{task_8h_a998c69e37431a3a32c637b31ff60089a}{vTaskMissedYield}();
2212                         \}
2213                         \textcolor{keywordflow}{else}
2214                         \{
2215                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2216                         \}
2217                     \}
2218                     \textcolor{keywordflow}{else}
2219                     \{
2220                         \textcolor{keywordflow}{break};
2221                     \}
2222                 \}
2223             \}
2224 \textcolor{preprocessor}{            #else }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
2225             \{
2226                 \textcolor{comment}{/* Tasks that are removed from the event list will get added to}
2227 \textcolor{comment}{                the pending ready list as the scheduler is still suspended. */}
2228                 \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
2229                 \{
2230                     \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
2231                     \{
2232                         \textcolor{comment}{/* The task waiting has a higher priority so record that}
2233 \textcolor{comment}{                        a context switch is required. */}
2234                         \hyperlink{task_8h_a998c69e37431a3a32c637b31ff60089a}{vTaskMissedYield}();
2235                     \}
2236                     \textcolor{keywordflow}{else}
2237                     \{
2238                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2239                     \}
2240                 \}
2241                 \textcolor{keywordflow}{else}
2242                 \{
2243                     \textcolor{keywordflow}{break};
2244                 \}
2245             \}
2246 \textcolor{preprocessor}{            #endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
2247 
2248             --cTxLock;
2249         \}
2250 
2251         pxQueue->\hyperlink{structQueueDefinition_a24ac3f0707f098da2a22244d843fcf82}{cTxLock} = \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED};
2252     \}
2253     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
2254 
2255     \textcolor{comment}{/* Do the same for the Rx lock. */}
2256     \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
2257     \{
2258         \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} cRxLock = pxQueue->\hyperlink{structQueueDefinition_ac750a3f75a6e174adbc697e473a0dd13}{cRxLock};
2259 
2260         \textcolor{keywordflow}{while}( cRxLock > \hyperlink{queue_8c_a60a95aa91f84782416755f38616231fd}{queueLOCKED\_UNMODIFIED} )
2261         \{
2262             \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
2263             \{
2264                 \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
2265                 \{
2266                     \hyperlink{task_8h_a998c69e37431a3a32c637b31ff60089a}{vTaskMissedYield}();
2267                 \}
2268                 \textcolor{keywordflow}{else}
2269                 \{
2270                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2271                 \}
2272 
2273                 --cRxLock;
2274             \}
2275             \textcolor{keywordflow}{else}
2276             \{
2277                 \textcolor{keywordflow}{break};
2278             \}
2279         \}
2280 
2281         pxQueue->\hyperlink{structQueueDefinition_ac750a3f75a6e174adbc697e473a0dd13}{cRxLock} = \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED};
2282     \}
2283     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
2284 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a4158a6134c9d1c60ffdb18d279d475b1}\label{queue_8c_a4158a6134c9d1c60ffdb18d279d475b1}} 
\index{queue.\+c@{queue.\+c}!ux\+Queue\+Messages\+Waiting@{ux\+Queue\+Messages\+Waiting}}
\index{ux\+Queue\+Messages\+Waiting@{ux\+Queue\+Messages\+Waiting}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{ux\+Queue\+Messages\+Waiting()}{uxQueueMessagesWaiting()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} ux\+Queue\+Messages\+Waiting (\begin{DoxyParamCaption}\item[{const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue }\end{DoxyParamCaption})}



Definition at line 1926 of file queue.\+c.


\begin{DoxyCode}
1927 \{
1928 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxReturn;
1929 
1930     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( xQueue );
1931 
1932     \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
1933     \{
1934         uxReturn = ( ( \hyperlink{structQueueDefinition}{Queue\_t} * ) xQueue )->uxMessagesWaiting;
1935     \}
1936     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1937 
1938     \textcolor{keywordflow}{return} uxReturn;
1939 \} \textcolor{comment}{/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_ad5d110bc27c691ff8da238e0116bf92a}\label{queue_8c_ad5d110bc27c691ff8da238e0116bf92a}} 
\index{queue.\+c@{queue.\+c}!ux\+Queue\+Messages\+Waiting\+From\+I\+SR@{ux\+Queue\+Messages\+Waiting\+From\+I\+SR}}
\index{ux\+Queue\+Messages\+Waiting\+From\+I\+SR@{ux\+Queue\+Messages\+Waiting\+From\+I\+SR}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{ux\+Queue\+Messages\+Waiting\+From\+I\+S\+R()}{uxQueueMessagesWaitingFromISR()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} ux\+Queue\+Messages\+Waiting\+From\+I\+SR (\begin{DoxyParamCaption}\item[{const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue }\end{DoxyParamCaption})}



Definition at line 1959 of file queue.\+c.


\begin{DoxyCode}
1960 \{
1961 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxReturn;
1962 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1963 
1964     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
1965     uxReturn = pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
1966 
1967     \textcolor{keywordflow}{return} uxReturn;
1968 \} \textcolor{comment}{/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a27d6fb77ce7a0b5a16f6471730d33201}\label{queue_8c_a27d6fb77ce7a0b5a16f6471730d33201}} 
\index{queue.\+c@{queue.\+c}!ux\+Queue\+Spaces\+Available@{ux\+Queue\+Spaces\+Available}}
\index{ux\+Queue\+Spaces\+Available@{ux\+Queue\+Spaces\+Available}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{ux\+Queue\+Spaces\+Available()}{uxQueueSpacesAvailable()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{U\+Base\+Type\+\_\+t} ux\+Queue\+Spaces\+Available (\begin{DoxyParamCaption}\item[{const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue }\end{DoxyParamCaption})}



Definition at line 1942 of file queue.\+c.


\begin{DoxyCode}
1943 \{
1944 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxReturn;
1945 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1946 
1947     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
1948 
1949     \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
1950     \{
1951         uxReturn = pxQueue->\hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} - pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
1952     \}
1953     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1954 
1955     \textcolor{keywordflow}{return} uxReturn;
1956 \} \textcolor{comment}{/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a35c0b4f9a0e940cb3a86ca4c5e84c41c}\label{queue_8c_a35c0b4f9a0e940cb3a86ca4c5e84c41c}} 
\index{queue.\+c@{queue.\+c}!v\+Queue\+Delete@{v\+Queue\+Delete}}
\index{v\+Queue\+Delete@{v\+Queue\+Delete}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{v\+Queue\+Delete()}{vQueueDelete()}}
{\footnotesize\ttfamily void v\+Queue\+Delete (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue }\end{DoxyParamCaption})}



Definition at line 1971 of file queue.\+c.


\begin{DoxyCode}
1972 \{
1973 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1974 
1975     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
1976     \hyperlink{FreeRTOS_8h_aae8ebd9c82ecd564953a37bb26a5a1e5}{traceQUEUE\_DELETE}( pxQueue );
1977 
1978 \textcolor{preprocessor}{    #if ( configQUEUE\_REGISTRY\_SIZE > 0 )}
1979     \{
1980         \hyperlink{FreeRTOS_8h_af007b655ee91c919bad9cd2798195899}{vQueueUnregisterQueue}( pxQueue );
1981     \}
1982 \textcolor{preprocessor}{    #endif}
1983 
1984 \textcolor{preprocessor}{    #if( ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) && ( configSUPPORT\_STATIC\_ALLOCATION == 0 ) )}
1985     \{
1986         \textcolor{comment}{/* The queue can only have been allocated dynamically - free it}
1987 \textcolor{comment}{        again. */}
1988         \hyperlink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{vPortFree}( pxQueue );
1989     \}
1990 \textcolor{preprocessor}{    #elif( ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) && ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) )}
1991     \{
1992         \textcolor{comment}{/* The queue could have been allocated statically or dynamically, so}
1993 \textcolor{comment}{        check before attempting to free the memory. */}
1994         \textcolor{keywordflow}{if}( pxQueue->ucStaticallyAllocated == ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} ) \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1995         \{
1996             \hyperlink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{vPortFree}( pxQueue );
1997         \}
1998         \textcolor{keywordflow}{else}
1999         \{
2000             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
2001         \}
2002     \}
2003 \textcolor{preprocessor}{    #else}
2004     \{
2005         \textcolor{comment}{/* The queue must have been statically allocated, so is not going to be}
2006 \textcolor{comment}{        deleted.  Avoid compiler warnings about the unused parameter. */}
2007         ( void ) pxQueue;
2008     \}
2009 \textcolor{preprocessor}{    #endif }\textcolor{comment}{/* configSUPPORT\_DYNAMIC\_ALLOCATION */}\textcolor{preprocessor}{}
2010 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a5e54273dbe3f56b8bdc8f7abee67a871}\label{queue_8c_a5e54273dbe3f56b8bdc8f7abee67a871}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Generic\+Reset@{x\+Queue\+Generic\+Reset}}
\index{x\+Queue\+Generic\+Reset@{x\+Queue\+Generic\+Reset}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Generic\+Reset()}{xQueueGenericReset()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Generic\+Reset (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t}}]{x\+New\+Queue }\end{DoxyParamCaption})}



Definition at line 255 of file queue.\+c.


\begin{DoxyCode}
256 \{
257 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
258 
259     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
260 
261     \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
262     \{
263         pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_acbbdc8eb47b348a824c7bced41512a38}{pcTail} = pxQueue->\hyperlink{structQueueDefinition_a487dc7e43b380c58212cba72bc33e0ed}{pcHead} + ( pxQueue->
      \hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} * pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} ); \textcolor{comment}{/*lint !e9016 Pointer arithmetic allowed on char types,
       especially when it assists conveying intent. */}
264         pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} = ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0U;
265         pxQueue->\hyperlink{structQueueDefinition_abdf13cc013c8488848cee3fce4f0fed3}{pcWriteTo} = pxQueue->\hyperlink{structQueueDefinition_a487dc7e43b380c58212cba72bc33e0ed}{pcHead};
266         pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} = pxQueue->\hyperlink{structQueueDefinition_a487dc7e43b380c58212cba72bc33e0ed}{pcHead} + ( ( pxQueue->
      \hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} - 1U ) * pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} ); \textcolor{comment}{/*lint !e9016 Pointer arithmetic allowed on char
       types, especially when it assists conveying intent. */}
267         pxQueue->\hyperlink{structQueueDefinition_ac750a3f75a6e174adbc697e473a0dd13}{cRxLock} = \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED};
268         pxQueue->\hyperlink{structQueueDefinition_a24ac3f0707f098da2a22244d843fcf82}{cTxLock} = \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED};
269 
270         \textcolor{keywordflow}{if}( xNewQueue == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
271         \{
272             \textcolor{comment}{/* If there are tasks blocked waiting to read from the queue, then}
273 \textcolor{comment}{            the tasks will remain blocked as after this function exits the queue}
274 \textcolor{comment}{            will still be empty.  If there are tasks blocked waiting to write to}
275 \textcolor{comment}{            the queue, then one should be unblocked as after this function exits}
276 \textcolor{comment}{            it will be possible to write to it. */}
277             \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
278             \{
279                 \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
280                 \{
281                     \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
282                 \}
283                 \textcolor{keywordflow}{else}
284                 \{
285                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
286                 \}
287             \}
288             \textcolor{keywordflow}{else}
289             \{
290                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
291             \}
292         \}
293         \textcolor{keywordflow}{else}
294         \{
295             \textcolor{comment}{/* Ensure the event queues start in the correct state. */}
296             \hyperlink{list_8h_adeef7734d7d6d9a3eea642a70c106919}{vListInitialise}( &( pxQueue->\hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) );
297             \hyperlink{list_8h_adeef7734d7d6d9a3eea642a70c106919}{vListInitialise}( &( pxQueue->\hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) );
298         \}
299     \}
300     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
301 
302     \textcolor{comment}{/* A value is returned for calling semantic consistency with previous}
303 \textcolor{comment}{    versions. */}
304     \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
305 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_acb67c81366c00896b21cd826e07d885d}\label{queue_8c_acb67c81366c00896b21cd826e07d885d}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Generic\+Send@{x\+Queue\+Generic\+Send}}
\index{x\+Queue\+Generic\+Send@{x\+Queue\+Generic\+Send}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Generic\+Send()}{xQueueGenericSend()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Generic\+Send (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{const void $\ast$const}]{pv\+Item\+To\+Queue,  }\item[{\hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t}}]{x\+Ticks\+To\+Wait,  }\item[{const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t}}]{x\+Copy\+Position }\end{DoxyParamCaption})}



Definition at line 747 of file queue.\+c.


\begin{DoxyCode}
748 \{
749 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xEntryTimeSet = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE}, xYieldRequired;
750 \hyperlink{structxTIME__OUT}{TimeOut\_t} xTimeOut;
751 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
752 
753     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
754     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( pvItemToQueue == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) && ( pxQueue->
      \hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} != ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0U ) ) );
755     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( xCopyPosition == \hyperlink{queue_8h_a5bb1c4a46d4b08b6d35cf586983476ef}{queueOVERWRITE} ) && ( pxQueue->
      \hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} != 1 ) ) );
756 \textcolor{preprocessor}{    #if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}
757     \{
758         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( \hyperlink{task_8h_a0241000e08a261372186d34825a35979}{xTaskGetSchedulerState}() == 
      \hyperlink{task_8h_a0cad071ca127a35df93166e9ed5b6ada}{taskSCHEDULER\_SUSPENDED} ) && ( xTicksToWait != 0 ) ) );
759     \}
760 \textcolor{preprocessor}{    #endif}
761 
762 
763     \textcolor{comment}{/*lint -save -e904 This function relaxes the coding standard somewhat to}
764 \textcolor{comment}{    allow return statements within the function itself.  This is done in the}
765 \textcolor{comment}{    interest of execution time efficiency. */}
766     \textcolor{keywordflow}{for}( ;; )
767     \{
768         \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
769         \{
770             \textcolor{comment}{/* Is there room on the queue now?  The running task must be the}
771 \textcolor{comment}{            highest priority task wanting to access the queue.  If the head item}
772 \textcolor{comment}{            in the queue is to be overwritten then it does not matter if the}
773 \textcolor{comment}{            queue is full. */}
774             \textcolor{keywordflow}{if}( ( pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} < pxQueue->
      \hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} ) || ( xCopyPosition == \hyperlink{queue_8h_a5bb1c4a46d4b08b6d35cf586983476ef}{queueOVERWRITE} ) )
775             \{
776                 \hyperlink{FreeRTOS_8h_a5cfc9dd899c89966172cb329740f551a}{traceQUEUE\_SEND}( pxQueue );
777 
778 \textcolor{preprocessor}{                #if ( configUSE\_QUEUE\_SETS == 1 )}
779                 \{
780                 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxPreviousMessagesWaiting = pxQueue->
      \hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
781 
782                     xYieldRequired = \hyperlink{queue_8c_a77098159b7735e0c27e27aa7072376c6}{prvCopyDataToQueue}( pxQueue, pvItemToQueue, 
      xCopyPosition );
783 
784                     \textcolor{keywordflow}{if}( pxQueue->pxQueueSetContainer != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
785                     \{
786                         \textcolor{keywordflow}{if}( ( xCopyPosition == \hyperlink{queue_8h_a5bb1c4a46d4b08b6d35cf586983476ef}{queueOVERWRITE} ) && ( 
      uxPreviousMessagesWaiting != ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 ) )
787                         \{
788                             \textcolor{comment}{/* Do not notify the queue set as an existing item}
789 \textcolor{comment}{                            was overwritten in the queue so the number of items}
790 \textcolor{comment}{                            in the queue has not changed. */}
791                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
792                         \}
793                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != 
      \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
794                         \{
795                             \textcolor{comment}{/* The queue is a member of a queue set, and posting}
796 \textcolor{comment}{                            to the queue set caused a higher priority task to}
797 \textcolor{comment}{                            unblock. A context switch is required. */}
798                             \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
799                         \}
800                         \textcolor{keywordflow}{else}
801                         \{
802                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
803                         \}
804                     \}
805                     \textcolor{keywordflow}{else}
806                     \{
807                         \textcolor{comment}{/* If there was a task waiting for data to arrive on the}
808 \textcolor{comment}{                        queue then unblock it now. */}
809                         \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
810                         \{
811                             \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
812                             \{
813                                 \textcolor{comment}{/* The unblocked task has a priority higher than}
814 \textcolor{comment}{                                our own so yield immediately.  Yes it is ok to}
815 \textcolor{comment}{                                do this from within the critical section - the}
816 \textcolor{comment}{                                kernel takes care of that. */}
817                                 \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
818                             \}
819                             \textcolor{keywordflow}{else}
820                             \{
821                                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
822                             \}
823                         \}
824                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xYieldRequired != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
825                         \{
826                             \textcolor{comment}{/* This path is a special case that will only get}
827 \textcolor{comment}{                            executed if the task was holding multiple mutexes}
828 \textcolor{comment}{                            and the mutexes were given back in an order that is}
829 \textcolor{comment}{                            different to that in which they were taken. */}
830                             \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
831                         \}
832                         \textcolor{keywordflow}{else}
833                         \{
834                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
835                         \}
836                     \}
837                 \}
838 \textcolor{preprocessor}{                #else }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
839                 \{
840                     xYieldRequired = \hyperlink{queue_8c_a77098159b7735e0c27e27aa7072376c6}{prvCopyDataToQueue}( pxQueue, pvItemToQueue, 
      xCopyPosition );
841 
842                     \textcolor{comment}{/* If there was a task waiting for data to arrive on the}
843 \textcolor{comment}{                    queue then unblock it now. */}
844                     \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
845                     \{
846                         \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
847                         \{
848                             \textcolor{comment}{/* The unblocked task has a priority higher than}
849 \textcolor{comment}{                            our own so yield immediately.  Yes it is ok to do}
850 \textcolor{comment}{                            this from within the critical section - the kernel}
851 \textcolor{comment}{                            takes care of that. */}
852                             \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
853                         \}
854                         \textcolor{keywordflow}{else}
855                         \{
856                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
857                         \}
858                     \}
859                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xYieldRequired != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
860                     \{
861                         \textcolor{comment}{/* This path is a special case that will only get}
862 \textcolor{comment}{                        executed if the task was holding multiple mutexes and}
863 \textcolor{comment}{                        the mutexes were given back in an order that is}
864 \textcolor{comment}{                        different to that in which they were taken. */}
865                         \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
866                     \}
867                     \textcolor{keywordflow}{else}
868                     \{
869                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
870                     \}
871                 \}
872 \textcolor{preprocessor}{                #endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
873 
874                 \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
875                 \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
876             \}
877             \textcolor{keywordflow}{else}
878             \{
879                 \textcolor{keywordflow}{if}( xTicksToWait == ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0 )
880                 \{
881                     \textcolor{comment}{/* The queue was full and no block time is specified (or}
882 \textcolor{comment}{                    the block time has expired) so leave now. */}
883                     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
884 
885                     \textcolor{comment}{/* Return to the original privilege level before exiting}
886 \textcolor{comment}{                    the function. */}
887                     \hyperlink{FreeRTOS_8h_ab4896b8d7e443200918a6e4a7f64585d}{traceQUEUE\_SEND\_FAILED}( pxQueue );
888                     \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_ae40de11e4044a83a97d2cb5d00ce608b}{errQUEUE\_FULL};
889                 \}
890                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xEntryTimeSet == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
891                 \{
892                     \textcolor{comment}{/* The queue was full and a block time was specified so}
893 \textcolor{comment}{                    configure the timeout structure. */}
894                     \hyperlink{task_8h_a9bff8681d5ed262e71b92805ca0da909}{vTaskInternalSetTimeOutState}( &xTimeOut );
895                     xEntryTimeSet = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
896                 \}
897                 \textcolor{keywordflow}{else}
898                 \{
899                     \textcolor{comment}{/* Entry time was already set. */}
900                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
901                 \}
902             \}
903         \}
904         \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
905 
906         \textcolor{comment}{/* Interrupts and other tasks can send to and receive from the queue}
907 \textcolor{comment}{        now the critical section has been exited. */}
908 
909         \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
910         \hyperlink{queue_8c_ae4efd14c0f4dee7f189ef2e4d9ce1f1b}{prvLockQueue}( pxQueue );
911 
912         \textcolor{comment}{/* Update the timeout state to see if it has expired yet. */}
913         \textcolor{keywordflow}{if}( \hyperlink{task_8h_a3b018a85d339e536a6c05748dd666a3a}{xTaskCheckForTimeOut}( &xTimeOut, &xTicksToWait ) == 
      \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
914         \{
915             \textcolor{keywordflow}{if}( \hyperlink{queue_8c_a70546f6b48a8b715eae3dd84e0546045}{prvIsQueueFull}( pxQueue ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
916             \{
917                 \hyperlink{FreeRTOS_8h_a9484f4523e4bec2ab2dc233f2556c3c5}{traceBLOCKING\_ON\_QUEUE\_SEND}( pxQueue );
918                 \hyperlink{task_8h_a56ae23bc0dece4522d666959902221ca}{vTaskPlaceOnEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ), xTicksToWait );
919 
920                 \textcolor{comment}{/* Unlocking the queue means queue events can effect the}
921 \textcolor{comment}{                event list.  It is possible that interrupts occurring now}
922 \textcolor{comment}{                remove this task from the event list again - but as the}
923 \textcolor{comment}{                scheduler is suspended the task will go onto the pending}
924 \textcolor{comment}{                ready last instead of the actual ready list. */}
925                 \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
926 
927                 \textcolor{comment}{/* Resuming the scheduler will move tasks from the pending}
928 \textcolor{comment}{                ready list into the ready list - so it is feasible that this}
929 \textcolor{comment}{                task is already in a ready list before it yields - in which}
930 \textcolor{comment}{                case the yield will not cause a context switch unless there}
931 \textcolor{comment}{                is also a higher priority task in the pending ready list. */}
932                 \textcolor{keywordflow}{if}( \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}() == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
933                 \{
934                     \hyperlink{FreeRTOS_8h_af4484fc07631a16e45ac5f29a3f0556e}{portYIELD\_WITHIN\_API}();
935                 \}
936             \}
937             \textcolor{keywordflow}{else}
938             \{
939                 \textcolor{comment}{/* Try again. */}
940                 \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
941                 ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
942             \}
943         \}
944         \textcolor{keywordflow}{else}
945         \{
946             \textcolor{comment}{/* The timeout has expired. */}
947             \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
948             ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
949 
950             \hyperlink{FreeRTOS_8h_ab4896b8d7e443200918a6e4a7f64585d}{traceQUEUE\_SEND\_FAILED}( pxQueue );
951             \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_ae40de11e4044a83a97d2cb5d00ce608b}{errQUEUE\_FULL};
952         \}
953     \} \textcolor{comment}{/*lint -restore */}
954 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a0fb58b25eb396a5cf8e1688b7e1a56cb}\label{queue_8c_a0fb58b25eb396a5cf8e1688b7e1a56cb}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Generic\+Send\+From\+I\+SR@{x\+Queue\+Generic\+Send\+From\+I\+SR}}
\index{x\+Queue\+Generic\+Send\+From\+I\+SR@{x\+Queue\+Generic\+Send\+From\+I\+SR}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Generic\+Send\+From\+I\+S\+R()}{xQueueGenericSendFromISR()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Generic\+Send\+From\+I\+SR (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{const void $\ast$const}]{pv\+Item\+To\+Queue,  }\item[{\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} $\ast$const}]{px\+Higher\+Priority\+Task\+Woken,  }\item[{const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t}}]{x\+Copy\+Position }\end{DoxyParamCaption})}



Definition at line 957 of file queue.\+c.


\begin{DoxyCode}
958 \{
959 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn;
960 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxSavedInterruptStatus;
961 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
962 
963     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
964     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( pvItemToQueue == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) && ( pxQueue->
      \hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} != ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0U ) ) );
965     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( xCopyPosition == \hyperlink{queue_8h_a5bb1c4a46d4b08b6d35cf586983476ef}{queueOVERWRITE} ) && ( pxQueue->
      \hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} != 1 ) ) );
966 
967     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}
968 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}
969 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}
970 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}
971 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}
972 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}
973 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}
974 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}
975 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}
976 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}
977 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}
978 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}
979 \textcolor{comment}{    More information (albeit Cortex-M specific) is provided on the following}
980 \textcolor{comment}{    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */}
981     \hyperlink{FreeRTOS_8h_a10f75d20c71c4289f96d1b89cb6c62e2}{portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID}();
982 
983     \textcolor{comment}{/* Similar to xQueueGenericSend, except without blocking if there is no room}
984 \textcolor{comment}{    in the queue.  Also don't directly wake a task that was blocked on a queue}
985 \textcolor{comment}{    read, instead return a flag to say whether a context switch is required or}
986 \textcolor{comment}{    not (i.e. has a task with a higher priority than us been woken by this}
987 \textcolor{comment}{    post). */}
988     uxSavedInterruptStatus = \hyperlink{FreeRTOS_8h_a31b4260dbc1823ba80b578f86eb15a98}{portSET\_INTERRUPT\_MASK\_FROM\_ISR}();
989     \{
990         \textcolor{keywordflow}{if}( ( pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} < pxQueue->\hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} ) || ( xCopyPosition 
      == \hyperlink{queue_8h_a5bb1c4a46d4b08b6d35cf586983476ef}{queueOVERWRITE} ) )
991         \{
992             \textcolor{keyword}{const} \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} cTxLock = pxQueue->\hyperlink{structQueueDefinition_a24ac3f0707f098da2a22244d843fcf82}{cTxLock};
993 
994             \hyperlink{FreeRTOS_8h_a590bfae4dcb6be8a4b3daadf09a1b587}{traceQUEUE\_SEND\_FROM\_ISR}( pxQueue );
995 
996             \textcolor{comment}{/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a}
997 \textcolor{comment}{            semaphore or mutex.  That means prvCopyDataToQueue() cannot result}
998 \textcolor{comment}{            in a task disinheriting a priority and prvCopyDataToQueue() can be}
999 \textcolor{comment}{            called here even though the disinherit function does not check if}
1000 \textcolor{comment}{            the scheduler is suspended before accessing the ready lists. */}
1001             ( void ) \hyperlink{queue_8c_a77098159b7735e0c27e27aa7072376c6}{prvCopyDataToQueue}( pxQueue, pvItemToQueue, xCopyPosition );
1002 
1003             \textcolor{comment}{/* The event list is not altered if the queue is locked.  This will}
1004 \textcolor{comment}{            be done when the queue is unlocked later. */}
1005             \textcolor{keywordflow}{if}( cTxLock == \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED} )
1006             \{
1007 \textcolor{preprocessor}{                #if ( configUSE\_QUEUE\_SETS == 1 )}
1008                 \{
1009                     \textcolor{keywordflow}{if}( pxQueue->pxQueueSetContainer != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1010                     \{
1011                         \textcolor{keywordflow}{if}( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != 
      \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1012                         \{
1013                             \textcolor{comment}{/* The queue is a member of a queue set, and posting}
1014 \textcolor{comment}{                            to the queue set caused a higher priority task to}
1015 \textcolor{comment}{                            unblock.  A context switch is required. */}
1016                             \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1017                             \{
1018                                 *pxHigherPriorityTaskWoken = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1019                             \}
1020                             \textcolor{keywordflow}{else}
1021                             \{
1022                                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1023                             \}
1024                         \}
1025                         \textcolor{keywordflow}{else}
1026                         \{
1027                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1028                         \}
1029                     \}
1030                     \textcolor{keywordflow}{else}
1031                     \{
1032                         \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1033                         \{
1034                             \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1035                             \{
1036                                 \textcolor{comment}{/* The task waiting has a higher priority so}
1037 \textcolor{comment}{                                record that a context switch is required. */}
1038                                 \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1039                                 \{
1040                                     *pxHigherPriorityTaskWoken = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1041                                 \}
1042                                 \textcolor{keywordflow}{else}
1043                                 \{
1044                                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1045                                 \}
1046                             \}
1047                             \textcolor{keywordflow}{else}
1048                             \{
1049                                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1050                             \}
1051                         \}
1052                         \textcolor{keywordflow}{else}
1053                         \{
1054                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1055                         \}
1056                     \}
1057                 \}
1058 \textcolor{preprocessor}{                #else }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
1059                 \{
1060                     \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1061                     \{
1062                         \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1063                         \{
1064                             \textcolor{comment}{/* The task waiting has a higher priority so record that a}
1065 \textcolor{comment}{                            context switch is required. */}
1066                             \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1067                             \{
1068                                 *pxHigherPriorityTaskWoken = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1069                             \}
1070                             \textcolor{keywordflow}{else}
1071                             \{
1072                                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1073                             \}
1074                         \}
1075                         \textcolor{keywordflow}{else}
1076                         \{
1077                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1078                         \}
1079                     \}
1080                     \textcolor{keywordflow}{else}
1081                     \{
1082                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1083                     \}
1084                 \}
1085 \textcolor{preprocessor}{                #endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
1086             \}
1087             \textcolor{keywordflow}{else}
1088             \{
1089                 \textcolor{comment}{/* Increment the lock count so the task that unlocks the queue}
1090 \textcolor{comment}{                knows that data was posted while it was locked. */}
1091                 pxQueue->\hyperlink{structQueueDefinition_a24ac3f0707f098da2a22244d843fcf82}{cTxLock} = ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} ) ( cTxLock + 1 );
1092             \}
1093 
1094             xReturn = \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
1095         \}
1096         \textcolor{keywordflow}{else}
1097         \{
1098             \hyperlink{FreeRTOS_8h_a71fa002ce8a199d38e697d94c613649f}{traceQUEUE\_SEND\_FROM\_ISR\_FAILED}( pxQueue );
1099             xReturn = \hyperlink{projdefs_8h_ae40de11e4044a83a97d2cb5d00ce608b}{errQUEUE\_FULL};
1100         \}
1101     \}
1102     \hyperlink{FreeRTOS_8h_a2661e2c5a4e4afe5bef2ebe9872e28b3}{portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR}( uxSavedInterruptStatus );
1103 
1104     \textcolor{keywordflow}{return} xReturn;
1105 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a4df49fafb6ba4400ede6f2d07a40865f}\label{queue_8c_a4df49fafb6ba4400ede6f2d07a40865f}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Give\+From\+I\+SR@{x\+Queue\+Give\+From\+I\+SR}}
\index{x\+Queue\+Give\+From\+I\+SR@{x\+Queue\+Give\+From\+I\+SR}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Give\+From\+I\+S\+R()}{xQueueGiveFromISR()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Give\+From\+I\+SR (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} $\ast$const}]{px\+Higher\+Priority\+Task\+Woken }\end{DoxyParamCaption})}



Definition at line 1108 of file queue.\+c.


\begin{DoxyCode}
1109 \{
1110 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn;
1111 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxSavedInterruptStatus;
1112 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1113 
1114     \textcolor{comment}{/* Similar to xQueueGenericSendFromISR() but used with semaphores where the}
1115 \textcolor{comment}{    item size is 0.  Don't directly wake a task that was blocked on a queue}
1116 \textcolor{comment}{    read, instead return a flag to say whether a context switch is required or}
1117 \textcolor{comment}{    not (i.e. has a task with a higher priority than us been woken by this}
1118 \textcolor{comment}{    post). */}
1119 
1120     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
1121 
1122     \textcolor{comment}{/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()}
1123 \textcolor{comment}{    if the item size is not 0. */}
1124     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} == 0 );
1125 
1126     \textcolor{comment}{/* Normally a mutex would not be given from an interrupt, especially if}
1127 \textcolor{comment}{    there is a mutex holder, as priority inheritance makes no sense for an}
1128 \textcolor{comment}{    interrupts, only tasks. */}
1129     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( pxQueue->uxQueueType == \hyperlink{queue_8c_a0799077a434aea43f5cca3cda3625aa8}{queueQUEUE\_IS\_MUTEX} ) && ( 
      pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_adb2c0818274974553c619ff953b6f477}{xSemaphore}.\hyperlink{structSemaphoreData_ab1ed54c7b39dc45b3c310fae7ad08693}{xMutexHolder} != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) ) );
1130 
1131     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}
1132 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}
1133 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}
1134 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}
1135 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}
1136 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}
1137 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}
1138 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}
1139 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}
1140 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}
1141 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}
1142 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}
1143 \textcolor{comment}{    More information (albeit Cortex-M specific) is provided on the following}
1144 \textcolor{comment}{    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */}
1145     \hyperlink{FreeRTOS_8h_a10f75d20c71c4289f96d1b89cb6c62e2}{portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID}();
1146 
1147     uxSavedInterruptStatus = \hyperlink{FreeRTOS_8h_a31b4260dbc1823ba80b578f86eb15a98}{portSET\_INTERRUPT\_MASK\_FROM\_ISR}();
1148     \{
1149         \textcolor{keyword}{const} \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxMessagesWaiting = pxQueue->
      \hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
1150 
1151         \textcolor{comment}{/* When the queue is used to implement a semaphore no data is ever}
1152 \textcolor{comment}{        moved through the queue but it is still valid to see if the queue 'has}
1153 \textcolor{comment}{        space'. */}
1154         \textcolor{keywordflow}{if}( uxMessagesWaiting < pxQueue->uxLength )
1155         \{
1156             \textcolor{keyword}{const} \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} cTxLock = pxQueue->\hyperlink{structQueueDefinition_a24ac3f0707f098da2a22244d843fcf82}{cTxLock};
1157 
1158             \hyperlink{FreeRTOS_8h_a590bfae4dcb6be8a4b3daadf09a1b587}{traceQUEUE\_SEND\_FROM\_ISR}( pxQueue );
1159 
1160             \textcolor{comment}{/* A task can only have an inherited priority if it is a mutex}
1161 \textcolor{comment}{            holder - and if there is a mutex holder then the mutex cannot be}
1162 \textcolor{comment}{            given from an ISR.  As this is the ISR version of the function it}
1163 \textcolor{comment}{            can be assumed there is no mutex holder and no need to determine if}
1164 \textcolor{comment}{            priority disinheritance is needed.  Simply increase the count of}
1165 \textcolor{comment}{            messages (semaphores) available. */}
1166             pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} = uxMessagesWaiting + ( 
      \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 1;
1167 
1168             \textcolor{comment}{/* The event list is not altered if the queue is locked.  This will}
1169 \textcolor{comment}{            be done when the queue is unlocked later. */}
1170             \textcolor{keywordflow}{if}( cTxLock == \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED} )
1171             \{
1172 \textcolor{preprocessor}{                #if ( configUSE\_QUEUE\_SETS == 1 )}
1173                 \{
1174                     \textcolor{keywordflow}{if}( pxQueue->pxQueueSetContainer != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1175                     \{
1176                         \textcolor{keywordflow}{if}( prvNotifyQueueSetContainer( pxQueue, 
      \hyperlink{queue_8h_a4d78fa863fbeb90425a2dda08fae8b12}{queueSEND\_TO\_BACK} ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1177                         \{
1178                             \textcolor{comment}{/* The semaphore is a member of a queue set, and}
1179 \textcolor{comment}{                            posting to the queue set caused a higher priority}
1180 \textcolor{comment}{                            task to unblock.  A context switch is required. */}
1181                             \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1182                             \{
1183                                 *pxHigherPriorityTaskWoken = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1184                             \}
1185                             \textcolor{keywordflow}{else}
1186                             \{
1187                                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1188                             \}
1189                         \}
1190                         \textcolor{keywordflow}{else}
1191                         \{
1192                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1193                         \}
1194                     \}
1195                     \textcolor{keywordflow}{else}
1196                     \{
1197                         \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1198                         \{
1199                             \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1200                             \{
1201                                 \textcolor{comment}{/* The task waiting has a higher priority so}
1202 \textcolor{comment}{                                record that a context switch is required. */}
1203                                 \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1204                                 \{
1205                                     *pxHigherPriorityTaskWoken = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1206                                 \}
1207                                 \textcolor{keywordflow}{else}
1208                                 \{
1209                                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1210                                 \}
1211                             \}
1212                             \textcolor{keywordflow}{else}
1213                             \{
1214                                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1215                             \}
1216                         \}
1217                         \textcolor{keywordflow}{else}
1218                         \{
1219                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1220                         \}
1221                     \}
1222                 \}
1223 \textcolor{preprocessor}{                #else }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
1224                 \{
1225                     \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1226                     \{
1227                         \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1228                         \{
1229                             \textcolor{comment}{/* The task waiting has a higher priority so record that a}
1230 \textcolor{comment}{                            context switch is required. */}
1231                             \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1232                             \{
1233                                 *pxHigherPriorityTaskWoken = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1234                             \}
1235                             \textcolor{keywordflow}{else}
1236                             \{
1237                                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1238                             \}
1239                         \}
1240                         \textcolor{keywordflow}{else}
1241                         \{
1242                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1243                         \}
1244                     \}
1245                     \textcolor{keywordflow}{else}
1246                     \{
1247                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1248                     \}
1249                 \}
1250 \textcolor{preprocessor}{                #endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}
1251             \}
1252             \textcolor{keywordflow}{else}
1253             \{
1254                 \textcolor{comment}{/* Increment the lock count so the task that unlocks the queue}
1255 \textcolor{comment}{                knows that data was posted while it was locked. */}
1256                 pxQueue->\hyperlink{structQueueDefinition_a24ac3f0707f098da2a22244d843fcf82}{cTxLock} = ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} ) ( cTxLock + 1 );
1257             \}
1258 
1259             xReturn = \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
1260         \}
1261         \textcolor{keywordflow}{else}
1262         \{
1263             \hyperlink{FreeRTOS_8h_a71fa002ce8a199d38e697d94c613649f}{traceQUEUE\_SEND\_FROM\_ISR\_FAILED}( pxQueue );
1264             xReturn = \hyperlink{projdefs_8h_ae40de11e4044a83a97d2cb5d00ce608b}{errQUEUE\_FULL};
1265         \}
1266     \}
1267     \hyperlink{FreeRTOS_8h_a2661e2c5a4e4afe5bef2ebe9872e28b3}{portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR}( uxSavedInterruptStatus );
1268 
1269     \textcolor{keywordflow}{return} xReturn;
1270 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a7d076f57a56ef50315418f8bbfba96fd}\label{queue_8c_a7d076f57a56ef50315418f8bbfba96fd}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Is\+Queue\+Empty\+From\+I\+SR@{x\+Queue\+Is\+Queue\+Empty\+From\+I\+SR}}
\index{x\+Queue\+Is\+Queue\+Empty\+From\+I\+SR@{x\+Queue\+Is\+Queue\+Empty\+From\+I\+SR}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Is\+Queue\+Empty\+From\+I\+S\+R()}{xQueueIsQueueEmptyFromISR()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Is\+Queue\+Empty\+From\+I\+SR (\begin{DoxyParamCaption}\item[{const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue }\end{DoxyParamCaption})}



Definition at line 2308 of file queue.\+c.


\begin{DoxyCode}
2309 \{
2310 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn;
2311 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
2312 
2313     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
2314     \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} == ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
2315     \{
2316         xReturn = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
2317     \}
2318     \textcolor{keywordflow}{else}
2319     \{
2320         xReturn = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
2321     \}
2322 
2323     \textcolor{keywordflow}{return} xReturn;
2324 \} \textcolor{comment}{/*lint !e818 xQueue could not be pointer to const because it is a typedef. */}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a76bbe8ebd21b3e89784e865d06f1058c}\label{queue_8c_a76bbe8ebd21b3e89784e865d06f1058c}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Is\+Queue\+Full\+From\+I\+SR@{x\+Queue\+Is\+Queue\+Full\+From\+I\+SR}}
\index{x\+Queue\+Is\+Queue\+Full\+From\+I\+SR@{x\+Queue\+Is\+Queue\+Full\+From\+I\+SR}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Is\+Queue\+Full\+From\+I\+S\+R()}{xQueueIsQueueFullFromISR()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Is\+Queue\+Full\+From\+I\+SR (\begin{DoxyParamCaption}\item[{const \hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue }\end{DoxyParamCaption})}



Definition at line 2348 of file queue.\+c.


\begin{DoxyCode}
2349 \{
2350 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn;
2351 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
2352 
2353     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
2354     \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} == pxQueue->\hyperlink{structQueueDefinition_ae80d17a812c669d4d41265b7f693988c}{uxLength} )
2355     \{
2356         xReturn = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
2357     \}
2358     \textcolor{keywordflow}{else}
2359     \{
2360         xReturn = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
2361     \}
2362 
2363     \textcolor{keywordflow}{return} xReturn;
2364 \} \textcolor{comment}{/*lint !e818 xQueue could not be pointer to const because it is a typedef. */}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_a8f68e37e931bbf95440c8845f512e090}\label{queue_8c_a8f68e37e931bbf95440c8845f512e090}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Peek@{x\+Queue\+Peek}}
\index{x\+Queue\+Peek@{x\+Queue\+Peek}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Peek()}{xQueuePeek()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Peek (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{void $\ast$const}]{pv\+Buffer,  }\item[{\hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t}}]{x\+Ticks\+To\+Wait }\end{DoxyParamCaption})}



Definition at line 1632 of file queue.\+c.


\begin{DoxyCode}
1633 \{
1634 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xEntryTimeSet = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
1635 \hyperlink{structxTIME__OUT}{TimeOut\_t} xTimeOut;
1636 \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} *pcOriginalReadPosition;
1637 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1638 
1639     \textcolor{comment}{/* Check the pointer is not NULL. */}
1640     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( pxQueue ) );
1641 
1642     \textcolor{comment}{/* The buffer into which data is received can only be NULL if the data size}
1643 \textcolor{comment}{    is zero (so no data is copied into the buffer. */}
1644     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( ( pvBuffer ) == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) && ( ( pxQueue )->uxItemSize != ( 
      \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0U ) ) );
1645 
1646     \textcolor{comment}{/* Cannot block if the scheduler is suspended. */}
1647 \textcolor{preprocessor}{    #if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}
1648     \{
1649         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( \hyperlink{task_8h_a0241000e08a261372186d34825a35979}{xTaskGetSchedulerState}() == 
      \hyperlink{task_8h_a0cad071ca127a35df93166e9ed5b6ada}{taskSCHEDULER\_SUSPENDED} ) && ( xTicksToWait != 0 ) ) );
1650     \}
1651 \textcolor{preprocessor}{    #endif}
1652 
1653 
1654     \textcolor{comment}{/*lint -save -e904  This function relaxes the coding standard somewhat to}
1655 \textcolor{comment}{    allow return statements within the function itself.  This is done in the}
1656 \textcolor{comment}{    interest of execution time efficiency. */}
1657     \textcolor{keywordflow}{for}( ;; )
1658     \{
1659         \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
1660         \{
1661             \textcolor{keyword}{const} \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxMessagesWaiting = pxQueue->
      \hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
1662 
1663             \textcolor{comment}{/* Is there data in the queue now?  To be running the calling task}
1664 \textcolor{comment}{            must be the highest priority task wanting to access the queue. */}
1665             \textcolor{keywordflow}{if}( uxMessagesWaiting > ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
1666             \{
1667                 \textcolor{comment}{/* Remember the read position so it can be reset after the data}
1668 \textcolor{comment}{                is read from the queue as this function is only peeking the}
1669 \textcolor{comment}{                data, not removing it. */}
1670                 pcOriginalReadPosition = pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom};
1671 
1672                 \hyperlink{queue_8c_ad9a2e17b2b13d4878f7af1361437320e}{prvCopyDataFromQueue}( pxQueue, pvBuffer );
1673                 \hyperlink{FreeRTOS_8h_acd24b909ecdd18ed844cdede3027e534}{traceQUEUE\_PEEK}( pxQueue );
1674 
1675                 \textcolor{comment}{/* The data is not being removed, so reset the read pointer. */}
1676                 pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} = pcOriginalReadPosition;
1677 
1678                 \textcolor{comment}{/* The data is being left in the queue, so see if there are}
1679 \textcolor{comment}{                any other tasks waiting for the data. */}
1680                 \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1681                 \{
1682                     \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1683                     \{
1684                         \textcolor{comment}{/* The task waiting has a higher priority than this task. */}
1685                         \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
1686                     \}
1687                     \textcolor{keywordflow}{else}
1688                     \{
1689                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1690                     \}
1691                 \}
1692                 \textcolor{keywordflow}{else}
1693                 \{
1694                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1695                 \}
1696 
1697                 \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1698                 \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
1699             \}
1700             \textcolor{keywordflow}{else}
1701             \{
1702                 \textcolor{keywordflow}{if}( xTicksToWait == ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0 )
1703                 \{
1704                     \textcolor{comment}{/* The queue was empty and no block time is specified (or}
1705 \textcolor{comment}{                    the block time has expired) so leave now. */}
1706                     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1707                     \hyperlink{FreeRTOS_8h_afa4b34739a92eb44f09947a669c98fb7}{traceQUEUE\_PEEK\_FAILED}( pxQueue );
1708                     \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a4d79b09954b1efa73ad8d87a36b4a575}{errQUEUE\_EMPTY};
1709                 \}
1710                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xEntryTimeSet == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1711                 \{
1712                     \textcolor{comment}{/* The queue was empty and a block time was specified so}
1713 \textcolor{comment}{                    configure the timeout structure ready to enter the blocked}
1714 \textcolor{comment}{                    state. */}
1715                     \hyperlink{task_8h_a9bff8681d5ed262e71b92805ca0da909}{vTaskInternalSetTimeOutState}( &xTimeOut );
1716                     xEntryTimeSet = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1717                 \}
1718                 \textcolor{keywordflow}{else}
1719                 \{
1720                     \textcolor{comment}{/* Entry time was already set. */}
1721                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1722                 \}
1723             \}
1724         \}
1725         \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1726 
1727         \textcolor{comment}{/* Interrupts and other tasks can send to and receive from the queue}
1728 \textcolor{comment}{        now the critical section has been exited. */}
1729 
1730         \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
1731         \hyperlink{queue_8c_ae4efd14c0f4dee7f189ef2e4d9ce1f1b}{prvLockQueue}( pxQueue );
1732 
1733         \textcolor{comment}{/* Update the timeout state to see if it has expired yet. */}
1734         \textcolor{keywordflow}{if}( \hyperlink{task_8h_a3b018a85d339e536a6c05748dd666a3a}{xTaskCheckForTimeOut}( &xTimeOut, &xTicksToWait ) == 
      \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1735         \{
1736             \textcolor{comment}{/* Timeout has not expired yet, check to see if there is data in the}
1737 \textcolor{comment}{            queue now, and if not enter the Blocked state to wait for data. */}
1738             \textcolor{keywordflow}{if}( \hyperlink{queue_8c_a8f21d4b7a21be0d109953120c93f6741}{prvIsQueueEmpty}( pxQueue ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1739             \{
1740                 \hyperlink{FreeRTOS_8h_a186c66f73c470500e556ec0f2fd3994f}{traceBLOCKING\_ON\_QUEUE\_PEEK}( pxQueue );
1741                 \hyperlink{task_8h_a56ae23bc0dece4522d666959902221ca}{vTaskPlaceOnEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ), xTicksToWait );
1742                 \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1743                 \textcolor{keywordflow}{if}( \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}() == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1744                 \{
1745                     \hyperlink{FreeRTOS_8h_af4484fc07631a16e45ac5f29a3f0556e}{portYIELD\_WITHIN\_API}();
1746                 \}
1747                 \textcolor{keywordflow}{else}
1748                 \{
1749                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1750                 \}
1751             \}
1752             \textcolor{keywordflow}{else}
1753             \{
1754                 \textcolor{comment}{/* There is data in the queue now, so don't enter the blocked}
1755 \textcolor{comment}{                state, instead return to try and obtain the data. */}
1756                 \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1757                 ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
1758             \}
1759         \}
1760         \textcolor{keywordflow}{else}
1761         \{
1762             \textcolor{comment}{/* The timeout has expired.  If there is still no data in the queue}
1763 \textcolor{comment}{            exit, otherwise go back and try to read the data again. */}
1764             \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1765             ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
1766 
1767             \textcolor{keywordflow}{if}( \hyperlink{queue_8c_a8f21d4b7a21be0d109953120c93f6741}{prvIsQueueEmpty}( pxQueue ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1768             \{
1769                 \hyperlink{FreeRTOS_8h_afa4b34739a92eb44f09947a669c98fb7}{traceQUEUE\_PEEK\_FAILED}( pxQueue );
1770                 \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a4d79b09954b1efa73ad8d87a36b4a575}{errQUEUE\_EMPTY};
1771             \}
1772             \textcolor{keywordflow}{else}
1773             \{
1774                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1775             \}
1776         \}
1777     \} \textcolor{comment}{/*lint -restore */}
1778 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_af67763957452955ac663c374d71278ce}\label{queue_8c_af67763957452955ac663c374d71278ce}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Peek\+From\+I\+SR@{x\+Queue\+Peek\+From\+I\+SR}}
\index{x\+Queue\+Peek\+From\+I\+SR@{x\+Queue\+Peek\+From\+I\+SR}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Peek\+From\+I\+S\+R()}{xQueuePeekFromISR()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Peek\+From\+I\+SR (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{void $\ast$const}]{pv\+Buffer }\end{DoxyParamCaption})}



Definition at line 1872 of file queue.\+c.


\begin{DoxyCode}
1873 \{
1874 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn;
1875 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxSavedInterruptStatus;
1876 \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} *pcOriginalReadPosition;
1877 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1878 
1879     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
1880     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( pvBuffer == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) && ( pxQueue->
      \hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} != ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0U ) ) );
1881     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} != 0 ); \textcolor{comment}{/* Can't peek a semaphore. */}
1882 
1883     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}
1884 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}
1885 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}
1886 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}
1887 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}
1888 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}
1889 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}
1890 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}
1891 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}
1892 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}
1893 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}
1894 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}
1895 \textcolor{comment}{    More information (albeit Cortex-M specific) is provided on the following}
1896 \textcolor{comment}{    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */}
1897     \hyperlink{FreeRTOS_8h_a10f75d20c71c4289f96d1b89cb6c62e2}{portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID}();
1898 
1899     uxSavedInterruptStatus = \hyperlink{FreeRTOS_8h_a31b4260dbc1823ba80b578f86eb15a98}{portSET\_INTERRUPT\_MASK\_FROM\_ISR}();
1900     \{
1901         \textcolor{comment}{/* Cannot block in an ISR, so check there is data available. */}
1902         \textcolor{keywordflow}{if}( pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} > ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
1903         \{
1904             \hyperlink{FreeRTOS_8h_a3e2a14b61c26f9690deb26d76cc801ee}{traceQUEUE\_PEEK\_FROM\_ISR}( pxQueue );
1905 
1906             \textcolor{comment}{/* Remember the read position so it can be reset as nothing is}
1907 \textcolor{comment}{            actually being removed from the queue. */}
1908             pcOriginalReadPosition = pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom};
1909             \hyperlink{queue_8c_ad9a2e17b2b13d4878f7af1361437320e}{prvCopyDataFromQueue}( pxQueue, pvBuffer );
1910             pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_aea4a2daf33054ff6b535f158bd4007f0}{xQueue}.\hyperlink{structQueuePointers_af381d02bbe6bc4a77934c6fd97598913}{pcReadFrom} = pcOriginalReadPosition;
1911 
1912             xReturn = \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
1913         \}
1914         \textcolor{keywordflow}{else}
1915         \{
1916             xReturn = \hyperlink{projdefs_8h_a99e2866c8cf4fe86db87dab62e7d6aa6}{pdFAIL};
1917             \hyperlink{FreeRTOS_8h_a72ea0f09cc6a38363f2b5217aab27fd3}{traceQUEUE\_PEEK\_FROM\_ISR\_FAILED}( pxQueue );
1918         \}
1919     \}
1920     \hyperlink{FreeRTOS_8h_a2661e2c5a4e4afe5bef2ebe9872e28b3}{portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR}( uxSavedInterruptStatus );
1921 
1922     \textcolor{keywordflow}{return} xReturn;
1923 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_ad0a166f3b1219a5e37e31f8090d4800d}\label{queue_8c_ad0a166f3b1219a5e37e31f8090d4800d}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Receive@{x\+Queue\+Receive}}
\index{x\+Queue\+Receive@{x\+Queue\+Receive}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Receive()}{xQueueReceive()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Receive (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{void $\ast$const}]{pv\+Buffer,  }\item[{\hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t}}]{x\+Ticks\+To\+Wait }\end{DoxyParamCaption})}



Definition at line 1273 of file queue.\+c.


\begin{DoxyCode}
1274 \{
1275 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xEntryTimeSet = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
1276 \hyperlink{structxTIME__OUT}{TimeOut\_t} xTimeOut;
1277 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1278 
1279     \textcolor{comment}{/* Check the pointer is not NULL. */}
1280     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( pxQueue ) );
1281 
1282     \textcolor{comment}{/* The buffer into which data is received can only be NULL if the data size}
1283 \textcolor{comment}{    is zero (so no data is copied into the buffer. */}
1284     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( ( pvBuffer ) == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) && ( ( pxQueue )->uxItemSize != ( 
      \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0U ) ) );
1285 
1286     \textcolor{comment}{/* Cannot block if the scheduler is suspended. */}
1287 \textcolor{preprocessor}{    #if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}
1288     \{
1289         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( \hyperlink{task_8h_a0241000e08a261372186d34825a35979}{xTaskGetSchedulerState}() == 
      \hyperlink{task_8h_a0cad071ca127a35df93166e9ed5b6ada}{taskSCHEDULER\_SUSPENDED} ) && ( xTicksToWait != 0 ) ) );
1290     \}
1291 \textcolor{preprocessor}{    #endif}
1292 
1293 
1294     \textcolor{comment}{/*lint -save -e904  This function relaxes the coding standard somewhat to}
1295 \textcolor{comment}{    allow return statements within the function itself.  This is done in the}
1296 \textcolor{comment}{    interest of execution time efficiency. */}
1297     \textcolor{keywordflow}{for}( ;; )
1298     \{
1299         \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
1300         \{
1301             \textcolor{keyword}{const} \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxMessagesWaiting = pxQueue->
      \hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
1302 
1303             \textcolor{comment}{/* Is there data in the queue now?  To be running the calling task}
1304 \textcolor{comment}{            must be the highest priority task wanting to access the queue. */}
1305             \textcolor{keywordflow}{if}( uxMessagesWaiting > ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
1306             \{
1307                 \textcolor{comment}{/* Data available, remove one item. */}
1308                 \hyperlink{queue_8c_ad9a2e17b2b13d4878f7af1361437320e}{prvCopyDataFromQueue}( pxQueue, pvBuffer );
1309                 \hyperlink{FreeRTOS_8h_a82b39aa722910a5e43793e882ded0faf}{traceQUEUE\_RECEIVE}( pxQueue );
1310                 pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} = uxMessagesWaiting - ( 
      \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 1;
1311 
1312                 \textcolor{comment}{/* There is now space in the queue, were any tasks waiting to}
1313 \textcolor{comment}{                post to the queue?  If so, unblock the highest priority waiting}
1314 \textcolor{comment}{                task. */}
1315                 \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1316                 \{
1317                     \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1318                     \{
1319                         \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
1320                     \}
1321                     \textcolor{keywordflow}{else}
1322                     \{
1323                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1324                     \}
1325                 \}
1326                 \textcolor{keywordflow}{else}
1327                 \{
1328                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1329                 \}
1330 
1331                 \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1332                 \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
1333             \}
1334             \textcolor{keywordflow}{else}
1335             \{
1336                 \textcolor{keywordflow}{if}( xTicksToWait == ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0 )
1337                 \{
1338                     \textcolor{comment}{/* The queue was empty and no block time is specified (or}
1339 \textcolor{comment}{                    the block time has expired) so leave now. */}
1340                     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1341                     \hyperlink{FreeRTOS_8h_a0dbf5969c9d984920177a19d5b402e4e}{traceQUEUE\_RECEIVE\_FAILED}( pxQueue );
1342                     \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a4d79b09954b1efa73ad8d87a36b4a575}{errQUEUE\_EMPTY};
1343                 \}
1344                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xEntryTimeSet == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1345                 \{
1346                     \textcolor{comment}{/* The queue was empty and a block time was specified so}
1347 \textcolor{comment}{                    configure the timeout structure. */}
1348                     \hyperlink{task_8h_a9bff8681d5ed262e71b92805ca0da909}{vTaskInternalSetTimeOutState}( &xTimeOut );
1349                     xEntryTimeSet = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1350                 \}
1351                 \textcolor{keywordflow}{else}
1352                 \{
1353                     \textcolor{comment}{/* Entry time was already set. */}
1354                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1355                 \}
1356             \}
1357         \}
1358         \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1359 
1360         \textcolor{comment}{/* Interrupts and other tasks can send to and receive from the queue}
1361 \textcolor{comment}{        now the critical section has been exited. */}
1362 
1363         \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
1364         \hyperlink{queue_8c_ae4efd14c0f4dee7f189ef2e4d9ce1f1b}{prvLockQueue}( pxQueue );
1365 
1366         \textcolor{comment}{/* Update the timeout state to see if it has expired yet. */}
1367         \textcolor{keywordflow}{if}( \hyperlink{task_8h_a3b018a85d339e536a6c05748dd666a3a}{xTaskCheckForTimeOut}( &xTimeOut, &xTicksToWait ) == 
      \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1368         \{
1369             \textcolor{comment}{/* The timeout has not expired.  If the queue is still empty place}
1370 \textcolor{comment}{            the task on the list of tasks waiting to receive from the queue. */}
1371             \textcolor{keywordflow}{if}( \hyperlink{queue_8c_a8f21d4b7a21be0d109953120c93f6741}{prvIsQueueEmpty}( pxQueue ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1372             \{
1373                 \hyperlink{FreeRTOS_8h_a657997eddb8c89bef7157e74bac003e2}{traceBLOCKING\_ON\_QUEUE\_RECEIVE}( pxQueue );
1374                 \hyperlink{task_8h_a56ae23bc0dece4522d666959902221ca}{vTaskPlaceOnEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ), xTicksToWait );
1375                 \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1376                 \textcolor{keywordflow}{if}( \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}() == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1377                 \{
1378                     \hyperlink{FreeRTOS_8h_af4484fc07631a16e45ac5f29a3f0556e}{portYIELD\_WITHIN\_API}();
1379                 \}
1380                 \textcolor{keywordflow}{else}
1381                 \{
1382                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1383                 \}
1384             \}
1385             \textcolor{keywordflow}{else}
1386             \{
1387                 \textcolor{comment}{/* The queue contains data again.  Loop back to try and read the}
1388 \textcolor{comment}{                data. */}
1389                 \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1390                 ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
1391             \}
1392         \}
1393         \textcolor{keywordflow}{else}
1394         \{
1395             \textcolor{comment}{/* Timed out.  If there is no data in the queue exit, otherwise loop}
1396 \textcolor{comment}{            back and attempt to read the data. */}
1397             \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1398             ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
1399 
1400             \textcolor{keywordflow}{if}( \hyperlink{queue_8c_a8f21d4b7a21be0d109953120c93f6741}{prvIsQueueEmpty}( pxQueue ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1401             \{
1402                 \hyperlink{FreeRTOS_8h_a0dbf5969c9d984920177a19d5b402e4e}{traceQUEUE\_RECEIVE\_FAILED}( pxQueue );
1403                 \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a4d79b09954b1efa73ad8d87a36b4a575}{errQUEUE\_EMPTY};
1404             \}
1405             \textcolor{keywordflow}{else}
1406             \{
1407                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1408             \}
1409         \}
1410     \} \textcolor{comment}{/*lint -restore */}
1411 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_ac61ec62828e70ed35d18559a35550462}\label{queue_8c_ac61ec62828e70ed35d18559a35550462}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Receive\+From\+I\+SR@{x\+Queue\+Receive\+From\+I\+SR}}
\index{x\+Queue\+Receive\+From\+I\+SR@{x\+Queue\+Receive\+From\+I\+SR}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Receive\+From\+I\+S\+R()}{xQueueReceiveFromISR()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Receive\+From\+I\+SR (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{void $\ast$const}]{pv\+Buffer,  }\item[{\hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} $\ast$const}]{px\+Higher\+Priority\+Task\+Woken }\end{DoxyParamCaption})}



Definition at line 1781 of file queue.\+c.


\begin{DoxyCode}
1782 \{
1783 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xReturn;
1784 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxSavedInterruptStatus;
1785 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1786 
1787     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue );
1788     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( pvBuffer == \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} ) && ( pxQueue->
      \hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} != ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0U ) ) );
1789 
1790     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}
1791 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}
1792 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}
1793 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}
1794 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}
1795 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}
1796 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}
1797 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}
1798 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}
1799 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}
1800 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}
1801 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}
1802 \textcolor{comment}{    More information (albeit Cortex-M specific) is provided on the following}
1803 \textcolor{comment}{    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */}
1804     \hyperlink{FreeRTOS_8h_a10f75d20c71c4289f96d1b89cb6c62e2}{portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID}();
1805 
1806     uxSavedInterruptStatus = \hyperlink{FreeRTOS_8h_a31b4260dbc1823ba80b578f86eb15a98}{portSET\_INTERRUPT\_MASK\_FROM\_ISR}();
1807     \{
1808         \textcolor{keyword}{const} \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxMessagesWaiting = pxQueue->
      \hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
1809 
1810         \textcolor{comment}{/* Cannot block in an ISR, so check there is data available. */}
1811         \textcolor{keywordflow}{if}( uxMessagesWaiting > ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
1812         \{
1813             \textcolor{keyword}{const} \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} cRxLock = pxQueue->\hyperlink{structQueueDefinition_ac750a3f75a6e174adbc697e473a0dd13}{cRxLock};
1814 
1815             \hyperlink{FreeRTOS_8h_ace59eac86a08f533c19edf91594961c6}{traceQUEUE\_RECEIVE\_FROM\_ISR}( pxQueue );
1816 
1817             \hyperlink{queue_8c_ad9a2e17b2b13d4878f7af1361437320e}{prvCopyDataFromQueue}( pxQueue, pvBuffer );
1818             pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} = uxMessagesWaiting - ( 
      \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 1;
1819 
1820             \textcolor{comment}{/* If the queue is locked the event list will not be modified.}
1821 \textcolor{comment}{            Instead update the lock count so the task that unlocks the queue}
1822 \textcolor{comment}{            will know that an ISR has removed data while the queue was}
1823 \textcolor{comment}{            locked. */}
1824             \textcolor{keywordflow}{if}( cRxLock == \hyperlink{queue_8c_acdb781ba6b38714cf41f7417de8fe6bf}{queueUNLOCKED} )
1825             \{
1826                 \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1827                 \{
1828                     \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1829                     \{
1830                         \textcolor{comment}{/* The task waiting has a higher priority than us so}
1831 \textcolor{comment}{                        force a context switch. */}
1832                         \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL} )
1833                         \{
1834                             *pxHigherPriorityTaskWoken = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1835                         \}
1836                         \textcolor{keywordflow}{else}
1837                         \{
1838                             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1839                         \}
1840                     \}
1841                     \textcolor{keywordflow}{else}
1842                     \{
1843                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1844                     \}
1845                 \}
1846                 \textcolor{keywordflow}{else}
1847                 \{
1848                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1849                 \}
1850             \}
1851             \textcolor{keywordflow}{else}
1852             \{
1853                 \textcolor{comment}{/* Increment the lock count so the task that unlocks the queue}
1854 \textcolor{comment}{                knows that data was removed while it was locked. */}
1855                 pxQueue->\hyperlink{structQueueDefinition_ac750a3f75a6e174adbc697e473a0dd13}{cRxLock} = ( \hyperlink{stdint_8h_aef44329758059c91c76d334e8fc09700}{int8\_t} ) ( cRxLock + 1 );
1856             \}
1857 
1858             xReturn = \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
1859         \}
1860         \textcolor{keywordflow}{else}
1861         \{
1862             xReturn = \hyperlink{projdefs_8h_a99e2866c8cf4fe86db87dab62e7d6aa6}{pdFAIL};
1863             \hyperlink{FreeRTOS_8h_a1f1f4a1fea93a33050fa6c27c30752d5}{traceQUEUE\_RECEIVE\_FROM\_ISR\_FAILED}( pxQueue );
1864         \}
1865     \}
1866     \hyperlink{FreeRTOS_8h_a2661e2c5a4e4afe5bef2ebe9872e28b3}{portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR}( uxSavedInterruptStatus );
1867 
1868     \textcolor{keywordflow}{return} xReturn;
1869 \}
\end{DoxyCode}
\mbox{\Hypertarget{queue_8c_ade45e48664e5ec17ea091f00cd34394f}\label{queue_8c_ade45e48664e5ec17ea091f00cd34394f}} 
\index{queue.\+c@{queue.\+c}!x\+Queue\+Semaphore\+Take@{x\+Queue\+Semaphore\+Take}}
\index{x\+Queue\+Semaphore\+Take@{x\+Queue\+Semaphore\+Take}!queue.\+c@{queue.\+c}}
\subsubsection{\texorpdfstring{x\+Queue\+Semaphore\+Take()}{xQueueSemaphoreTake()}}
{\footnotesize\ttfamily \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Queue\+Semaphore\+Take (\begin{DoxyParamCaption}\item[{\hyperlink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{Queue\+Handle\+\_\+t}}]{x\+Queue,  }\item[{\hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t}}]{x\+Ticks\+To\+Wait }\end{DoxyParamCaption})}



Definition at line 1414 of file queue.\+c.


\begin{DoxyCode}
1415 \{
1416 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xEntryTimeSet = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
1417 \hyperlink{structxTIME__OUT}{TimeOut\_t} xTimeOut;
1418 \hyperlink{structQueueDefinition}{Queue\_t} * \textcolor{keyword}{const} pxQueue = xQueue;
1419 
1420 \textcolor{preprocessor}{#if( configUSE\_MUTEXES == 1 )}
1421     \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xInheritanceOccurred = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
1422 \textcolor{preprocessor}{#endif}
1423 
1424     \textcolor{comment}{/* Check the queue pointer is not NULL. */}
1425     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( pxQueue ) );
1426 
1427     \textcolor{comment}{/* Check this really is a semaphore, in which case the item size will be}
1428 \textcolor{comment}{    0. */}
1429     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxQueue->\hyperlink{structQueueDefinition_a81bb7d3826909244baa9debf5a55abb0}{uxItemSize} == 0 );
1430 
1431     \textcolor{comment}{/* Cannot block if the scheduler is suspended. */}
1432 \textcolor{preprocessor}{    #if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}
1433     \{
1434         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( \hyperlink{task_8h_a0241000e08a261372186d34825a35979}{xTaskGetSchedulerState}() == 
      \hyperlink{task_8h_a0cad071ca127a35df93166e9ed5b6ada}{taskSCHEDULER\_SUSPENDED} ) && ( xTicksToWait != 0 ) ) );
1435     \}
1436 \textcolor{preprocessor}{    #endif}
1437 
1438 
1439     \textcolor{comment}{/*lint -save -e904 This function relaxes the coding standard somewhat to allow return}
1440 \textcolor{comment}{    statements within the function itself.  This is done in the interest}
1441 \textcolor{comment}{    of execution time efficiency. */}
1442     \textcolor{keywordflow}{for}( ;; )
1443     \{
1444         \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
1445         \{
1446             \textcolor{comment}{/* Semaphores are queues with an item size of 0, and where the}
1447 \textcolor{comment}{            number of messages in the queue is the semaphore's count value. */}
1448             \textcolor{keyword}{const} \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxSemaphoreCount = pxQueue->
      \hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting};
1449 
1450             \textcolor{comment}{/* Is there data in the queue now?  To be running the calling task}
1451 \textcolor{comment}{            must be the highest priority task wanting to access the queue. */}
1452             \textcolor{keywordflow}{if}( uxSemaphoreCount > ( \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
1453             \{
1454                 \hyperlink{FreeRTOS_8h_a82b39aa722910a5e43793e882ded0faf}{traceQUEUE\_RECEIVE}( pxQueue );
1455 
1456                 \textcolor{comment}{/* Semaphores are queues with a data size of zero and where the}
1457 \textcolor{comment}{                messages waiting is the semaphore's count.  Reduce the count. */}
1458                 pxQueue->\hyperlink{structQueueDefinition_a12b07a40152d0f21488ca06d362d13d1}{uxMessagesWaiting} = uxSemaphoreCount - ( 
      \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 1;
1459 
1460 \textcolor{preprocessor}{                #if ( configUSE\_MUTEXES == 1 )}
1461                 \{
1462                     \textcolor{keywordflow}{if}( pxQueue->uxQueueType == \hyperlink{queue_8c_a0799077a434aea43f5cca3cda3625aa8}{queueQUEUE\_IS\_MUTEX} )
1463                     \{
1464                         \textcolor{comment}{/* Record the information required to implement}
1465 \textcolor{comment}{                        priority inheritance should it become necessary. */}
1466                         pxQueue->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_adb2c0818274974553c619ff953b6f477}{xSemaphore}.\hyperlink{structSemaphoreData_ab1ed54c7b39dc45b3c310fae7ad08693}{xMutexHolder} = 
      \hyperlink{task_8h_a54430b124666d513049dcbf888e6935f}{pvTaskIncrementMutexHeldCount}();
1467                     \}
1468                     \textcolor{keywordflow}{else}
1469                     \{
1470                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1471                     \}
1472                 \}
1473 \textcolor{preprocessor}{                #endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}
1474 
1475                 \textcolor{comment}{/* Check to see if other tasks are blocked waiting to give the}
1476 \textcolor{comment}{                semaphore, and if so, unblock the highest priority such task. */}
1477                 \textcolor{keywordflow}{if}( \hyperlink{list_8h_aaba6eb05d67ebc8026bea29193eca28f}{listLIST\_IS\_EMPTY}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1478                 \{
1479                     \textcolor{keywordflow}{if}( \hyperlink{task_8h_a14513b7dd36055f73fba3c5ebbdc1b06}{xTaskRemoveFromEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_aaab135c4345cb0393d6ff3cd5164c7b2}{xTasksWaitingToSend} ) ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1480                     \{
1481                         \hyperlink{queue_8c_adb4472163ac5b0e8ad72183d69387b81}{queueYIELD\_IF\_USING\_PREEMPTION}();
1482                     \}
1483                     \textcolor{keywordflow}{else}
1484                     \{
1485                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1486                     \}
1487                 \}
1488                 \textcolor{keywordflow}{else}
1489                 \{
1490                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1491                 \}
1492 
1493                 \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1494                 \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS};
1495             \}
1496             \textcolor{keywordflow}{else}
1497             \{
1498                 \textcolor{keywordflow}{if}( xTicksToWait == ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0 )
1499                 \{
1500                     \textcolor{comment}{/* For inheritance to have occurred there must have been an}
1501 \textcolor{comment}{                    initial timeout, and an adjusted timeout cannot become 0, as}
1502 \textcolor{comment}{                    if it were 0 the function would have exited. */}
1503 \textcolor{preprocessor}{                    #if( configUSE\_MUTEXES == 1 )}
1504                     \{
1505                         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( xInheritanceOccurred == 
      \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} );
1506                     \}
1507 \textcolor{preprocessor}{                    #endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}
1508 
1509                     \textcolor{comment}{/* The semaphore count was 0 and no block time is specified}
1510 \textcolor{comment}{                    (or the block time has expired) so exit now. */}
1511                     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1512                     \hyperlink{FreeRTOS_8h_a0dbf5969c9d984920177a19d5b402e4e}{traceQUEUE\_RECEIVE\_FAILED}( pxQueue );
1513                     \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a4d79b09954b1efa73ad8d87a36b4a575}{errQUEUE\_EMPTY};
1514                 \}
1515                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xEntryTimeSet == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1516                 \{
1517                     \textcolor{comment}{/* The semaphore count was 0 and a block time was specified}
1518 \textcolor{comment}{                    so configure the timeout structure ready to block. */}
1519                     \hyperlink{task_8h_a9bff8681d5ed262e71b92805ca0da909}{vTaskInternalSetTimeOutState}( &xTimeOut );
1520                     xEntryTimeSet = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
1521                 \}
1522                 \textcolor{keywordflow}{else}
1523                 \{
1524                     \textcolor{comment}{/* Entry time was already set. */}
1525                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1526                 \}
1527             \}
1528         \}
1529         \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1530 
1531         \textcolor{comment}{/* Interrupts and other tasks can give to and take from the semaphore}
1532 \textcolor{comment}{        now the critical section has been exited. */}
1533 
1534         \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
1535         \hyperlink{queue_8c_ae4efd14c0f4dee7f189ef2e4d9ce1f1b}{prvLockQueue}( pxQueue );
1536 
1537         \textcolor{comment}{/* Update the timeout state to see if it has expired yet. */}
1538         \textcolor{keywordflow}{if}( \hyperlink{task_8h_a3b018a85d339e536a6c05748dd666a3a}{xTaskCheckForTimeOut}( &xTimeOut, &xTicksToWait ) == 
      \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1539         \{
1540             \textcolor{comment}{/* A block time is specified and not expired.  If the semaphore}
1541 \textcolor{comment}{            count is 0 then enter the Blocked state to wait for a semaphore to}
1542 \textcolor{comment}{            become available.  As semaphores are implemented with queues the}
1543 \textcolor{comment}{            queue being empty is equivalent to the semaphore count being 0. */}
1544             \textcolor{keywordflow}{if}( \hyperlink{queue_8c_a8f21d4b7a21be0d109953120c93f6741}{prvIsQueueEmpty}( pxQueue ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1545             \{
1546                 \hyperlink{FreeRTOS_8h_a657997eddb8c89bef7157e74bac003e2}{traceBLOCKING\_ON\_QUEUE\_RECEIVE}( pxQueue );
1547 
1548 \textcolor{preprocessor}{                #if ( configUSE\_MUTEXES == 1 )}
1549                 \{
1550                     \textcolor{keywordflow}{if}( pxQueue->uxQueueType == \hyperlink{queue_8c_a0799077a434aea43f5cca3cda3625aa8}{queueQUEUE\_IS\_MUTEX} )
1551                     \{
1552                         \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
1553                         \{
1554                             xInheritanceOccurred = \hyperlink{task_8h_aa715a488a6014df5a9393ca38c5938c0}{xTaskPriorityInherit}( pxQueue->
      \hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_adb2c0818274974553c619ff953b6f477}{xSemaphore}.\hyperlink{structSemaphoreData_ab1ed54c7b39dc45b3c310fae7ad08693}{xMutexHolder} );
1555                         \}
1556                         \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1557                     \}
1558                     \textcolor{keywordflow}{else}
1559                     \{
1560                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1561                     \}
1562                 \}
1563 \textcolor{preprocessor}{                #endif}
1564 
1565                 \hyperlink{task_8h_a56ae23bc0dece4522d666959902221ca}{vTaskPlaceOnEventList}( &( pxQueue->
      \hyperlink{structQueueDefinition_af6d61526f77beee659cd604a0c473359}{xTasksWaitingToReceive} ), xTicksToWait );
1566                 \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1567                 \textcolor{keywordflow}{if}( \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}() == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1568                 \{
1569                     \hyperlink{FreeRTOS_8h_af4484fc07631a16e45ac5f29a3f0556e}{portYIELD\_WITHIN\_API}();
1570                 \}
1571                 \textcolor{keywordflow}{else}
1572                 \{
1573                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1574                 \}
1575             \}
1576             \textcolor{keywordflow}{else}
1577             \{
1578                 \textcolor{comment}{/* There was no timeout and the semaphore count was not 0, so}
1579 \textcolor{comment}{                attempt to take the semaphore again. */}
1580                 \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1581                 ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
1582             \}
1583         \}
1584         \textcolor{keywordflow}{else}
1585         \{
1586             \textcolor{comment}{/* Timed out. */}
1587             \hyperlink{queue_8c_a7297c84a7c770ed57567bad1d3e2faf6}{prvUnlockQueue}( pxQueue );
1588             ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
1589 
1590             \textcolor{comment}{/* If the semaphore count is 0 exit now as the timeout has}
1591 \textcolor{comment}{            expired.  Otherwise return to attempt to take the semaphore that is}
1592 \textcolor{comment}{            known to be available.  As semaphores are implemented by queues the}
1593 \textcolor{comment}{            queue being empty is equivalent to the semaphore count being 0. */}
1594             \textcolor{keywordflow}{if}( \hyperlink{queue_8c_a8f21d4b7a21be0d109953120c93f6741}{prvIsQueueEmpty}( pxQueue ) != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1595             \{
1596 \textcolor{preprocessor}{                #if ( configUSE\_MUTEXES == 1 )}
1597                 \{
1598                     \textcolor{comment}{/* xInheritanceOccurred could only have be set if}
1599 \textcolor{comment}{                    pxQueue->uxQueueType == queueQUEUE\_IS\_MUTEX so no need to}
1600 \textcolor{comment}{                    test the mutex type again to check it is actually a mutex. */}
1601                     \textcolor{keywordflow}{if}( xInheritanceOccurred != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
1602                     \{
1603                         \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
1604                         \{
1605                             \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxHighestWaitingPriority;
1606 
1607                             \textcolor{comment}{/* This task blocking on the mutex caused another}
1608 \textcolor{comment}{                            task to inherit this task's priority.  Now this task}
1609 \textcolor{comment}{                            has timed out the priority should be disinherited}
1610 \textcolor{comment}{                            again, but only as low as the next highest priority}
1611 \textcolor{comment}{                            task that is waiting for the same mutex. */}
1612                             uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1613                             \hyperlink{task_8h_aa11e6a58d2534fe91ed8ee3a02c9b5e0}{vTaskPriorityDisinheritAfterTimeout}( pxQueue
      ->\hyperlink{structQueueDefinition_a23e83b160ae20e3e6d4b7a78203cd45d}{u}.\hyperlink{structQueueDefinition_adb2c0818274974553c619ff953b6f477}{xSemaphore}.\hyperlink{structSemaphoreData_ab1ed54c7b39dc45b3c310fae7ad08693}{xMutexHolder}, uxHighestWaitingPriority );
1614                         \}
1615                         \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
1616                     \}
1617                 \}
1618 \textcolor{preprocessor}{                #endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}
1619 
1620                 \hyperlink{FreeRTOS_8h_a0dbf5969c9d984920177a19d5b402e4e}{traceQUEUE\_RECEIVE\_FAILED}( pxQueue );
1621                 \textcolor{keywordflow}{return} \hyperlink{projdefs_8h_a4d79b09954b1efa73ad8d87a36b4a575}{errQUEUE\_EMPTY};
1622             \}
1623             \textcolor{keywordflow}{else}
1624             \{
1625                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
1626             \}
1627         \}
1628     \} \textcolor{comment}{/*lint -restore */}
1629 \}
\end{DoxyCode}
