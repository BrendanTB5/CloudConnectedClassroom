\hypertarget{event__groups_8h}{}\section{third\+\_\+party/freertos/include/event\+\_\+groups.h File Reference}
\label{event__groups_8h}\index{third\+\_\+party/freertos/include/event\+\_\+groups.\+h@{third\+\_\+party/freertos/include/event\+\_\+groups.\+h}}
{\ttfamily \#include \char`\"{}timers.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{event__groups_8h_a3d7de214a697f33fe7b914e26a93f33a}{x\+Event\+Group\+Clear\+Bits\+From\+I\+SR}(x\+Event\+Group,  ux\+Bits\+To\+Clear)~\hyperlink{timers_8h_ae0d9338933037e6feebe6437763fa299}{x\+Timer\+Pend\+Function\+Call\+From\+I\+SR}( \hyperlink{event__groups_8h_a9187a137998183178320167de254cce9}{v\+Event\+Group\+Clear\+Bits\+Callback}, ( void $\ast$ ) x\+Event\+Group, ( \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\+\_\+t} ) ux\+Bits\+To\+Clear, \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL} )
\item 
\#define \hyperlink{event__groups_8h_a62b68278abac6358369ae8e390988a02}{x\+Event\+Group\+Set\+Bits\+From\+I\+SR}(x\+Event\+Group,  ux\+Bits\+To\+Set,  px\+Higher\+Priority\+Task\+Woken)~\hyperlink{timers_8h_ae0d9338933037e6feebe6437763fa299}{x\+Timer\+Pend\+Function\+Call\+From\+I\+SR}( \hyperlink{event__groups_8h_abe76a301815525eb5e03f331e5e51ae3}{v\+Event\+Group\+Set\+Bits\+Callback}, ( void $\ast$ ) x\+Event\+Group, ( \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\+\_\+t} ) ux\+Bits\+To\+Set, px\+Higher\+Priority\+Task\+Woken )
\item 
\#define \hyperlink{event__groups_8h_a0ae86f092fb07ccb475ae938f9a12584}{x\+Event\+Group\+Get\+Bits}(x\+Event\+Group)~\hyperlink{event__groups_8h_a0fb72cfdd4f0d5f86d955fc3af448f2a}{x\+Event\+Group\+Clear\+Bits}( x\+Event\+Group, 0 )
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structEventGroupDef__t}{Event\+Group\+Def\+\_\+t} $\ast$ \hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t}
\item 
typedef \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} \hyperlink{event__groups_8h_aab9d5b405bc57b7624dcabe9a9a503db}{x\+Event\+Group\+Wait\+Bits} (\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t} x\+Event\+Group, const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} ux\+Bits\+To\+Wait\+For, const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Clear\+On\+Exit, const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t} x\+Wait\+For\+All\+Bits, \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} x\+Ticks\+To\+Wait) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
\hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} \hyperlink{event__groups_8h_a0fb72cfdd4f0d5f86d955fc3af448f2a}{x\+Event\+Group\+Clear\+Bits} (\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t} x\+Event\+Group, const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} ux\+Bits\+To\+Clear) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
\hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} \hyperlink{event__groups_8h_a02d7b3bb55f7e11d9c47116266c5fb2e}{x\+Event\+Group\+Set\+Bits} (\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t} x\+Event\+Group, const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} ux\+Bits\+To\+Set) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
\hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} \hyperlink{event__groups_8h_a869511456b86426f52e2eec898bff341}{x\+Event\+Group\+Sync} (\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t} x\+Event\+Group, const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} ux\+Bits\+To\+Set, const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} ux\+Bits\+To\+Wait\+For, \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} x\+Ticks\+To\+Wait) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
\hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} \hyperlink{event__groups_8h_a95822db4357d0b77c35aed0c7427eca0}{x\+Event\+Group\+Get\+Bits\+From\+I\+SR} (\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t} x\+Event\+Group) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
void \hyperlink{event__groups_8h_a50cb52d1c81b063fd8d94f5293dcfea9}{v\+Event\+Group\+Delete} (\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t} x\+Event\+Group) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
void \hyperlink{event__groups_8h_abe76a301815525eb5e03f331e5e51ae3}{v\+Event\+Group\+Set\+Bits\+Callback} (void $\ast$pv\+Event\+Group, const \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\+\_\+t} ul\+Bits\+To\+Set) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\item 
void \hyperlink{event__groups_8h_a9187a137998183178320167de254cce9}{v\+Event\+Group\+Clear\+Bits\+Callback} (void $\ast$pv\+Event\+Group, const \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\+\_\+t} ul\+Bits\+To\+Clear) \hyperlink{mpu__wrappers_8h_a4785c4f4a8c04b835139dcc2a6682078}{P\+R\+I\+V\+I\+L\+E\+G\+E\+D\+\_\+\+F\+U\+N\+C\+T\+I\+ON}
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{event__groups_8h_a3d7de214a697f33fe7b914e26a93f33a}\label{event__groups_8h_a3d7de214a697f33fe7b914e26a93f33a}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!x\+Event\+Group\+Clear\+Bits\+From\+I\+SR@{x\+Event\+Group\+Clear\+Bits\+From\+I\+SR}}
\index{x\+Event\+Group\+Clear\+Bits\+From\+I\+SR@{x\+Event\+Group\+Clear\+Bits\+From\+I\+SR}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{x\+Event\+Group\+Clear\+Bits\+From\+I\+SR}{xEventGroupClearBitsFromISR}}
{\footnotesize\ttfamily \#define x\+Event\+Group\+Clear\+Bits\+From\+I\+SR(\begin{DoxyParamCaption}\item[{}]{x\+Event\+Group,  }\item[{}]{ux\+Bits\+To\+Clear }\end{DoxyParamCaption})~\hyperlink{timers_8h_ae0d9338933037e6feebe6437763fa299}{x\+Timer\+Pend\+Function\+Call\+From\+I\+SR}( \hyperlink{event__groups_8h_a9187a137998183178320167de254cce9}{v\+Event\+Group\+Clear\+Bits\+Callback}, ( void $\ast$ ) x\+Event\+Group, ( \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\+\_\+t} ) ux\+Bits\+To\+Clear, \hyperlink{group__BSPDefine_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL} )}



Definition at line 410 of file event\+\_\+groups.\+h.

\mbox{\Hypertarget{event__groups_8h_a0ae86f092fb07ccb475ae938f9a12584}\label{event__groups_8h_a0ae86f092fb07ccb475ae938f9a12584}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!x\+Event\+Group\+Get\+Bits@{x\+Event\+Group\+Get\+Bits}}
\index{x\+Event\+Group\+Get\+Bits@{x\+Event\+Group\+Get\+Bits}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{x\+Event\+Group\+Get\+Bits}{xEventGroupGetBits}}
{\footnotesize\ttfamily \#define x\+Event\+Group\+Get\+Bits(\begin{DoxyParamCaption}\item[{}]{x\+Event\+Group }\end{DoxyParamCaption})~\hyperlink{event__groups_8h_a0fb72cfdd4f0d5f86d955fc3af448f2a}{x\+Event\+Group\+Clear\+Bits}( x\+Event\+Group, 0 )}



Definition at line 708 of file event\+\_\+groups.\+h.

\mbox{\Hypertarget{event__groups_8h_a62b68278abac6358369ae8e390988a02}\label{event__groups_8h_a62b68278abac6358369ae8e390988a02}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!x\+Event\+Group\+Set\+Bits\+From\+I\+SR@{x\+Event\+Group\+Set\+Bits\+From\+I\+SR}}
\index{x\+Event\+Group\+Set\+Bits\+From\+I\+SR@{x\+Event\+Group\+Set\+Bits\+From\+I\+SR}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{x\+Event\+Group\+Set\+Bits\+From\+I\+SR}{xEventGroupSetBitsFromISR}}
{\footnotesize\ttfamily \#define x\+Event\+Group\+Set\+Bits\+From\+I\+SR(\begin{DoxyParamCaption}\item[{}]{x\+Event\+Group,  }\item[{}]{ux\+Bits\+To\+Set,  }\item[{}]{px\+Higher\+Priority\+Task\+Woken }\end{DoxyParamCaption})~\hyperlink{timers_8h_ae0d9338933037e6feebe6437763fa299}{x\+Timer\+Pend\+Function\+Call\+From\+I\+SR}( \hyperlink{event__groups_8h_abe76a301815525eb5e03f331e5e51ae3}{v\+Event\+Group\+Set\+Bits\+Callback}, ( void $\ast$ ) x\+Event\+Group, ( \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\+\_\+t} ) ux\+Bits\+To\+Set, px\+Higher\+Priority\+Task\+Woken )}



Definition at line 562 of file event\+\_\+groups.\+h.



\subsection{Typedef Documentation}
\mbox{\Hypertarget{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}\label{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!Event\+Bits\+\_\+t@{Event\+Bits\+\_\+t}}
\index{Event\+Bits\+\_\+t@{Event\+Bits\+\_\+t}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{Event\+Bits\+\_\+t}{EventBits\_t}}
{\footnotesize\ttfamily typedef \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t} \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t}}



Definition at line 92 of file event\+\_\+groups.\+h.

\mbox{\Hypertarget{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}\label{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!Event\+Group\+Handle\+\_\+t@{Event\+Group\+Handle\+\_\+t}}
\index{Event\+Group\+Handle\+\_\+t@{Event\+Group\+Handle\+\_\+t}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{Event\+Group\+Handle\+\_\+t}{EventGroupHandle\_t}}
{\footnotesize\ttfamily typedef struct \hyperlink{structEventGroupDef__t}{Event\+Group\+Def\+\_\+t}$\ast$ \hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t}}



Definition at line 82 of file event\+\_\+groups.\+h.



\subsection{Function Documentation}
\mbox{\Hypertarget{event__groups_8h_a9187a137998183178320167de254cce9}\label{event__groups_8h_a9187a137998183178320167de254cce9}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!v\+Event\+Group\+Clear\+Bits\+Callback@{v\+Event\+Group\+Clear\+Bits\+Callback}}
\index{v\+Event\+Group\+Clear\+Bits\+Callback@{v\+Event\+Group\+Clear\+Bits\+Callback}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{v\+Event\+Group\+Clear\+Bits\+Callback()}{vEventGroupClearBitsCallback()}}
{\footnotesize\ttfamily void v\+Event\+Group\+Clear\+Bits\+Callback (\begin{DoxyParamCaption}\item[{void $\ast$}]{pv\+Event\+Group,  }\item[{const \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\+\_\+t}}]{ul\+Bits\+To\+Clear }\end{DoxyParamCaption})}



Definition at line 665 of file event\+\_\+groups.\+c.


\begin{DoxyCode}
666 \{
667     ( void ) \hyperlink{event__groups_8c_a71dd2680fdfbdde7d6b10db203e266ba}{xEventGroupClearBits}( pvEventGroup, ( 
      \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} ) ulBitsToClear ); \textcolor{comment}{/*lint !e9079 Can't avoid cast to void* as a generic timer
       callback prototype. Callback casts back to original type so safe. */}
668 \}
\end{DoxyCode}
\mbox{\Hypertarget{event__groups_8h_a50cb52d1c81b063fd8d94f5293dcfea9}\label{event__groups_8h_a50cb52d1c81b063fd8d94f5293dcfea9}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!v\+Event\+Group\+Delete@{v\+Event\+Group\+Delete}}
\index{v\+Event\+Group\+Delete@{v\+Event\+Group\+Delete}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{v\+Event\+Group\+Delete()}{vEventGroupDelete()}}
{\footnotesize\ttfamily void v\+Event\+Group\+Delete (\begin{DoxyParamCaption}\item[{\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t}}]{x\+Event\+Group }\end{DoxyParamCaption})}

event\+\_\+groups.\+h 
\begin{DoxyPre}
   void xEventGroupDelete( EventGroupHandle\_t xEventGroup );
\end{DoxyPre}


Delete an event group that was previously created by a call to x\+Event\+Group\+Create(). Tasks that are blocked on the event group will be unblocked and obtain 0 as the event group\textquotesingle{}s value.


\begin{DoxyParams}{Parameters}
{\em x\+Event\+Group} & The event group being deleted. \\
\hline
\end{DoxyParams}


Definition at line 613 of file event\+\_\+groups.\+c.


\begin{DoxyCode}
614 \{
615 \hyperlink{structEventGroupDef__t}{EventGroup\_t} *pxEventBits = xEventGroup;
616 \textcolor{keyword}{const} \hyperlink{structxLIST}{List\_t} *pxTasksWaitingForBits = &( pxEventBits->\hyperlink{structEventGroupDef__t_a3dd347560456bfe452415efb52760dc3}{xTasksWaitingForBits} );
617 
618     \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
619     \{
620         \hyperlink{FreeRTOS_8h_abf48364a72dd38af47bf7203c06ee832}{traceEVENT\_GROUP\_DELETE}( xEventGroup );
621 
622         \textcolor{keywordflow}{while}( \hyperlink{list_8h_a18b4aded515bdc512017ea6e677a13bb}{listCURRENT\_LIST\_LENGTH}( pxTasksWaitingForBits ) > ( 
      \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} ) 0 )
623         \{
624             \textcolor{comment}{/* Unblock the task, returning 0 as the event list is being deleted}
625 \textcolor{comment}{            and cannot therefore have any bits set. */}
626             \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( pxTasksWaitingForBits->\hyperlink{structxLIST_a49ad62fa153126e27e273811167b336a}{xListEnd}.
      \hyperlink{structxMINI__LIST__ITEM_aa7ae770b0f10daeb9ac76c6f7dd5608e}{pxNext} != ( \textcolor{keyword}{const} \hyperlink{structxLIST__ITEM}{ListItem\_t} * ) &( pxTasksWaitingForBits->
      \hyperlink{structxLIST_a49ad62fa153126e27e273811167b336a}{xListEnd} ) );
627             \hyperlink{task_8h_a340b9bc9f37c9d4d3fb6e303c3ef311b}{vTaskRemoveFromUnorderedEventList}( pxTasksWaitingForBits->
      \hyperlink{structxLIST_a49ad62fa153126e27e273811167b336a}{xListEnd}.\hyperlink{structxMINI__LIST__ITEM_aa7ae770b0f10daeb9ac76c6f7dd5608e}{pxNext}, \hyperlink{event__groups_8c_ab451d5ad95813d5ec7ff1784d69e9ec3}{eventUNBLOCKED\_DUE\_TO\_BIT\_SET} );
628         \}
629 
630 \textcolor{preprocessor}{        #if( ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) && ( configSUPPORT\_STATIC\_ALLOCATION == 0 ) )}
631         \{
632             \textcolor{comment}{/* The event group can only have been allocated dynamically - free}
633 \textcolor{comment}{            it again. */}
634             \hyperlink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{vPortFree}( pxEventBits );
635         \}
636 \textcolor{preprocessor}{        #elif( ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) && ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) )}
637         \{
638             \textcolor{comment}{/* The event group could have been allocated statically or}
639 \textcolor{comment}{            dynamically, so check before attempting to free the memory. */}
640             \textcolor{keywordflow}{if}( pxEventBits->ucStaticallyAllocated == ( \hyperlink{stdint_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\_t} ) \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
641             \{
642                 \hyperlink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{vPortFree}( pxEventBits );
643             \}
644             \textcolor{keywordflow}{else}
645             \{
646                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
647             \}
648         \}
649 \textcolor{preprocessor}{        #endif }\textcolor{comment}{/* configSUPPORT\_DYNAMIC\_ALLOCATION */}\textcolor{preprocessor}{}
650     \}
651     ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
652 \}
\end{DoxyCode}
\mbox{\Hypertarget{event__groups_8h_abe76a301815525eb5e03f331e5e51ae3}\label{event__groups_8h_abe76a301815525eb5e03f331e5e51ae3}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!v\+Event\+Group\+Set\+Bits\+Callback@{v\+Event\+Group\+Set\+Bits\+Callback}}
\index{v\+Event\+Group\+Set\+Bits\+Callback@{v\+Event\+Group\+Set\+Bits\+Callback}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{v\+Event\+Group\+Set\+Bits\+Callback()}{vEventGroupSetBitsCallback()}}
{\footnotesize\ttfamily void v\+Event\+Group\+Set\+Bits\+Callback (\begin{DoxyParamCaption}\item[{void $\ast$}]{pv\+Event\+Group,  }\item[{const \hyperlink{stdint_8h_a435d1572bf3f880d55459d9805097f62}{uint32\+\_\+t}}]{ul\+Bits\+To\+Set }\end{DoxyParamCaption})}



Definition at line 657 of file event\+\_\+groups.\+c.


\begin{DoxyCode}
658 \{
659     ( void ) \hyperlink{event__groups_8c_a9ac7cd970f50e2e50a494b656e0eb239}{xEventGroupSetBits}( pvEventGroup, ( \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} ) ulBitsToSet ); \textcolor{comment}{
      /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to
       original type so safe. */}
660 \}
\end{DoxyCode}
\mbox{\Hypertarget{event__groups_8h_a0fb72cfdd4f0d5f86d955fc3af448f2a}\label{event__groups_8h_a0fb72cfdd4f0d5f86d955fc3af448f2a}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!x\+Event\+Group\+Clear\+Bits@{x\+Event\+Group\+Clear\+Bits}}
\index{x\+Event\+Group\+Clear\+Bits@{x\+Event\+Group\+Clear\+Bits}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{x\+Event\+Group\+Clear\+Bits()}{xEventGroupClearBits()}}
{\footnotesize\ttfamily \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} x\+Event\+Group\+Clear\+Bits (\begin{DoxyParamCaption}\item[{\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t}}]{x\+Event\+Group,  }\item[{const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t}}]{ux\+Bits\+To\+Clear }\end{DoxyParamCaption})}



Definition at line 461 of file event\+\_\+groups.\+c.


\begin{DoxyCode}
462 \{
463 \hyperlink{structEventGroupDef__t}{EventGroup\_t} *pxEventBits = xEventGroup;
464 \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} uxReturn;
465 
466     \textcolor{comment}{/* Check the user is not attempting to clear the bits used by the kernel}
467 \textcolor{comment}{    itself. */}
468     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( xEventGroup );
469     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( uxBitsToClear & \hyperlink{event__groups_8c_a46c8292a6ba88b017cca402f5baf670b}{eventEVENT\_BITS\_CONTROL\_BYTES} 
      ) == 0 );
470 
471     \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
472     \{
473         \hyperlink{FreeRTOS_8h_ad929200fa50e5a1ae2c5894ffeea2ef6}{traceEVENT\_GROUP\_CLEAR\_BITS}( xEventGroup, uxBitsToClear );
474 
475         \textcolor{comment}{/* The value returned is the event group value prior to the bits being}
476 \textcolor{comment}{        cleared. */}
477         uxReturn = pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits};
478 
479         \textcolor{comment}{/* Clear the bits. */}
480         pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} &= ~uxBitsToClear;
481     \}
482     \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
483 
484     \textcolor{keywordflow}{return} uxReturn;
485 \}
\end{DoxyCode}
\mbox{\Hypertarget{event__groups_8h_a95822db4357d0b77c35aed0c7427eca0}\label{event__groups_8h_a95822db4357d0b77c35aed0c7427eca0}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!x\+Event\+Group\+Get\+Bits\+From\+I\+SR@{x\+Event\+Group\+Get\+Bits\+From\+I\+SR}}
\index{x\+Event\+Group\+Get\+Bits\+From\+I\+SR@{x\+Event\+Group\+Get\+Bits\+From\+I\+SR}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{x\+Event\+Group\+Get\+Bits\+From\+I\+S\+R()}{xEventGroupGetBitsFromISR()}}
{\footnotesize\ttfamily \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} x\+Event\+Group\+Get\+Bits\+From\+I\+SR (\begin{DoxyParamCaption}\item[{\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t}}]{x\+Event\+Group }\end{DoxyParamCaption})}



Definition at line 503 of file event\+\_\+groups.\+c.


\begin{DoxyCode}
504 \{
505 \hyperlink{pic32mx_2portmacro_8h_a646f89d4298e4f5afd522202b11cb2e6}{UBaseType\_t} uxSavedInterruptStatus;
506 \hyperlink{structEventGroupDef__t}{EventGroup\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} pxEventBits = xEventGroup;
507 \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} uxReturn;
508 
509     uxSavedInterruptStatus = \hyperlink{FreeRTOS_8h_a31b4260dbc1823ba80b578f86eb15a98}{portSET\_INTERRUPT\_MASK\_FROM\_ISR}();
510     \{
511         uxReturn = pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits};
512     \}
513     \hyperlink{FreeRTOS_8h_a2661e2c5a4e4afe5bef2ebe9872e28b3}{portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR}( uxSavedInterruptStatus );
514 
515     \textcolor{keywordflow}{return} uxReturn;
516 \} \textcolor{comment}{/*lint !e818 EventGroupHandle\_t is a typedef used in other functions to so can't be pointer to const. */}
\end{DoxyCode}
\mbox{\Hypertarget{event__groups_8h_a02d7b3bb55f7e11d9c47116266c5fb2e}\label{event__groups_8h_a02d7b3bb55f7e11d9c47116266c5fb2e}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!x\+Event\+Group\+Set\+Bits@{x\+Event\+Group\+Set\+Bits}}
\index{x\+Event\+Group\+Set\+Bits@{x\+Event\+Group\+Set\+Bits}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{x\+Event\+Group\+Set\+Bits()}{xEventGroupSetBits()}}
{\footnotesize\ttfamily \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} x\+Event\+Group\+Set\+Bits (\begin{DoxyParamCaption}\item[{\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t}}]{x\+Event\+Group,  }\item[{const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t}}]{ux\+Bits\+To\+Set }\end{DoxyParamCaption})}



Definition at line 519 of file event\+\_\+groups.\+c.


\begin{DoxyCode}
520 \{
521 \hyperlink{structxLIST__ITEM}{ListItem\_t} *pxListItem, *pxNext;
522 \hyperlink{structxLIST__ITEM}{ListItem\_t} \textcolor{keyword}{const} *pxListEnd;
523 \hyperlink{structxLIST}{List\_t} \textcolor{keyword}{const} * pxList;
524 \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
525 \hyperlink{structEventGroupDef__t}{EventGroup\_t} *pxEventBits = xEventGroup;
526 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xMatchFound = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
527 
528     \textcolor{comment}{/* Check the user is not attempting to set the bits used by the kernel}
529 \textcolor{comment}{    itself. */}
530     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( xEventGroup );
531     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( uxBitsToSet & \hyperlink{event__groups_8c_a46c8292a6ba88b017cca402f5baf670b}{eventEVENT\_BITS\_CONTROL\_BYTES} ) 
      == 0 );
532 
533     pxList = &( pxEventBits->\hyperlink{structEventGroupDef__t_a3dd347560456bfe452415efb52760dc3}{xTasksWaitingForBits} );
534     pxListEnd = \hyperlink{list_8h_a96cb0919f02e5c0d8e41ded0e65197a3}{listGET\_END\_MARKER}( pxList ); \textcolor{comment}{/*lint !e826 !e740 !e9087 The mini list
       structure is used as the list end to save RAM.  This is checked and valid. */}
535     \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
536     \{
537         \hyperlink{FreeRTOS_8h_a56eb08eb12a36c99a32729a518d5b3fd}{traceEVENT\_GROUP\_SET\_BITS}( xEventGroup, uxBitsToSet );
538 
539         pxListItem = \hyperlink{list_8h_a987cb2766e509022c23b654907cea199}{listGET\_HEAD\_ENTRY}( pxList );
540 
541         \textcolor{comment}{/* Set the bits. */}
542         pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} |= uxBitsToSet;
543 
544         \textcolor{comment}{/* See if the new bit value should unblock any tasks. */}
545         \textcolor{keywordflow}{while}( pxListItem != pxListEnd )
546         \{
547             pxNext = \hyperlink{list_8h_aabf78d3f24ba56ac1d0bf0179438b960}{listGET\_NEXT}( pxListItem );
548             uxBitsWaitedFor = \hyperlink{list_8h_aa50d09950abc602741d7ebe8387f4e1a}{listGET\_LIST\_ITEM\_VALUE}( pxListItem );
549             xMatchFound = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
550 
551             \textcolor{comment}{/* Split the bits waited for from the control bits. */}
552             uxControlBits = uxBitsWaitedFor & \hyperlink{event__groups_8c_a46c8292a6ba88b017cca402f5baf670b}{eventEVENT\_BITS\_CONTROL\_BYTES};
553             uxBitsWaitedFor &= ~eventEVENT\_BITS\_CONTROL\_BYTES;
554 
555             \textcolor{keywordflow}{if}( ( uxControlBits & \hyperlink{event__groups_8c_ae98d5f1271845ad42742aef9659e1568}{eventWAIT\_FOR\_ALL\_BITS} ) == ( 
      \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} ) 0 )
556             \{
557                 \textcolor{comment}{/* Just looking for single bit being set. */}
558                 \textcolor{keywordflow}{if}( ( uxBitsWaitedFor & pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} ) != ( 
      \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} ) 0 )
559                 \{
560                     xMatchFound = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
561                 \}
562                 \textcolor{keywordflow}{else}
563                 \{
564                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
565                 \}
566             \}
567             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ( uxBitsWaitedFor & pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} ) == uxBitsWaitedFor )
568             \{
569                 \textcolor{comment}{/* All bits are set. */}
570                 xMatchFound = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
571             \}
572             \textcolor{keywordflow}{else}
573             \{
574                 \textcolor{comment}{/* Need all bits to be set, but not all the bits were set. */}
575             \}
576 
577             \textcolor{keywordflow}{if}( xMatchFound != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
578             \{
579                 \textcolor{comment}{/* The bits match.  Should the bits be cleared on exit? */}
580                 \textcolor{keywordflow}{if}( ( uxControlBits & \hyperlink{event__groups_8c_a1404686af7c8070fa57675707c817abc}{eventCLEAR\_EVENTS\_ON\_EXIT\_BIT} ) != ( 
      \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} ) 0 )
581                 \{
582                     uxBitsToClear |= uxBitsWaitedFor;
583                 \}
584                 \textcolor{keywordflow}{else}
585                 \{
586                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
587                 \}
588 
589                 \textcolor{comment}{/* Store the actual event flag value in the task's event list}
590 \textcolor{comment}{                item before removing the task from the event list.  The}
591 \textcolor{comment}{                eventUNBLOCKED\_DUE\_TO\_BIT\_SET bit is set so the task knows}
592 \textcolor{comment}{                that is was unblocked due to its required bits matching, rather}
593 \textcolor{comment}{                than because it timed out. */}
594                 \hyperlink{task_8h_a340b9bc9f37c9d4d3fb6e303c3ef311b}{vTaskRemoveFromUnorderedEventList}( pxListItem, pxEventBits
      ->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} | \hyperlink{event__groups_8c_ab451d5ad95813d5ec7ff1784d69e9ec3}{eventUNBLOCKED\_DUE\_TO\_BIT\_SET} );
595             \}
596 
597             \textcolor{comment}{/* Move onto the next list item.  Note pxListItem->pxNext is not}
598 \textcolor{comment}{            used here as the list item may have been removed from the event list}
599 \textcolor{comment}{            and inserted into the ready/pending reading list. */}
600             pxListItem = pxNext;
601         \}
602 
603         \textcolor{comment}{/* Clear any bits that matched when the eventCLEAR\_EVENTS\_ON\_EXIT\_BIT}
604 \textcolor{comment}{        bit was set in the control word. */}
605         pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} &= ~uxBitsToClear;
606     \}
607     ( void ) \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
608 
609     \textcolor{keywordflow}{return} pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits};
610 \}
\end{DoxyCode}
\mbox{\Hypertarget{event__groups_8h_a869511456b86426f52e2eec898bff341}\label{event__groups_8h_a869511456b86426f52e2eec898bff341}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!x\+Event\+Group\+Sync@{x\+Event\+Group\+Sync}}
\index{x\+Event\+Group\+Sync@{x\+Event\+Group\+Sync}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{x\+Event\+Group\+Sync()}{xEventGroupSync()}}
{\footnotesize\ttfamily \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} x\+Event\+Group\+Sync (\begin{DoxyParamCaption}\item[{\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t}}]{x\+Event\+Group,  }\item[{const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t}}]{ux\+Bits\+To\+Set,  }\item[{const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t}}]{ux\+Bits\+To\+Wait\+For,  }\item[{\hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t}}]{x\+Ticks\+To\+Wait }\end{DoxyParamCaption})}



Definition at line 191 of file event\+\_\+groups.\+c.


\begin{DoxyCode}
192 \{
193 \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} uxOriginalBitValue, uxReturn;
194 \hyperlink{structEventGroupDef__t}{EventGroup\_t} *pxEventBits = xEventGroup;
195 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xAlreadyYielded;
196 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xTimeoutOccurred = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
197 
198     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( uxBitsToWaitFor & \hyperlink{event__groups_8c_a46c8292a6ba88b017cca402f5baf670b}{eventEVENT\_BITS\_CONTROL\_BYTES}
       ) == 0 );
199     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( uxBitsToWaitFor != 0 );
200 \textcolor{preprocessor}{    #if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}
201     \{
202         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( \hyperlink{task_8h_a0241000e08a261372186d34825a35979}{xTaskGetSchedulerState}() == 
      \hyperlink{task_8h_a0cad071ca127a35df93166e9ed5b6ada}{taskSCHEDULER\_SUSPENDED} ) && ( xTicksToWait != 0 ) ) );
203     \}
204 \textcolor{preprocessor}{    #endif}
205 
206     \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
207     \{
208         uxOriginalBitValue = pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits};
209 
210         ( void ) \hyperlink{event__groups_8c_a9ac7cd970f50e2e50a494b656e0eb239}{xEventGroupSetBits}( xEventGroup, uxBitsToSet );
211 
212         \textcolor{keywordflow}{if}( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
213         \{
214             \textcolor{comment}{/* All the rendezvous bits are now set - no need to block. */}
215             uxReturn = ( uxOriginalBitValue | uxBitsToSet );
216 
217             \textcolor{comment}{/* Rendezvous always clear the bits.  They will have been cleared}
218 \textcolor{comment}{            already unless this is the only task in the rendezvous. */}
219             pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} &= ~uxBitsToWaitFor;
220 
221             xTicksToWait = 0;
222         \}
223         \textcolor{keywordflow}{else}
224         \{
225             \textcolor{keywordflow}{if}( xTicksToWait != ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0 )
226             \{
227                 \hyperlink{FreeRTOS_8h_a898ead658f344a0475a9f2ed3bf8f407}{traceEVENT\_GROUP\_SYNC\_BLOCK}( xEventGroup, uxBitsToSet, 
      uxBitsToWaitFor );
228 
229                 \textcolor{comment}{/* Store the bits that the calling task is waiting for in the}
230 \textcolor{comment}{                task's event list item so the kernel knows when a match is}
231 \textcolor{comment}{                found.  Then enter the blocked state. */}
232                 \hyperlink{task_8h_a9d52fa7b60cc6a7b4fd0846700d7834c}{vTaskPlaceOnUnorderedEventList}( &( pxEventBits->
      \hyperlink{structEventGroupDef__t_a3dd347560456bfe452415efb52760dc3}{xTasksWaitingForBits} ), ( uxBitsToWaitFor | 
      \hyperlink{event__groups_8c_a1404686af7c8070fa57675707c817abc}{eventCLEAR\_EVENTS\_ON\_EXIT\_BIT} | 
      \hyperlink{event__groups_8c_ae98d5f1271845ad42742aef9659e1568}{eventWAIT\_FOR\_ALL\_BITS} ), xTicksToWait );
233 
234                 \textcolor{comment}{/* This assignment is obsolete as uxReturn will get set after}
235 \textcolor{comment}{                the task unblocks, but some compilers mistakenly generate a}
236 \textcolor{comment}{                warning about uxReturn being returned without being set if the}
237 \textcolor{comment}{                assignment is omitted. */}
238                 uxReturn = 0;
239             \}
240             \textcolor{keywordflow}{else}
241             \{
242                 \textcolor{comment}{/* The rendezvous bits were not set, but no block time was}
243 \textcolor{comment}{                specified - just return the current event bit value. */}
244                 uxReturn = pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits};
245                 xTimeoutOccurred = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
246             \}
247         \}
248     \}
249     xAlreadyYielded = \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
250 
251     \textcolor{keywordflow}{if}( xTicksToWait != ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0 )
252     \{
253         \textcolor{keywordflow}{if}( xAlreadyYielded == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
254         \{
255             \hyperlink{FreeRTOS_8h_af4484fc07631a16e45ac5f29a3f0556e}{portYIELD\_WITHIN\_API}();
256         \}
257         \textcolor{keywordflow}{else}
258         \{
259             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
260         \}
261 
262         \textcolor{comment}{/* The task blocked to wait for its required bits to be set - at this}
263 \textcolor{comment}{        point either the required bits were set or the block time expired.  If}
264 \textcolor{comment}{        the required bits were set they will have been stored in the task's}
265 \textcolor{comment}{        event list item, and they should now be retrieved then cleared. */}
266         uxReturn = \hyperlink{task_8h_a7793b4bbe45c10d4c5104c126b89e87c}{uxTaskResetEventItemValue}();
267 
268         \textcolor{keywordflow}{if}( ( uxReturn & \hyperlink{event__groups_8c_ab451d5ad95813d5ec7ff1784d69e9ec3}{eventUNBLOCKED\_DUE\_TO\_BIT\_SET} ) == ( 
      \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} ) 0 )
269         \{
270             \textcolor{comment}{/* The task timed out, just return the current event bit value. */}
271             \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
272             \{
273                 uxReturn = pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits};
274 
275                 \textcolor{comment}{/* Although the task got here because it timed out before the}
276 \textcolor{comment}{                bits it was waiting for were set, it is possible that since it}
277 \textcolor{comment}{                unblocked another task has set the bits.  If this is the case}
278 \textcolor{comment}{                then it needs to clear the bits before exiting. */}
279                 \textcolor{keywordflow}{if}( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
280                 \{
281                     pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} &= ~uxBitsToWaitFor;
282                 \}
283                 \textcolor{keywordflow}{else}
284                 \{
285                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
286                 \}
287             \}
288             \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
289 
290             xTimeoutOccurred = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
291         \}
292         \textcolor{keywordflow}{else}
293         \{
294             \textcolor{comment}{/* The task unblocked because the bits were set. */}
295         \}
296 
297         \textcolor{comment}{/* Control bits might be set as the task had blocked should not be}
298 \textcolor{comment}{        returned. */}
299         uxReturn &= ~\hyperlink{event__groups_8c_a46c8292a6ba88b017cca402f5baf670b}{eventEVENT\_BITS\_CONTROL\_BYTES};
300     \}
301 
302     \hyperlink{FreeRTOS_8h_af0cb50e5a1402163cd29e638c6140a2e}{traceEVENT\_GROUP\_SYNC\_END}( xEventGroup, uxBitsToSet, uxBitsToWaitFor, 
      xTimeoutOccurred );
303 
304     \textcolor{comment}{/* Prevent compiler warnings when trace macros are not used. */}
305     ( void ) xTimeoutOccurred;
306 
307     \textcolor{keywordflow}{return} uxReturn;
308 \}
\end{DoxyCode}
\mbox{\Hypertarget{event__groups_8h_aab9d5b405bc57b7624dcabe9a9a503db}\label{event__groups_8h_aab9d5b405bc57b7624dcabe9a9a503db}} 
\index{event\+\_\+groups.\+h@{event\+\_\+groups.\+h}!x\+Event\+Group\+Wait\+Bits@{x\+Event\+Group\+Wait\+Bits}}
\index{x\+Event\+Group\+Wait\+Bits@{x\+Event\+Group\+Wait\+Bits}!event\+\_\+groups.\+h@{event\+\_\+groups.\+h}}
\subsubsection{\texorpdfstring{x\+Event\+Group\+Wait\+Bits()}{xEventGroupWaitBits()}}
{\footnotesize\ttfamily \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t} x\+Event\+Group\+Wait\+Bits (\begin{DoxyParamCaption}\item[{\hyperlink{event__groups_8h_acab96e0b6a5cab7f7b29822b79cc78ed}{Event\+Group\+Handle\+\_\+t}}]{x\+Event\+Group,  }\item[{const \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{Event\+Bits\+\_\+t}}]{ux\+Bits\+To\+Wait\+For,  }\item[{const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t}}]{x\+Clear\+On\+Exit,  }\item[{const \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{Base\+Type\+\_\+t}}]{x\+Wait\+For\+All\+Bits,  }\item[{\hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{Tick\+Type\+\_\+t}}]{x\+Ticks\+To\+Wait }\end{DoxyParamCaption})}



Definition at line 311 of file event\+\_\+groups.\+c.


\begin{DoxyCode}
312 \{
313 \hyperlink{structEventGroupDef__t}{EventGroup\_t} *pxEventBits = xEventGroup;
314 \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} uxReturn, uxControlBits = 0;
315 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xWaitConditionMet, xAlreadyYielded;
316 \hyperlink{pic32mx_2portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xTimeoutOccurred = \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE};
317 
318     \textcolor{comment}{/* Check the user is not attempting to wait on the bits used by the kernel}
319 \textcolor{comment}{    itself, and that at least one bit is being requested. */}
320     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( xEventGroup );
321     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( ( uxBitsToWaitFor & \hyperlink{event__groups_8c_a46c8292a6ba88b017cca402f5baf670b}{eventEVENT\_BITS\_CONTROL\_BYTES}
       ) == 0 );
322     \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( uxBitsToWaitFor != 0 );
323 \textcolor{preprocessor}{    #if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}
324     \{
325         \hyperlink{FreeRTOS_8h_a228c70cd48927d6ab730ed1a6dfbe35f}{configASSERT}( !( ( \hyperlink{task_8h_a0241000e08a261372186d34825a35979}{xTaskGetSchedulerState}() == 
      \hyperlink{task_8h_a0cad071ca127a35df93166e9ed5b6ada}{taskSCHEDULER\_SUSPENDED} ) && ( xTicksToWait != 0 ) ) );
326     \}
327 \textcolor{preprocessor}{    #endif}
328 
329     \hyperlink{task_8h_a366b302eba79d10b5ee2a3756f0fcc43}{vTaskSuspendAll}();
330     \{
331         \textcolor{keyword}{const} \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} uxCurrentEventBits = pxEventBits->
      \hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits};
332 
333         \textcolor{comment}{/* Check to see if the wait condition is already met or not. */}
334         xWaitConditionMet = \hyperlink{event__groups_8c_a152ce51000f6d8d26afbd14b4794e036}{prvTestWaitCondition}( uxCurrentEventBits, uxBitsToWaitFor, 
      xWaitForAllBits );
335 
336         \textcolor{keywordflow}{if}( xWaitConditionMet != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
337         \{
338             \textcolor{comment}{/* The wait condition has already been met so there is no need to}
339 \textcolor{comment}{            block. */}
340             uxReturn = uxCurrentEventBits;
341             xTicksToWait = ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0;
342 
343             \textcolor{comment}{/* Clear the wait bits if requested to do so. */}
344             \textcolor{keywordflow}{if}( xClearOnExit != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
345             \{
346                 pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} &= ~uxBitsToWaitFor;
347             \}
348             \textcolor{keywordflow}{else}
349             \{
350                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
351             \}
352         \}
353         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xTicksToWait == ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0 )
354         \{
355             \textcolor{comment}{/* The wait condition has not been met, but no block time was}
356 \textcolor{comment}{            specified, so just return the current value. */}
357             uxReturn = uxCurrentEventBits;
358             xTimeoutOccurred = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
359         \}
360         \textcolor{keywordflow}{else}
361         \{
362             \textcolor{comment}{/* The task is going to block to wait for its required bits to be}
363 \textcolor{comment}{            set.  uxControlBits are used to remember the specified behaviour of}
364 \textcolor{comment}{            this call to xEventGroupWaitBits() - for use when the event bits}
365 \textcolor{comment}{            unblock the task. */}
366             \textcolor{keywordflow}{if}( xClearOnExit != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
367             \{
368                 uxControlBits |= \hyperlink{event__groups_8c_a1404686af7c8070fa57675707c817abc}{eventCLEAR\_EVENTS\_ON\_EXIT\_BIT};
369             \}
370             \textcolor{keywordflow}{else}
371             \{
372                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
373             \}
374 
375             \textcolor{keywordflow}{if}( xWaitForAllBits != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
376             \{
377                 uxControlBits |= \hyperlink{event__groups_8c_ae98d5f1271845ad42742aef9659e1568}{eventWAIT\_FOR\_ALL\_BITS};
378             \}
379             \textcolor{keywordflow}{else}
380             \{
381                 \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
382             \}
383 
384             \textcolor{comment}{/* Store the bits that the calling task is waiting for in the}
385 \textcolor{comment}{            task's event list item so the kernel knows when a match is}
386 \textcolor{comment}{            found.  Then enter the blocked state. */}
387             \hyperlink{task_8h_a9d52fa7b60cc6a7b4fd0846700d7834c}{vTaskPlaceOnUnorderedEventList}( &( pxEventBits->
      \hyperlink{structEventGroupDef__t_a3dd347560456bfe452415efb52760dc3}{xTasksWaitingForBits} ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
388 
389             \textcolor{comment}{/* This is obsolete as it will get set after the task unblocks, but}
390 \textcolor{comment}{            some compilers mistakenly generate a warning about the variable}
391 \textcolor{comment}{            being returned without being set if it is not done. */}
392             uxReturn = 0;
393 
394             \hyperlink{FreeRTOS_8h_aeb8953a9be153986d0e830acdf60445a}{traceEVENT\_GROUP\_WAIT\_BITS\_BLOCK}( xEventGroup, uxBitsToWaitFor 
      );
395         \}
396     \}
397     xAlreadyYielded = \hyperlink{task_8h_a003f8ae6d649225abd030cc76e1c7d0e}{xTaskResumeAll}();
398 
399     \textcolor{keywordflow}{if}( xTicksToWait != ( \hyperlink{pic32mx_2portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} ) 0 )
400     \{
401         \textcolor{keywordflow}{if}( xAlreadyYielded == \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
402         \{
403             \hyperlink{FreeRTOS_8h_af4484fc07631a16e45ac5f29a3f0556e}{portYIELD\_WITHIN\_API}();
404         \}
405         \textcolor{keywordflow}{else}
406         \{
407             \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
408         \}
409 
410         \textcolor{comment}{/* The task blocked to wait for its required bits to be set - at this}
411 \textcolor{comment}{        point either the required bits were set or the block time expired.  If}
412 \textcolor{comment}{        the required bits were set they will have been stored in the task's}
413 \textcolor{comment}{        event list item, and they should now be retrieved then cleared. */}
414         uxReturn = \hyperlink{task_8h_a7793b4bbe45c10d4c5104c126b89e87c}{uxTaskResetEventItemValue}();
415 
416         \textcolor{keywordflow}{if}( ( uxReturn & \hyperlink{event__groups_8c_ab451d5ad95813d5ec7ff1784d69e9ec3}{eventUNBLOCKED\_DUE\_TO\_BIT\_SET} ) == ( 
      \hyperlink{event__groups_8h_ab2f21b93db0b2a0ab64d7a81ff32ac2e}{EventBits\_t} ) 0 )
417         \{
418             \hyperlink{task_8h_ab7bf0ae866292ba8296091a9d5209689}{taskENTER\_CRITICAL}();
419             \{
420                 \textcolor{comment}{/* The task timed out, just return the current event bit value. */}
421                 uxReturn = pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits};
422 
423                 \textcolor{comment}{/* It is possible that the event bits were updated between this}
424 \textcolor{comment}{                task leaving the Blocked state and running again. */}
425                 \textcolor{keywordflow}{if}( \hyperlink{event__groups_8c_a152ce51000f6d8d26afbd14b4794e036}{prvTestWaitCondition}( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) 
      != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
426                 \{
427                     \textcolor{keywordflow}{if}( xClearOnExit != \hyperlink{projdefs_8h_aa56260e937e7e203026707e5ba944273}{pdFALSE} )
428                     \{
429                         pxEventBits->\hyperlink{structEventGroupDef__t_ab1bcd95a3330b71c55198b2352926643}{uxEventBits} &= ~uxBitsToWaitFor;
430                     \}
431                     \textcolor{keywordflow}{else}
432                     \{
433                         \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
434                     \}
435                 \}
436                 \textcolor{keywordflow}{else}
437                 \{
438                     \hyperlink{FreeRTOS_8h_ac77e2af1a6b0d38fbab36cf2aa96f1a8}{mtCOVERAGE\_TEST\_MARKER}();
439                 \}
440                 xTimeoutOccurred = \hyperlink{projdefs_8h_af268cf937960eb029256bd9c4d949fbe}{pdTRUE};
441             \}
442             \hyperlink{task_8h_aac8f36abc45ac4ee714bd6b81e3b1643}{taskEXIT\_CRITICAL}();
443         \}
444         \textcolor{keywordflow}{else}
445         \{
446             \textcolor{comment}{/* The task unblocked because the bits were set. */}
447         \}
448 
449         \textcolor{comment}{/* The task blocked so control bits may have been set. */}
450         uxReturn &= ~\hyperlink{event__groups_8c_a46c8292a6ba88b017cca402f5baf670b}{eventEVENT\_BITS\_CONTROL\_BYTES};
451     \}
452     \hyperlink{FreeRTOS_8h_ad7a6b7684053a41690cac487ccf4d927}{traceEVENT\_GROUP\_WAIT\_BITS\_END}( xEventGroup, uxBitsToWaitFor, 
      xTimeoutOccurred );
453 
454     \textcolor{comment}{/* Prevent compiler warnings when trace macros are not used. */}
455     ( void ) xTimeoutOccurred;
456 
457     \textcolor{keywordflow}{return} uxReturn;
458 \}
\end{DoxyCode}
